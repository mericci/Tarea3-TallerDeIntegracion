{"ast":null,"code":"var zrUtil = require(\"zrender/lib/core/util\");\n\nvar numberUtil = require(\"../../util/number\");\n\nvar indexOf = zrUtil.indexOf;\n\nfunction hasXOrY(item) {\n  return !(isNaN(parseFloat(item.x)) && isNaN(parseFloat(item.y)));\n}\n\nfunction hasXAndY(item) {\n  return !isNaN(parseFloat(item.x)) && !isNaN(parseFloat(item.y));\n}\n\nfunction getPrecision(data, valueAxisDim, dataIndex) {\n  var precision = -1;\n\n  do {\n    precision = Math.max(numberUtil.getPrecision(data.get(valueAxisDim, dataIndex)), precision);\n    data = data.stackedOn;\n  } while (data);\n\n  return precision;\n}\n\nfunction markerTypeCalculatorWithExtent(mlType, data, otherDataDim, targetDataDim, otherCoordIndex, targetCoordIndex) {\n  var coordArr = [];\n  var value = numCalculate(data, targetDataDim, mlType);\n  var dataIndex = data.indicesOfNearest(targetDataDim, value, true)[0];\n  coordArr[otherCoordIndex] = data.get(otherDataDim, dataIndex, true);\n  coordArr[targetCoordIndex] = data.get(targetDataDim, dataIndex, true);\n  var precision = getPrecision(data, targetDataDim, dataIndex);\n  precision = Math.min(precision, 20);\n\n  if (precision >= 0) {\n    coordArr[targetCoordIndex] = +coordArr[targetCoordIndex].toFixed(precision);\n  }\n\n  return coordArr;\n}\n\nvar curry = zrUtil.curry; // TODO Specified percent\n\nvar markerTypeCalculator = {\n  /**\n   * @method\n   * @param {module:echarts/data/List} data\n   * @param {string} baseAxisDim\n   * @param {string} valueAxisDim\n   */\n  min: curry(markerTypeCalculatorWithExtent, 'min'),\n\n  /**\n   * @method\n   * @param {module:echarts/data/List} data\n   * @param {string} baseAxisDim\n   * @param {string} valueAxisDim\n   */\n  max: curry(markerTypeCalculatorWithExtent, 'max'),\n\n  /**\n   * @method\n   * @param {module:echarts/data/List} data\n   * @param {string} baseAxisDim\n   * @param {string} valueAxisDim\n   */\n  average: curry(markerTypeCalculatorWithExtent, 'average')\n};\n/**\n * Transform markPoint data item to format used in List by do the following\n * 1. Calculate statistic like `max`, `min`, `average`\n * 2. Convert `item.xAxis`, `item.yAxis` to `item.coord` array\n * @param  {module:echarts/model/Series} seriesModel\n * @param  {module:echarts/coord/*} [coordSys]\n * @param  {Object} item\n * @return {Object}\n */\n\nfunction dataTransform(seriesModel, item) {\n  var data = seriesModel.getData();\n  var coordSys = seriesModel.coordinateSystem; // 1. If not specify the position with pixel directly\n  // 2. If `coord` is not a data array. Which uses `xAxis`,\n  // `yAxis` to specify the coord on each dimension\n  // parseFloat first because item.x and item.y can be percent string like '20%'\n\n  if (item && !hasXAndY(item) && !zrUtil.isArray(item.coord) && coordSys) {\n    var dims = coordSys.dimensions;\n    var axisInfo = getAxisInfo(item, data, coordSys, seriesModel); // Clone the option\n    // Transform the properties xAxis, yAxis, radiusAxis, angleAxis, geoCoord to value\n\n    item = zrUtil.clone(item);\n\n    if (item.type && markerTypeCalculator[item.type] && axisInfo.baseAxis && axisInfo.valueAxis) {\n      var otherCoordIndex = indexOf(dims, axisInfo.baseAxis.dim);\n      var targetCoordIndex = indexOf(dims, axisInfo.valueAxis.dim);\n      item.coord = markerTypeCalculator[item.type](data, axisInfo.baseDataDim, axisInfo.valueDataDim, otherCoordIndex, targetCoordIndex); // Force to use the value of calculated value.\n\n      item.value = item.coord[targetCoordIndex];\n    } else {\n      // FIXME Only has one of xAxis and yAxis.\n      var coord = [item.xAxis != null ? item.xAxis : item.radiusAxis, item.yAxis != null ? item.yAxis : item.angleAxis]; // Each coord support max, min, average\n\n      for (var i = 0; i < 2; i++) {\n        if (markerTypeCalculator[coord[i]]) {\n          var dataDim = seriesModel.coordDimToDataDim(dims[i])[0];\n          coord[i] = numCalculate(data, dataDim, coord[i]);\n        }\n      }\n\n      item.coord = coord;\n    }\n  }\n\n  return item;\n}\n\nfunction getAxisInfo(item, data, coordSys, seriesModel) {\n  var ret = {};\n\n  if (item.valueIndex != null || item.valueDim != null) {\n    ret.valueDataDim = item.valueIndex != null ? data.getDimension(item.valueIndex) : item.valueDim;\n    ret.valueAxis = coordSys.getAxis(seriesModel.dataDimToCoordDim(ret.valueDataDim));\n    ret.baseAxis = coordSys.getOtherAxis(ret.valueAxis);\n    ret.baseDataDim = seriesModel.coordDimToDataDim(ret.baseAxis.dim)[0];\n  } else {\n    ret.baseAxis = seriesModel.getBaseAxis();\n    ret.valueAxis = coordSys.getOtherAxis(ret.baseAxis);\n    ret.baseDataDim = seriesModel.coordDimToDataDim(ret.baseAxis.dim)[0];\n    ret.valueDataDim = seriesModel.coordDimToDataDim(ret.valueAxis.dim)[0];\n  }\n\n  return ret;\n}\n/**\n * Filter data which is out of coordinateSystem range\n * [dataFilter description]\n * @param  {module:echarts/coord/*} [coordSys]\n * @param  {Object} item\n * @return {boolean}\n */\n\n\nfunction dataFilter(coordSys, item) {\n  // Alwalys return true if there is no coordSys\n  return coordSys && coordSys.containData && item.coord && !hasXOrY(item) ? coordSys.containData(item.coord) : true;\n}\n\nfunction dimValueGetter(item, dimName, dataIndex, dimIndex) {\n  // x, y, radius, angle\n  if (dimIndex < 2) {\n    return item.coord && item.coord[dimIndex];\n  }\n\n  return item.value;\n}\n\nfunction numCalculate(data, valueDataDim, type) {\n  if (type === 'average') {\n    var sum = 0;\n    var count = 0;\n    data.each(valueDataDim, function (val, idx) {\n      if (!isNaN(val)) {\n        sum += val;\n        count++;\n      }\n    }, true);\n    return sum / count;\n  } else {\n    return data.getDataExtent(valueDataDim, true)[type === 'max' ? 1 : 0];\n  }\n}\n\nexports.dataTransform = dataTransform;\nexports.getAxisInfo = getAxisInfo;\nexports.dataFilter = dataFilter;\nexports.dimValueGetter = dimValueGetter;\nexports.numCalculate = numCalculate;","map":{"version":3,"sources":["/home/martin/Escritorio/Taller de Integracion/Tarea3-TallerDeIntegracion/node_modules/react-echarts/node_modules/echarts/lib/component/marker/markerHelper.js"],"names":["zrUtil","require","numberUtil","indexOf","hasXOrY","item","isNaN","parseFloat","x","y","hasXAndY","getPrecision","data","valueAxisDim","dataIndex","precision","Math","max","get","stackedOn","markerTypeCalculatorWithExtent","mlType","otherDataDim","targetDataDim","otherCoordIndex","targetCoordIndex","coordArr","value","numCalculate","indicesOfNearest","min","toFixed","curry","markerTypeCalculator","average","dataTransform","seriesModel","getData","coordSys","coordinateSystem","isArray","coord","dims","dimensions","axisInfo","getAxisInfo","clone","type","baseAxis","valueAxis","dim","baseDataDim","valueDataDim","xAxis","radiusAxis","yAxis","angleAxis","i","dataDim","coordDimToDataDim","ret","valueIndex","valueDim","getDimension","getAxis","dataDimToCoordDim","getOtherAxis","getBaseAxis","dataFilter","containData","dimValueGetter","dimName","dimIndex","sum","count","each","val","idx","getDataExtent","exports"],"mappings":"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","sourcesContent":["var zrUtil = require(\"zrender/lib/core/util\");\n\nvar numberUtil = require(\"../../util/number\");\n\nvar indexOf = zrUtil.indexOf;\n\nfunction hasXOrY(item) {\n  return !(isNaN(parseFloat(item.x)) && isNaN(parseFloat(item.y)));\n}\n\nfunction hasXAndY(item) {\n  return !isNaN(parseFloat(item.x)) && !isNaN(parseFloat(item.y));\n}\n\nfunction getPrecision(data, valueAxisDim, dataIndex) {\n  var precision = -1;\n\n  do {\n    precision = Math.max(numberUtil.getPrecision(data.get(valueAxisDim, dataIndex)), precision);\n    data = data.stackedOn;\n  } while (data);\n\n  return precision;\n}\n\nfunction markerTypeCalculatorWithExtent(mlType, data, otherDataDim, targetDataDim, otherCoordIndex, targetCoordIndex) {\n  var coordArr = [];\n  var value = numCalculate(data, targetDataDim, mlType);\n  var dataIndex = data.indicesOfNearest(targetDataDim, value, true)[0];\n  coordArr[otherCoordIndex] = data.get(otherDataDim, dataIndex, true);\n  coordArr[targetCoordIndex] = data.get(targetDataDim, dataIndex, true);\n  var precision = getPrecision(data, targetDataDim, dataIndex);\n  precision = Math.min(precision, 20);\n\n  if (precision >= 0) {\n    coordArr[targetCoordIndex] = +coordArr[targetCoordIndex].toFixed(precision);\n  }\n\n  return coordArr;\n}\n\nvar curry = zrUtil.curry; // TODO Specified percent\n\nvar markerTypeCalculator = {\n  /**\n   * @method\n   * @param {module:echarts/data/List} data\n   * @param {string} baseAxisDim\n   * @param {string} valueAxisDim\n   */\n  min: curry(markerTypeCalculatorWithExtent, 'min'),\n\n  /**\n   * @method\n   * @param {module:echarts/data/List} data\n   * @param {string} baseAxisDim\n   * @param {string} valueAxisDim\n   */\n  max: curry(markerTypeCalculatorWithExtent, 'max'),\n\n  /**\n   * @method\n   * @param {module:echarts/data/List} data\n   * @param {string} baseAxisDim\n   * @param {string} valueAxisDim\n   */\n  average: curry(markerTypeCalculatorWithExtent, 'average')\n};\n/**\n * Transform markPoint data item to format used in List by do the following\n * 1. Calculate statistic like `max`, `min`, `average`\n * 2. Convert `item.xAxis`, `item.yAxis` to `item.coord` array\n * @param  {module:echarts/model/Series} seriesModel\n * @param  {module:echarts/coord/*} [coordSys]\n * @param  {Object} item\n * @return {Object}\n */\n\nfunction dataTransform(seriesModel, item) {\n  var data = seriesModel.getData();\n  var coordSys = seriesModel.coordinateSystem; // 1. If not specify the position with pixel directly\n  // 2. If `coord` is not a data array. Which uses `xAxis`,\n  // `yAxis` to specify the coord on each dimension\n  // parseFloat first because item.x and item.y can be percent string like '20%'\n\n  if (item && !hasXAndY(item) && !zrUtil.isArray(item.coord) && coordSys) {\n    var dims = coordSys.dimensions;\n    var axisInfo = getAxisInfo(item, data, coordSys, seriesModel); // Clone the option\n    // Transform the properties xAxis, yAxis, radiusAxis, angleAxis, geoCoord to value\n\n    item = zrUtil.clone(item);\n\n    if (item.type && markerTypeCalculator[item.type] && axisInfo.baseAxis && axisInfo.valueAxis) {\n      var otherCoordIndex = indexOf(dims, axisInfo.baseAxis.dim);\n      var targetCoordIndex = indexOf(dims, axisInfo.valueAxis.dim);\n      item.coord = markerTypeCalculator[item.type](data, axisInfo.baseDataDim, axisInfo.valueDataDim, otherCoordIndex, targetCoordIndex); // Force to use the value of calculated value.\n\n      item.value = item.coord[targetCoordIndex];\n    } else {\n      // FIXME Only has one of xAxis and yAxis.\n      var coord = [item.xAxis != null ? item.xAxis : item.radiusAxis, item.yAxis != null ? item.yAxis : item.angleAxis]; // Each coord support max, min, average\n\n      for (var i = 0; i < 2; i++) {\n        if (markerTypeCalculator[coord[i]]) {\n          var dataDim = seriesModel.coordDimToDataDim(dims[i])[0];\n          coord[i] = numCalculate(data, dataDim, coord[i]);\n        }\n      }\n\n      item.coord = coord;\n    }\n  }\n\n  return item;\n}\n\nfunction getAxisInfo(item, data, coordSys, seriesModel) {\n  var ret = {};\n\n  if (item.valueIndex != null || item.valueDim != null) {\n    ret.valueDataDim = item.valueIndex != null ? data.getDimension(item.valueIndex) : item.valueDim;\n    ret.valueAxis = coordSys.getAxis(seriesModel.dataDimToCoordDim(ret.valueDataDim));\n    ret.baseAxis = coordSys.getOtherAxis(ret.valueAxis);\n    ret.baseDataDim = seriesModel.coordDimToDataDim(ret.baseAxis.dim)[0];\n  } else {\n    ret.baseAxis = seriesModel.getBaseAxis();\n    ret.valueAxis = coordSys.getOtherAxis(ret.baseAxis);\n    ret.baseDataDim = seriesModel.coordDimToDataDim(ret.baseAxis.dim)[0];\n    ret.valueDataDim = seriesModel.coordDimToDataDim(ret.valueAxis.dim)[0];\n  }\n\n  return ret;\n}\n/**\n * Filter data which is out of coordinateSystem range\n * [dataFilter description]\n * @param  {module:echarts/coord/*} [coordSys]\n * @param  {Object} item\n * @return {boolean}\n */\n\n\nfunction dataFilter(coordSys, item) {\n  // Alwalys return true if there is no coordSys\n  return coordSys && coordSys.containData && item.coord && !hasXOrY(item) ? coordSys.containData(item.coord) : true;\n}\n\nfunction dimValueGetter(item, dimName, dataIndex, dimIndex) {\n  // x, y, radius, angle\n  if (dimIndex < 2) {\n    return item.coord && item.coord[dimIndex];\n  }\n\n  return item.value;\n}\n\nfunction numCalculate(data, valueDataDim, type) {\n  if (type === 'average') {\n    var sum = 0;\n    var count = 0;\n    data.each(valueDataDim, function (val, idx) {\n      if (!isNaN(val)) {\n        sum += val;\n        count++;\n      }\n    }, true);\n    return sum / count;\n  } else {\n    return data.getDataExtent(valueDataDim, true)[type === 'max' ? 1 : 0];\n  }\n}\n\nexports.dataTransform = dataTransform;\nexports.getAxisInfo = getAxisInfo;\nexports.dataFilter = dataFilter;\nexports.dimValueGetter = dimValueGetter;\nexports.numCalculate = numCalculate;"]},"metadata":{},"sourceType":"script"}