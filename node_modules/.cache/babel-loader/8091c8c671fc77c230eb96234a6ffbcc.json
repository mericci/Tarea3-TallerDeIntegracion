{"ast":null,"code":"var Path = require(\"zrender/lib/graphic/Path\");\n\nvar vec2 = require(\"zrender/lib/core/vector\");\n\nvar fixClipWithShadow = require(\"zrender/lib/graphic/helper/fixClipWithShadow\"); // Poly path support NaN point\n\n\nvar vec2Min = vec2.min;\nvar vec2Max = vec2.max;\nvar scaleAndAdd = vec2.scaleAndAdd;\nvar v2Copy = vec2.copy; // Temporary variable\n\nvar v = [];\nvar cp0 = [];\nvar cp1 = [];\n\nfunction isPointNull(p) {\n  return isNaN(p[0]) || isNaN(p[1]);\n}\n\nfunction drawSegment(ctx, points, start, segLen, allLen, dir, smoothMin, smoothMax, smooth, smoothMonotone, connectNulls) {\n  var prevIdx = 0;\n  var idx = start;\n\n  for (var k = 0; k < segLen; k++) {\n    var p = points[idx];\n\n    if (idx >= allLen || idx < 0) {\n      break;\n    }\n\n    if (isPointNull(p)) {\n      if (connectNulls) {\n        idx += dir;\n        continue;\n      }\n\n      break;\n    }\n\n    if (idx === start) {\n      ctx[dir > 0 ? 'moveTo' : 'lineTo'](p[0], p[1]);\n      v2Copy(cp0, p);\n    } else {\n      if (smooth > 0) {\n        var nextIdx = idx + dir;\n        var nextP = points[nextIdx];\n\n        if (connectNulls) {\n          // Find next point not null\n          while (nextP && isPointNull(points[nextIdx])) {\n            nextIdx += dir;\n            nextP = points[nextIdx];\n          }\n        }\n\n        var ratioNextSeg = 0.5;\n        var prevP = points[prevIdx];\n        var nextP = points[nextIdx]; // Last point\n\n        if (!nextP || isPointNull(nextP)) {\n          v2Copy(cp1, p);\n        } else {\n          // If next data is null in not connect case\n          if (isPointNull(nextP) && !connectNulls) {\n            nextP = p;\n          }\n\n          vec2.sub(v, nextP, prevP);\n          var lenPrevSeg;\n          var lenNextSeg;\n\n          if (smoothMonotone === 'x' || smoothMonotone === 'y') {\n            var dim = smoothMonotone === 'x' ? 0 : 1;\n            lenPrevSeg = Math.abs(p[dim] - prevP[dim]);\n            lenNextSeg = Math.abs(p[dim] - nextP[dim]);\n          } else {\n            lenPrevSeg = vec2.dist(p, prevP);\n            lenNextSeg = vec2.dist(p, nextP);\n          } // Use ratio of seg length\n\n\n          ratioNextSeg = lenNextSeg / (lenNextSeg + lenPrevSeg);\n          scaleAndAdd(cp1, p, v, -smooth * (1 - ratioNextSeg));\n        } // Smooth constraint\n\n\n        vec2Min(cp0, cp0, smoothMax);\n        vec2Max(cp0, cp0, smoothMin);\n        vec2Min(cp1, cp1, smoothMax);\n        vec2Max(cp1, cp1, smoothMin);\n        ctx.bezierCurveTo(cp0[0], cp0[1], cp1[0], cp1[1], p[0], p[1]); // cp0 of next segment\n\n        scaleAndAdd(cp0, p, v, smooth * ratioNextSeg);\n      } else {\n        ctx.lineTo(p[0], p[1]);\n      }\n    }\n\n    prevIdx = idx;\n    idx += dir;\n  }\n\n  return k;\n}\n\nfunction getBoundingBox(points, smoothConstraint) {\n  var ptMin = [Infinity, Infinity];\n  var ptMax = [-Infinity, -Infinity];\n\n  if (smoothConstraint) {\n    for (var i = 0; i < points.length; i++) {\n      var pt = points[i];\n\n      if (pt[0] < ptMin[0]) {\n        ptMin[0] = pt[0];\n      }\n\n      if (pt[1] < ptMin[1]) {\n        ptMin[1] = pt[1];\n      }\n\n      if (pt[0] > ptMax[0]) {\n        ptMax[0] = pt[0];\n      }\n\n      if (pt[1] > ptMax[1]) {\n        ptMax[1] = pt[1];\n      }\n    }\n  }\n\n  return {\n    min: smoothConstraint ? ptMin : ptMax,\n    max: smoothConstraint ? ptMax : ptMin\n  };\n}\n\nvar Polyline = Path.extend({\n  type: 'ec-polyline',\n  shape: {\n    points: [],\n    smooth: 0,\n    smoothConstraint: true,\n    smoothMonotone: null,\n    connectNulls: false\n  },\n  style: {\n    fill: null,\n    stroke: '#000'\n  },\n  brush: fixClipWithShadow(Path.prototype.brush),\n  buildPath: function (ctx, shape) {\n    var points = shape.points;\n    var i = 0;\n    var len = points.length;\n    var result = getBoundingBox(points, shape.smoothConstraint);\n\n    if (shape.connectNulls) {\n      // Must remove first and last null values avoid draw error in polygon\n      for (; len > 0; len--) {\n        if (!isPointNull(points[len - 1])) {\n          break;\n        }\n      }\n\n      for (; i < len; i++) {\n        if (!isPointNull(points[i])) {\n          break;\n        }\n      }\n    }\n\n    while (i < len) {\n      i += drawSegment(ctx, points, i, len, len, 1, result.min, result.max, shape.smooth, shape.smoothMonotone, shape.connectNulls) + 1;\n    }\n  }\n});\nvar Polygon = Path.extend({\n  type: 'ec-polygon',\n  shape: {\n    points: [],\n    // Offset between stacked base points and points\n    stackedOnPoints: [],\n    smooth: 0,\n    stackedOnSmooth: 0,\n    smoothConstraint: true,\n    smoothMonotone: null,\n    connectNulls: false\n  },\n  brush: fixClipWithShadow(Path.prototype.brush),\n  buildPath: function (ctx, shape) {\n    var points = shape.points;\n    var stackedOnPoints = shape.stackedOnPoints;\n    var i = 0;\n    var len = points.length;\n    var smoothMonotone = shape.smoothMonotone;\n    var bbox = getBoundingBox(points, shape.smoothConstraint);\n    var stackedOnBBox = getBoundingBox(stackedOnPoints, shape.smoothConstraint);\n\n    if (shape.connectNulls) {\n      // Must remove first and last null values avoid draw error in polygon\n      for (; len > 0; len--) {\n        if (!isPointNull(points[len - 1])) {\n          break;\n        }\n      }\n\n      for (; i < len; i++) {\n        if (!isPointNull(points[i])) {\n          break;\n        }\n      }\n    }\n\n    while (i < len) {\n      var k = drawSegment(ctx, points, i, len, len, 1, bbox.min, bbox.max, shape.smooth, smoothMonotone, shape.connectNulls);\n      drawSegment(ctx, stackedOnPoints, i + k - 1, k, len, -1, stackedOnBBox.min, stackedOnBBox.max, shape.stackedOnSmooth, smoothMonotone, shape.connectNulls);\n      i += k + 1;\n      ctx.closePath();\n    }\n  }\n});\nexports.Polyline = Polyline;\nexports.Polygon = Polygon;","map":{"version":3,"sources":["/home/martin/Escritorio/Taller de Integracion/Tarea3-TallerDeIntegracion/node_modules/react-echarts/node_modules/echarts/lib/chart/line/poly.js"],"names":["Path","require","vec2","fixClipWithShadow","vec2Min","min","vec2Max","max","scaleAndAdd","v2Copy","copy","v","cp0","cp1","isPointNull","p","isNaN","drawSegment","ctx","points","start","segLen","allLen","dir","smoothMin","smoothMax","smooth","smoothMonotone","connectNulls","prevIdx","idx","k","nextIdx","nextP","ratioNextSeg","prevP","sub","lenPrevSeg","lenNextSeg","dim","Math","abs","dist","bezierCurveTo","lineTo","getBoundingBox","smoothConstraint","ptMin","Infinity","ptMax","i","length","pt","Polyline","extend","type","shape","style","fill","stroke","brush","prototype","buildPath","len","result","Polygon","stackedOnPoints","stackedOnSmooth","bbox","stackedOnBBox","closePath","exports"],"mappings":"AAAA,IAAIA,IAAI,GAAGC,OAAO,CAAC,0BAAD,CAAlB;;AAEA,IAAIC,IAAI,GAAGD,OAAO,CAAC,yBAAD,CAAlB;;AAEA,IAAIE,iBAAiB,GAAGF,OAAO,CAAC,8CAAD,CAA/B,C,CAEA;;;AACA,IAAIG,OAAO,GAAGF,IAAI,CAACG,GAAnB;AACA,IAAIC,OAAO,GAAGJ,IAAI,CAACK,GAAnB;AACA,IAAIC,WAAW,GAAGN,IAAI,CAACM,WAAvB;AACA,IAAIC,MAAM,GAAGP,IAAI,CAACQ,IAAlB,C,CAAwB;;AAExB,IAAIC,CAAC,GAAG,EAAR;AACA,IAAIC,GAAG,GAAG,EAAV;AACA,IAAIC,GAAG,GAAG,EAAV;;AAEA,SAASC,WAAT,CAAqBC,CAArB,EAAwB;AACtB,SAAOC,KAAK,CAACD,CAAC,CAAC,CAAD,CAAF,CAAL,IAAeC,KAAK,CAACD,CAAC,CAAC,CAAD,CAAF,CAA3B;AACD;;AAED,SAASE,WAAT,CAAqBC,GAArB,EAA0BC,MAA1B,EAAkCC,KAAlC,EAAyCC,MAAzC,EAAiDC,MAAjD,EAAyDC,GAAzD,EAA8DC,SAA9D,EAAyEC,SAAzE,EAAoFC,MAApF,EAA4FC,cAA5F,EAA4GC,YAA5G,EAA0H;AACxH,MAAIC,OAAO,GAAG,CAAd;AACA,MAAIC,GAAG,GAAGV,KAAV;;AAEA,OAAK,IAAIW,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGV,MAApB,EAA4BU,CAAC,EAA7B,EAAiC;AAC/B,QAAIhB,CAAC,GAAGI,MAAM,CAACW,GAAD,CAAd;;AAEA,QAAIA,GAAG,IAAIR,MAAP,IAAiBQ,GAAG,GAAG,CAA3B,EAA8B;AAC5B;AACD;;AAED,QAAIhB,WAAW,CAACC,CAAD,CAAf,EAAoB;AAClB,UAAIa,YAAJ,EAAkB;AAChBE,QAAAA,GAAG,IAAIP,GAAP;AACA;AACD;;AAED;AACD;;AAED,QAAIO,GAAG,KAAKV,KAAZ,EAAmB;AACjBF,MAAAA,GAAG,CAACK,GAAG,GAAG,CAAN,GAAU,QAAV,GAAqB,QAAtB,CAAH,CAAmCR,CAAC,CAAC,CAAD,CAApC,EAAyCA,CAAC,CAAC,CAAD,CAA1C;AACAN,MAAAA,MAAM,CAACG,GAAD,EAAMG,CAAN,CAAN;AACD,KAHD,MAGO;AACL,UAAIW,MAAM,GAAG,CAAb,EAAgB;AACd,YAAIM,OAAO,GAAGF,GAAG,GAAGP,GAApB;AACA,YAAIU,KAAK,GAAGd,MAAM,CAACa,OAAD,CAAlB;;AAEA,YAAIJ,YAAJ,EAAkB;AAChB;AACA,iBAAOK,KAAK,IAAInB,WAAW,CAACK,MAAM,CAACa,OAAD,CAAP,CAA3B,EAA8C;AAC5CA,YAAAA,OAAO,IAAIT,GAAX;AACAU,YAAAA,KAAK,GAAGd,MAAM,CAACa,OAAD,CAAd;AACD;AACF;;AAED,YAAIE,YAAY,GAAG,GAAnB;AACA,YAAIC,KAAK,GAAGhB,MAAM,CAACU,OAAD,CAAlB;AACA,YAAII,KAAK,GAAGd,MAAM,CAACa,OAAD,CAAlB,CAdc,CAce;;AAE7B,YAAI,CAACC,KAAD,IAAUnB,WAAW,CAACmB,KAAD,CAAzB,EAAkC;AAChCxB,UAAAA,MAAM,CAACI,GAAD,EAAME,CAAN,CAAN;AACD,SAFD,MAEO;AACL;AACA,cAAID,WAAW,CAACmB,KAAD,CAAX,IAAsB,CAACL,YAA3B,EAAyC;AACvCK,YAAAA,KAAK,GAAGlB,CAAR;AACD;;AAEDb,UAAAA,IAAI,CAACkC,GAAL,CAASzB,CAAT,EAAYsB,KAAZ,EAAmBE,KAAnB;AACA,cAAIE,UAAJ;AACA,cAAIC,UAAJ;;AAEA,cAAIX,cAAc,KAAK,GAAnB,IAA0BA,cAAc,KAAK,GAAjD,EAAsD;AACpD,gBAAIY,GAAG,GAAGZ,cAAc,KAAK,GAAnB,GAAyB,CAAzB,GAA6B,CAAvC;AACAU,YAAAA,UAAU,GAAGG,IAAI,CAACC,GAAL,CAAS1B,CAAC,CAACwB,GAAD,CAAD,GAASJ,KAAK,CAACI,GAAD,CAAvB,CAAb;AACAD,YAAAA,UAAU,GAAGE,IAAI,CAACC,GAAL,CAAS1B,CAAC,CAACwB,GAAD,CAAD,GAASN,KAAK,CAACM,GAAD,CAAvB,CAAb;AACD,WAJD,MAIO;AACLF,YAAAA,UAAU,GAAGnC,IAAI,CAACwC,IAAL,CAAU3B,CAAV,EAAaoB,KAAb,CAAb;AACAG,YAAAA,UAAU,GAAGpC,IAAI,CAACwC,IAAL,CAAU3B,CAAV,EAAakB,KAAb,CAAb;AACD,WAjBI,CAiBH;;;AAGFC,UAAAA,YAAY,GAAGI,UAAU,IAAIA,UAAU,GAAGD,UAAjB,CAAzB;AACA7B,UAAAA,WAAW,CAACK,GAAD,EAAME,CAAN,EAASJ,CAAT,EAAY,CAACe,MAAD,IAAW,IAAIQ,YAAf,CAAZ,CAAX;AACD,SAxCa,CAwCZ;;;AAGF9B,QAAAA,OAAO,CAACQ,GAAD,EAAMA,GAAN,EAAWa,SAAX,CAAP;AACAnB,QAAAA,OAAO,CAACM,GAAD,EAAMA,GAAN,EAAWY,SAAX,CAAP;AACApB,QAAAA,OAAO,CAACS,GAAD,EAAMA,GAAN,EAAWY,SAAX,CAAP;AACAnB,QAAAA,OAAO,CAACO,GAAD,EAAMA,GAAN,EAAWW,SAAX,CAAP;AACAN,QAAAA,GAAG,CAACyB,aAAJ,CAAkB/B,GAAG,CAAC,CAAD,CAArB,EAA0BA,GAAG,CAAC,CAAD,CAA7B,EAAkCC,GAAG,CAAC,CAAD,CAArC,EAA0CA,GAAG,CAAC,CAAD,CAA7C,EAAkDE,CAAC,CAAC,CAAD,CAAnD,EAAwDA,CAAC,CAAC,CAAD,CAAzD,EA/Cc,CA+CiD;;AAE/DP,QAAAA,WAAW,CAACI,GAAD,EAAMG,CAAN,EAASJ,CAAT,EAAYe,MAAM,GAAGQ,YAArB,CAAX;AACD,OAlDD,MAkDO;AACLhB,QAAAA,GAAG,CAAC0B,MAAJ,CAAW7B,CAAC,CAAC,CAAD,CAAZ,EAAiBA,CAAC,CAAC,CAAD,CAAlB;AACD;AACF;;AAEDc,IAAAA,OAAO,GAAGC,GAAV;AACAA,IAAAA,GAAG,IAAIP,GAAP;AACD;;AAED,SAAOQ,CAAP;AACD;;AAED,SAASc,cAAT,CAAwB1B,MAAxB,EAAgC2B,gBAAhC,EAAkD;AAChD,MAAIC,KAAK,GAAG,CAACC,QAAD,EAAWA,QAAX,CAAZ;AACA,MAAIC,KAAK,GAAG,CAAC,CAACD,QAAF,EAAY,CAACA,QAAb,CAAZ;;AAEA,MAAIF,gBAAJ,EAAsB;AACpB,SAAK,IAAII,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAG/B,MAAM,CAACgC,MAA3B,EAAmCD,CAAC,EAApC,EAAwC;AACtC,UAAIE,EAAE,GAAGjC,MAAM,CAAC+B,CAAD,CAAf;;AAEA,UAAIE,EAAE,CAAC,CAAD,CAAF,GAAQL,KAAK,CAAC,CAAD,CAAjB,EAAsB;AACpBA,QAAAA,KAAK,CAAC,CAAD,CAAL,GAAWK,EAAE,CAAC,CAAD,CAAb;AACD;;AAED,UAAIA,EAAE,CAAC,CAAD,CAAF,GAAQL,KAAK,CAAC,CAAD,CAAjB,EAAsB;AACpBA,QAAAA,KAAK,CAAC,CAAD,CAAL,GAAWK,EAAE,CAAC,CAAD,CAAb;AACD;;AAED,UAAIA,EAAE,CAAC,CAAD,CAAF,GAAQH,KAAK,CAAC,CAAD,CAAjB,EAAsB;AACpBA,QAAAA,KAAK,CAAC,CAAD,CAAL,GAAWG,EAAE,CAAC,CAAD,CAAb;AACD;;AAED,UAAIA,EAAE,CAAC,CAAD,CAAF,GAAQH,KAAK,CAAC,CAAD,CAAjB,EAAsB;AACpBA,QAAAA,KAAK,CAAC,CAAD,CAAL,GAAWG,EAAE,CAAC,CAAD,CAAb;AACD;AACF;AACF;;AAED,SAAO;AACL/C,IAAAA,GAAG,EAAEyC,gBAAgB,GAAGC,KAAH,GAAWE,KAD3B;AAEL1C,IAAAA,GAAG,EAAEuC,gBAAgB,GAAGG,KAAH,GAAWF;AAF3B,GAAP;AAID;;AAED,IAAIM,QAAQ,GAAGrD,IAAI,CAACsD,MAAL,CAAY;AACzBC,EAAAA,IAAI,EAAE,aADmB;AAEzBC,EAAAA,KAAK,EAAE;AACLrC,IAAAA,MAAM,EAAE,EADH;AAELO,IAAAA,MAAM,EAAE,CAFH;AAGLoB,IAAAA,gBAAgB,EAAE,IAHb;AAILnB,IAAAA,cAAc,EAAE,IAJX;AAKLC,IAAAA,YAAY,EAAE;AALT,GAFkB;AASzB6B,EAAAA,KAAK,EAAE;AACLC,IAAAA,IAAI,EAAE,IADD;AAELC,IAAAA,MAAM,EAAE;AAFH,GATkB;AAazBC,EAAAA,KAAK,EAAEzD,iBAAiB,CAACH,IAAI,CAAC6D,SAAL,CAAeD,KAAhB,CAbC;AAczBE,EAAAA,SAAS,EAAE,UAAU5C,GAAV,EAAesC,KAAf,EAAsB;AAC/B,QAAIrC,MAAM,GAAGqC,KAAK,CAACrC,MAAnB;AACA,QAAI+B,CAAC,GAAG,CAAR;AACA,QAAIa,GAAG,GAAG5C,MAAM,CAACgC,MAAjB;AACA,QAAIa,MAAM,GAAGnB,cAAc,CAAC1B,MAAD,EAASqC,KAAK,CAACV,gBAAf,CAA3B;;AAEA,QAAIU,KAAK,CAAC5B,YAAV,EAAwB;AACtB;AACA,aAAOmC,GAAG,GAAG,CAAb,EAAgBA,GAAG,EAAnB,EAAuB;AACrB,YAAI,CAACjD,WAAW,CAACK,MAAM,CAAC4C,GAAG,GAAG,CAAP,CAAP,CAAhB,EAAmC;AACjC;AACD;AACF;;AAED,aAAOb,CAAC,GAAGa,GAAX,EAAgBb,CAAC,EAAjB,EAAqB;AACnB,YAAI,CAACpC,WAAW,CAACK,MAAM,CAAC+B,CAAD,CAAP,CAAhB,EAA6B;AAC3B;AACD;AACF;AACF;;AAED,WAAOA,CAAC,GAAGa,GAAX,EAAgB;AACdb,MAAAA,CAAC,IAAIjC,WAAW,CAACC,GAAD,EAAMC,MAAN,EAAc+B,CAAd,EAAiBa,GAAjB,EAAsBA,GAAtB,EAA2B,CAA3B,EAA8BC,MAAM,CAAC3D,GAArC,EAA0C2D,MAAM,CAACzD,GAAjD,EAAsDiD,KAAK,CAAC9B,MAA5D,EAAoE8B,KAAK,CAAC7B,cAA1E,EAA0F6B,KAAK,CAAC5B,YAAhG,CAAX,GAA2H,CAAhI;AACD;AACF;AAtCwB,CAAZ,CAAf;AAwCA,IAAIqC,OAAO,GAAGjE,IAAI,CAACsD,MAAL,CAAY;AACxBC,EAAAA,IAAI,EAAE,YADkB;AAExBC,EAAAA,KAAK,EAAE;AACLrC,IAAAA,MAAM,EAAE,EADH;AAEL;AACA+C,IAAAA,eAAe,EAAE,EAHZ;AAILxC,IAAAA,MAAM,EAAE,CAJH;AAKLyC,IAAAA,eAAe,EAAE,CALZ;AAMLrB,IAAAA,gBAAgB,EAAE,IANb;AAOLnB,IAAAA,cAAc,EAAE,IAPX;AAQLC,IAAAA,YAAY,EAAE;AART,GAFiB;AAYxBgC,EAAAA,KAAK,EAAEzD,iBAAiB,CAACH,IAAI,CAAC6D,SAAL,CAAeD,KAAhB,CAZA;AAaxBE,EAAAA,SAAS,EAAE,UAAU5C,GAAV,EAAesC,KAAf,EAAsB;AAC/B,QAAIrC,MAAM,GAAGqC,KAAK,CAACrC,MAAnB;AACA,QAAI+C,eAAe,GAAGV,KAAK,CAACU,eAA5B;AACA,QAAIhB,CAAC,GAAG,CAAR;AACA,QAAIa,GAAG,GAAG5C,MAAM,CAACgC,MAAjB;AACA,QAAIxB,cAAc,GAAG6B,KAAK,CAAC7B,cAA3B;AACA,QAAIyC,IAAI,GAAGvB,cAAc,CAAC1B,MAAD,EAASqC,KAAK,CAACV,gBAAf,CAAzB;AACA,QAAIuB,aAAa,GAAGxB,cAAc,CAACqB,eAAD,EAAkBV,KAAK,CAACV,gBAAxB,CAAlC;;AAEA,QAAIU,KAAK,CAAC5B,YAAV,EAAwB;AACtB;AACA,aAAOmC,GAAG,GAAG,CAAb,EAAgBA,GAAG,EAAnB,EAAuB;AACrB,YAAI,CAACjD,WAAW,CAACK,MAAM,CAAC4C,GAAG,GAAG,CAAP,CAAP,CAAhB,EAAmC;AACjC;AACD;AACF;;AAED,aAAOb,CAAC,GAAGa,GAAX,EAAgBb,CAAC,EAAjB,EAAqB;AACnB,YAAI,CAACpC,WAAW,CAACK,MAAM,CAAC+B,CAAD,CAAP,CAAhB,EAA6B;AAC3B;AACD;AACF;AACF;;AAED,WAAOA,CAAC,GAAGa,GAAX,EAAgB;AACd,UAAIhC,CAAC,GAAGd,WAAW,CAACC,GAAD,EAAMC,MAAN,EAAc+B,CAAd,EAAiBa,GAAjB,EAAsBA,GAAtB,EAA2B,CAA3B,EAA8BK,IAAI,CAAC/D,GAAnC,EAAwC+D,IAAI,CAAC7D,GAA7C,EAAkDiD,KAAK,CAAC9B,MAAxD,EAAgEC,cAAhE,EAAgF6B,KAAK,CAAC5B,YAAtF,CAAnB;AACAX,MAAAA,WAAW,CAACC,GAAD,EAAMgD,eAAN,EAAuBhB,CAAC,GAAGnB,CAAJ,GAAQ,CAA/B,EAAkCA,CAAlC,EAAqCgC,GAArC,EAA0C,CAAC,CAA3C,EAA8CM,aAAa,CAAChE,GAA5D,EAAiEgE,aAAa,CAAC9D,GAA/E,EAAoFiD,KAAK,CAACW,eAA1F,EAA2GxC,cAA3G,EAA2H6B,KAAK,CAAC5B,YAAjI,CAAX;AACAsB,MAAAA,CAAC,IAAInB,CAAC,GAAG,CAAT;AACAb,MAAAA,GAAG,CAACoD,SAAJ;AACD;AACF;AA3CuB,CAAZ,CAAd;AA6CAC,OAAO,CAAClB,QAAR,GAAmBA,QAAnB;AACAkB,OAAO,CAACN,OAAR,GAAkBA,OAAlB","sourcesContent":["var Path = require(\"zrender/lib/graphic/Path\");\n\nvar vec2 = require(\"zrender/lib/core/vector\");\n\nvar fixClipWithShadow = require(\"zrender/lib/graphic/helper/fixClipWithShadow\");\n\n// Poly path support NaN point\nvar vec2Min = vec2.min;\nvar vec2Max = vec2.max;\nvar scaleAndAdd = vec2.scaleAndAdd;\nvar v2Copy = vec2.copy; // Temporary variable\n\nvar v = [];\nvar cp0 = [];\nvar cp1 = [];\n\nfunction isPointNull(p) {\n  return isNaN(p[0]) || isNaN(p[1]);\n}\n\nfunction drawSegment(ctx, points, start, segLen, allLen, dir, smoothMin, smoothMax, smooth, smoothMonotone, connectNulls) {\n  var prevIdx = 0;\n  var idx = start;\n\n  for (var k = 0; k < segLen; k++) {\n    var p = points[idx];\n\n    if (idx >= allLen || idx < 0) {\n      break;\n    }\n\n    if (isPointNull(p)) {\n      if (connectNulls) {\n        idx += dir;\n        continue;\n      }\n\n      break;\n    }\n\n    if (idx === start) {\n      ctx[dir > 0 ? 'moveTo' : 'lineTo'](p[0], p[1]);\n      v2Copy(cp0, p);\n    } else {\n      if (smooth > 0) {\n        var nextIdx = idx + dir;\n        var nextP = points[nextIdx];\n\n        if (connectNulls) {\n          // Find next point not null\n          while (nextP && isPointNull(points[nextIdx])) {\n            nextIdx += dir;\n            nextP = points[nextIdx];\n          }\n        }\n\n        var ratioNextSeg = 0.5;\n        var prevP = points[prevIdx];\n        var nextP = points[nextIdx]; // Last point\n\n        if (!nextP || isPointNull(nextP)) {\n          v2Copy(cp1, p);\n        } else {\n          // If next data is null in not connect case\n          if (isPointNull(nextP) && !connectNulls) {\n            nextP = p;\n          }\n\n          vec2.sub(v, nextP, prevP);\n          var lenPrevSeg;\n          var lenNextSeg;\n\n          if (smoothMonotone === 'x' || smoothMonotone === 'y') {\n            var dim = smoothMonotone === 'x' ? 0 : 1;\n            lenPrevSeg = Math.abs(p[dim] - prevP[dim]);\n            lenNextSeg = Math.abs(p[dim] - nextP[dim]);\n          } else {\n            lenPrevSeg = vec2.dist(p, prevP);\n            lenNextSeg = vec2.dist(p, nextP);\n          } // Use ratio of seg length\n\n\n          ratioNextSeg = lenNextSeg / (lenNextSeg + lenPrevSeg);\n          scaleAndAdd(cp1, p, v, -smooth * (1 - ratioNextSeg));\n        } // Smooth constraint\n\n\n        vec2Min(cp0, cp0, smoothMax);\n        vec2Max(cp0, cp0, smoothMin);\n        vec2Min(cp1, cp1, smoothMax);\n        vec2Max(cp1, cp1, smoothMin);\n        ctx.bezierCurveTo(cp0[0], cp0[1], cp1[0], cp1[1], p[0], p[1]); // cp0 of next segment\n\n        scaleAndAdd(cp0, p, v, smooth * ratioNextSeg);\n      } else {\n        ctx.lineTo(p[0], p[1]);\n      }\n    }\n\n    prevIdx = idx;\n    idx += dir;\n  }\n\n  return k;\n}\n\nfunction getBoundingBox(points, smoothConstraint) {\n  var ptMin = [Infinity, Infinity];\n  var ptMax = [-Infinity, -Infinity];\n\n  if (smoothConstraint) {\n    for (var i = 0; i < points.length; i++) {\n      var pt = points[i];\n\n      if (pt[0] < ptMin[0]) {\n        ptMin[0] = pt[0];\n      }\n\n      if (pt[1] < ptMin[1]) {\n        ptMin[1] = pt[1];\n      }\n\n      if (pt[0] > ptMax[0]) {\n        ptMax[0] = pt[0];\n      }\n\n      if (pt[1] > ptMax[1]) {\n        ptMax[1] = pt[1];\n      }\n    }\n  }\n\n  return {\n    min: smoothConstraint ? ptMin : ptMax,\n    max: smoothConstraint ? ptMax : ptMin\n  };\n}\n\nvar Polyline = Path.extend({\n  type: 'ec-polyline',\n  shape: {\n    points: [],\n    smooth: 0,\n    smoothConstraint: true,\n    smoothMonotone: null,\n    connectNulls: false\n  },\n  style: {\n    fill: null,\n    stroke: '#000'\n  },\n  brush: fixClipWithShadow(Path.prototype.brush),\n  buildPath: function (ctx, shape) {\n    var points = shape.points;\n    var i = 0;\n    var len = points.length;\n    var result = getBoundingBox(points, shape.smoothConstraint);\n\n    if (shape.connectNulls) {\n      // Must remove first and last null values avoid draw error in polygon\n      for (; len > 0; len--) {\n        if (!isPointNull(points[len - 1])) {\n          break;\n        }\n      }\n\n      for (; i < len; i++) {\n        if (!isPointNull(points[i])) {\n          break;\n        }\n      }\n    }\n\n    while (i < len) {\n      i += drawSegment(ctx, points, i, len, len, 1, result.min, result.max, shape.smooth, shape.smoothMonotone, shape.connectNulls) + 1;\n    }\n  }\n});\nvar Polygon = Path.extend({\n  type: 'ec-polygon',\n  shape: {\n    points: [],\n    // Offset between stacked base points and points\n    stackedOnPoints: [],\n    smooth: 0,\n    stackedOnSmooth: 0,\n    smoothConstraint: true,\n    smoothMonotone: null,\n    connectNulls: false\n  },\n  brush: fixClipWithShadow(Path.prototype.brush),\n  buildPath: function (ctx, shape) {\n    var points = shape.points;\n    var stackedOnPoints = shape.stackedOnPoints;\n    var i = 0;\n    var len = points.length;\n    var smoothMonotone = shape.smoothMonotone;\n    var bbox = getBoundingBox(points, shape.smoothConstraint);\n    var stackedOnBBox = getBoundingBox(stackedOnPoints, shape.smoothConstraint);\n\n    if (shape.connectNulls) {\n      // Must remove first and last null values avoid draw error in polygon\n      for (; len > 0; len--) {\n        if (!isPointNull(points[len - 1])) {\n          break;\n        }\n      }\n\n      for (; i < len; i++) {\n        if (!isPointNull(points[i])) {\n          break;\n        }\n      }\n    }\n\n    while (i < len) {\n      var k = drawSegment(ctx, points, i, len, len, 1, bbox.min, bbox.max, shape.smooth, smoothMonotone, shape.connectNulls);\n      drawSegment(ctx, stackedOnPoints, i + k - 1, k, len, -1, stackedOnBBox.min, stackedOnBBox.max, shape.stackedOnSmooth, smoothMonotone, shape.connectNulls);\n      i += k + 1;\n      ctx.closePath();\n    }\n  }\n});\nexports.Polyline = Polyline;\nexports.Polygon = Polygon;"]},"metadata":{},"sourceType":"script"}