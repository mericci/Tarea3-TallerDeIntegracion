{"ast":null,"code":"var zrUtil = require(\"zrender/lib/core/util\");\n\nvar zrColor = require(\"zrender/lib/tool/color\");\n\nvar _number = require(\"../util/number\");\n\nvar linearMap = _number.linearMap;\nvar each = zrUtil.each;\nvar isObject = zrUtil.isObject;\nvar CATEGORY_DEFAULT_VISUAL_INDEX = -1;\n/**\n * @param {Object} option\n * @param {string} [option.type] See visualHandlers.\n * @param {string} [option.mappingMethod] 'linear' or 'piecewise' or 'category' or 'fixed'\n * @param {Array.<number>=} [option.dataExtent] [minExtent, maxExtent],\n *                                              required when mappingMethod is 'linear'\n * @param {Array.<Object>=} [option.pieceList] [\n *                                             {value: someValue},\n *                                             {interval: [min1, max1], visual: {...}},\n *                                             {interval: [min2, max2]}\n *                                             ],\n *                                            required when mappingMethod is 'piecewise'.\n *                                            Visual for only each piece can be specified.\n * @param {Array.<string|Object>=} [option.categories] ['cate1', 'cate2']\n *                                            required when mappingMethod is 'category'.\n *                                            If no option.categories, categories is set\n *                                            as [0, 1, 2, ...].\n * @param {boolean} [option.loop=false] Whether loop mapping when mappingMethod is 'category'.\n * @param {(Array|Object|*)} [option.visual]  Visual data.\n *                                            when mappingMethod is 'category',\n *                                            visual data can be array or object\n *                                            (like: {cate1: '#222', none: '#fff'})\n *                                            or primary types (which represents\n *                                            defualt category visual), otherwise visual\n *                                            can be array or primary (which will be\n *                                            normalized to array).\n *\n */\n\nvar VisualMapping = function (option) {\n  var mappingMethod = option.mappingMethod;\n  var visualType = option.type;\n  /**\n   * @readOnly\n   * @type {Object}\n   */\n\n  var thisOption = this.option = zrUtil.clone(option);\n  /**\n   * @readOnly\n   * @type {string}\n   */\n\n  this.type = visualType;\n  /**\n   * @readOnly\n   * @type {string}\n   */\n\n  this.mappingMethod = mappingMethod;\n  /**\n   * @private\n   * @type {Function}\n   */\n\n  this._normalizeData = normalizers[mappingMethod];\n  var visualHandler = visualHandlers[visualType];\n  /**\n   * @public\n   * @type {Function}\n   */\n\n  this.applyVisual = visualHandler.applyVisual;\n  /**\n   * @public\n   * @type {Function}\n   */\n\n  this.getColorMapper = visualHandler.getColorMapper;\n  /**\n   * @private\n   * @type {Function}\n   */\n\n  this._doMap = visualHandler._doMap[mappingMethod];\n\n  if (mappingMethod === 'piecewise') {\n    normalizeVisualRange(thisOption);\n    preprocessForPiecewise(thisOption);\n  } else if (mappingMethod === 'category') {\n    thisOption.categories ? preprocessForSpecifiedCategory(thisOption) // categories is ordinal when thisOption.categories not specified,\n    // which need no more preprocess except normalize visual.\n    : normalizeVisualRange(thisOption, true);\n  } else {\n    // mappingMethod === 'linear' or 'fixed'\n    zrUtil.assert(mappingMethod !== 'linear' || thisOption.dataExtent);\n    normalizeVisualRange(thisOption);\n  }\n};\n\nVisualMapping.prototype = {\n  constructor: VisualMapping,\n  mapValueToVisual: function (value) {\n    var normalized = this._normalizeData(value);\n\n    return this._doMap(normalized, value);\n  },\n  getNormalizer: function () {\n    return zrUtil.bind(this._normalizeData, this);\n  }\n};\nvar visualHandlers = VisualMapping.visualHandlers = {\n  color: {\n    applyVisual: makeApplyVisual('color'),\n\n    /**\n     * Create a mapper function\n     * @return {Function}\n     */\n    getColorMapper: function () {\n      var thisOption = this.option;\n      return zrUtil.bind(thisOption.mappingMethod === 'category' ? function (value, isNormalized) {\n        !isNormalized && (value = this._normalizeData(value));\n        return doMapCategory.call(this, value);\n      } : function (value, isNormalized, out) {\n        // If output rgb array\n        // which will be much faster and useful in pixel manipulation\n        var returnRGBArray = !!out;\n        !isNormalized && (value = this._normalizeData(value));\n        out = zrColor.fastLerp(value, thisOption.parsedVisual, out);\n        return returnRGBArray ? out : zrColor.stringify(out, 'rgba');\n      }, this);\n    },\n    _doMap: {\n      linear: function (normalized) {\n        return zrColor.stringify(zrColor.fastLerp(normalized, this.option.parsedVisual), 'rgba');\n      },\n      category: doMapCategory,\n      piecewise: function (normalized, value) {\n        var result = getSpecifiedVisual.call(this, value);\n\n        if (result == null) {\n          result = zrColor.stringify(zrColor.fastLerp(normalized, this.option.parsedVisual), 'rgba');\n        }\n\n        return result;\n      },\n      fixed: doMapFixed\n    }\n  },\n  colorHue: makePartialColorVisualHandler(function (color, value) {\n    return zrColor.modifyHSL(color, value);\n  }),\n  colorSaturation: makePartialColorVisualHandler(function (color, value) {\n    return zrColor.modifyHSL(color, null, value);\n  }),\n  colorLightness: makePartialColorVisualHandler(function (color, value) {\n    return zrColor.modifyHSL(color, null, null, value);\n  }),\n  colorAlpha: makePartialColorVisualHandler(function (color, value) {\n    return zrColor.modifyAlpha(color, value);\n  }),\n  opacity: {\n    applyVisual: makeApplyVisual('opacity'),\n    _doMap: makeDoMap([0, 1])\n  },\n  symbol: {\n    applyVisual: function (value, getter, setter) {\n      var symbolCfg = this.mapValueToVisual(value);\n\n      if (zrUtil.isString(symbolCfg)) {\n        setter('symbol', symbolCfg);\n      } else if (isObject(symbolCfg)) {\n        for (var name in symbolCfg) {\n          if (symbolCfg.hasOwnProperty(name)) {\n            setter(name, symbolCfg[name]);\n          }\n        }\n      }\n    },\n    _doMap: {\n      linear: doMapToArray,\n      category: doMapCategory,\n      piecewise: function (normalized, value) {\n        var result = getSpecifiedVisual.call(this, value);\n\n        if (result == null) {\n          result = doMapToArray.call(this, normalized);\n        }\n\n        return result;\n      },\n      fixed: doMapFixed\n    }\n  },\n  symbolSize: {\n    applyVisual: makeApplyVisual('symbolSize'),\n    _doMap: makeDoMap([0, 1])\n  }\n};\n\nfunction preprocessForPiecewise(thisOption) {\n  var pieceList = thisOption.pieceList;\n  thisOption.hasSpecialVisual = false;\n  zrUtil.each(pieceList, function (piece, index) {\n    piece.originIndex = index; // piece.visual is \"result visual value\" but not\n    // a visual range, so it does not need to be normalized.\n\n    if (piece.visual != null) {\n      thisOption.hasSpecialVisual = true;\n    }\n  });\n}\n\nfunction preprocessForSpecifiedCategory(thisOption) {\n  // Hash categories.\n  var categories = thisOption.categories;\n  var visual = thisOption.visual;\n  var categoryMap = thisOption.categoryMap = {};\n  each(categories, function (cate, index) {\n    categoryMap[cate] = index;\n  }); // Process visual map input.\n\n  if (!zrUtil.isArray(visual)) {\n    var visualArr = [];\n\n    if (zrUtil.isObject(visual)) {\n      each(visual, function (v, cate) {\n        var index = categoryMap[cate];\n        visualArr[index != null ? index : CATEGORY_DEFAULT_VISUAL_INDEX] = v;\n      });\n    } else {\n      // Is primary type, represents default visual.\n      visualArr[CATEGORY_DEFAULT_VISUAL_INDEX] = visual;\n    }\n\n    visual = setVisualToOption(thisOption, visualArr);\n  } // Remove categories that has no visual,\n  // then we can mapping them to CATEGORY_DEFAULT_VISUAL_INDEX.\n\n\n  for (var i = categories.length - 1; i >= 0; i--) {\n    if (visual[i] == null) {\n      delete categoryMap[categories[i]];\n      categories.pop();\n    }\n  }\n}\n\nfunction normalizeVisualRange(thisOption, isCategory) {\n  var visual = thisOption.visual;\n  var visualArr = [];\n\n  if (zrUtil.isObject(visual)) {\n    each(visual, function (v) {\n      visualArr.push(v);\n    });\n  } else if (visual != null) {\n    visualArr.push(visual);\n  }\n\n  var doNotNeedPair = {\n    color: 1,\n    symbol: 1\n  };\n\n  if (!isCategory && visualArr.length === 1 && !doNotNeedPair.hasOwnProperty(thisOption.type)) {\n    // Do not care visualArr.length === 0, which is illegal.\n    visualArr[1] = visualArr[0];\n  }\n\n  setVisualToOption(thisOption, visualArr);\n}\n\nfunction makePartialColorVisualHandler(applyValue) {\n  return {\n    applyVisual: function (value, getter, setter) {\n      value = this.mapValueToVisual(value); // Must not be array value\n\n      setter('color', applyValue(getter('color'), value));\n    },\n    _doMap: makeDoMap([0, 1])\n  };\n}\n\nfunction doMapToArray(normalized) {\n  var visual = this.option.visual;\n  return visual[Math.round(linearMap(normalized, [0, 1], [0, visual.length - 1], true))] || {};\n}\n\nfunction makeApplyVisual(visualType) {\n  return function (value, getter, setter) {\n    setter(visualType, this.mapValueToVisual(value));\n  };\n}\n\nfunction doMapCategory(normalized) {\n  var visual = this.option.visual;\n  return visual[this.option.loop && normalized !== CATEGORY_DEFAULT_VISUAL_INDEX ? normalized % visual.length : normalized];\n}\n\nfunction doMapFixed() {\n  return this.option.visual[0];\n}\n\nfunction makeDoMap(sourceExtent) {\n  return {\n    linear: function (normalized) {\n      return linearMap(normalized, sourceExtent, this.option.visual, true);\n    },\n    category: doMapCategory,\n    piecewise: function (normalized, value) {\n      var result = getSpecifiedVisual.call(this, value);\n\n      if (result == null) {\n        result = linearMap(normalized, sourceExtent, this.option.visual, true);\n      }\n\n      return result;\n    },\n    fixed: doMapFixed\n  };\n}\n\nfunction getSpecifiedVisual(value) {\n  var thisOption = this.option;\n  var pieceList = thisOption.pieceList;\n\n  if (thisOption.hasSpecialVisual) {\n    var pieceIndex = VisualMapping.findPieceIndex(value, pieceList);\n    var piece = pieceList[pieceIndex];\n\n    if (piece && piece.visual) {\n      return piece.visual[this.type];\n    }\n  }\n}\n\nfunction setVisualToOption(thisOption, visualArr) {\n  thisOption.visual = visualArr;\n\n  if (thisOption.type === 'color') {\n    thisOption.parsedVisual = zrUtil.map(visualArr, function (item) {\n      return zrColor.parse(item);\n    });\n  }\n\n  return visualArr;\n}\n/**\n * Normalizers by mapping methods.\n */\n\n\nvar normalizers = {\n  linear: function (value) {\n    return linearMap(value, this.option.dataExtent, [0, 1], true);\n  },\n  piecewise: function (value) {\n    var pieceList = this.option.pieceList;\n    var pieceIndex = VisualMapping.findPieceIndex(value, pieceList, true);\n\n    if (pieceIndex != null) {\n      return linearMap(pieceIndex, [0, pieceList.length - 1], [0, 1], true);\n    }\n  },\n  category: function (value) {\n    var index = this.option.categories ? this.option.categoryMap[value] : value; // ordinal\n\n    return index == null ? CATEGORY_DEFAULT_VISUAL_INDEX : index;\n  },\n  fixed: zrUtil.noop\n};\n/**\n * List available visual types.\n *\n * @public\n * @return {Array.<string>}\n */\n\nVisualMapping.listVisualTypes = function () {\n  var visualTypes = [];\n  zrUtil.each(visualHandlers, function (handler, key) {\n    visualTypes.push(key);\n  });\n  return visualTypes;\n};\n/**\n * @public\n */\n\n\nVisualMapping.addVisualHandler = function (name, handler) {\n  visualHandlers[name] = handler;\n};\n/**\n * @public\n */\n\n\nVisualMapping.isValidType = function (visualType) {\n  return visualHandlers.hasOwnProperty(visualType);\n};\n/**\n * Convinent method.\n * Visual can be Object or Array or primary type.\n *\n * @public\n */\n\n\nVisualMapping.eachVisual = function (visual, callback, context) {\n  if (zrUtil.isObject(visual)) {\n    zrUtil.each(visual, callback, context);\n  } else {\n    callback.call(context, visual);\n  }\n};\n\nVisualMapping.mapVisual = function (visual, callback, context) {\n  var isPrimary;\n  var newVisual = zrUtil.isArray(visual) ? [] : zrUtil.isObject(visual) ? {} : (isPrimary = true, null);\n  VisualMapping.eachVisual(visual, function (v, key) {\n    var newVal = callback.call(context, v, key);\n    isPrimary ? newVisual = newVal : newVisual[key] = newVal;\n  });\n  return newVisual;\n};\n/**\n * @public\n * @param {Object} obj\n * @return {Object} new object containers visual values.\n *                 If no visuals, return null.\n */\n\n\nVisualMapping.retrieveVisuals = function (obj) {\n  var ret = {};\n  var hasVisual;\n  obj && each(visualHandlers, function (h, visualType) {\n    if (obj.hasOwnProperty(visualType)) {\n      ret[visualType] = obj[visualType];\n      hasVisual = true;\n    }\n  });\n  return hasVisual ? ret : null;\n};\n/**\n * Give order to visual types, considering colorSaturation, colorAlpha depends on color.\n *\n * @public\n * @param {(Object|Array)} visualTypes If Object, like: {color: ..., colorSaturation: ...}\n *                                     IF Array, like: ['color', 'symbol', 'colorSaturation']\n * @return {Array.<string>} Sorted visual types.\n */\n\n\nVisualMapping.prepareVisualTypes = function (visualTypes) {\n  if (isObject(visualTypes)) {\n    var types = [];\n    each(visualTypes, function (item, type) {\n      types.push(type);\n    });\n    visualTypes = types;\n  } else if (zrUtil.isArray(visualTypes)) {\n    visualTypes = visualTypes.slice();\n  } else {\n    return [];\n  }\n\n  visualTypes.sort(function (type1, type2) {\n    // color should be front of colorSaturation, colorAlpha, ...\n    // symbol and symbolSize do not matter.\n    return type2 === 'color' && type1 !== 'color' && type1.indexOf('color') === 0 ? 1 : -1;\n  });\n  return visualTypes;\n};\n/**\n * 'color', 'colorSaturation', 'colorAlpha', ... are depends on 'color'.\n * Other visuals are only depends on themself.\n *\n * @public\n * @param {string} visualType1\n * @param {string} visualType2\n * @return {boolean}\n */\n\n\nVisualMapping.dependsOn = function (visualType1, visualType2) {\n  return visualType2 === 'color' ? !!(visualType1 && visualType1.indexOf(visualType2) === 0) : visualType1 === visualType2;\n};\n/**\n * @param {number} value\n * @param {Array.<Object>} pieceList [{value: ..., interval: [min, max]}, ...]\n *                         Always from small to big.\n * @param {boolean} [findClosestWhenOutside=false]\n * @return {number} index\n */\n\n\nVisualMapping.findPieceIndex = function (value, pieceList, findClosestWhenOutside) {\n  var possibleI;\n  var abs = Infinity; // value has the higher priority.\n\n  for (var i = 0, len = pieceList.length; i < len; i++) {\n    var pieceValue = pieceList[i].value;\n\n    if (pieceValue != null) {\n      if (pieceValue === value // FIXME\n      // It is supposed to compare value according to value type of dimension,\n      // but currently value type can exactly be string or number.\n      // Compromise for numeric-like string (like '12'), especially\n      // in the case that visualMap.categories is ['22', '33'].\n      || typeof pieceValue === 'string' && pieceValue === value + '') {\n        return i;\n      }\n\n      findClosestWhenOutside && updatePossible(pieceValue, i);\n    }\n  }\n\n  for (var i = 0, len = pieceList.length; i < len; i++) {\n    var piece = pieceList[i];\n    var interval = piece.interval;\n    var close = piece.close;\n\n    if (interval) {\n      if (interval[0] === -Infinity) {\n        if (littleThan(close[1], value, interval[1])) {\n          return i;\n        }\n      } else if (interval[1] === Infinity) {\n        if (littleThan(close[0], interval[0], value)) {\n          return i;\n        }\n      } else if (littleThan(close[0], interval[0], value) && littleThan(close[1], value, interval[1])) {\n        return i;\n      }\n\n      findClosestWhenOutside && updatePossible(interval[0], i);\n      findClosestWhenOutside && updatePossible(interval[1], i);\n    }\n  }\n\n  if (findClosestWhenOutside) {\n    return value === Infinity ? pieceList.length - 1 : value === -Infinity ? 0 : possibleI;\n  }\n\n  function updatePossible(val, index) {\n    var newAbs = Math.abs(val - value);\n\n    if (newAbs < abs) {\n      abs = newAbs;\n      possibleI = index;\n    }\n  }\n};\n\nfunction littleThan(close, a, b) {\n  return close ? a <= b : a < b;\n}\n\nvar _default = VisualMapping;\nmodule.exports = _default;","map":{"version":3,"sources":["/home/martin/Escritorio/Taller de Integracion/Tarea3-TallerDeIntegracion/node_modules/react-echarts/node_modules/echarts/lib/visual/VisualMapping.js"],"names":["zrUtil","require","zrColor","_number","linearMap","each","isObject","CATEGORY_DEFAULT_VISUAL_INDEX","VisualMapping","option","mappingMethod","visualType","type","thisOption","clone","_normalizeData","normalizers","visualHandler","visualHandlers","applyVisual","getColorMapper","_doMap","normalizeVisualRange","preprocessForPiecewise","categories","preprocessForSpecifiedCategory","assert","dataExtent","prototype","constructor","mapValueToVisual","value","normalized","getNormalizer","bind","color","makeApplyVisual","isNormalized","doMapCategory","call","out","returnRGBArray","fastLerp","parsedVisual","stringify","linear","category","piecewise","result","getSpecifiedVisual","fixed","doMapFixed","colorHue","makePartialColorVisualHandler","modifyHSL","colorSaturation","colorLightness","colorAlpha","modifyAlpha","opacity","makeDoMap","symbol","getter","setter","symbolCfg","isString","name","hasOwnProperty","doMapToArray","symbolSize","pieceList","hasSpecialVisual","piece","index","originIndex","visual","categoryMap","cate","isArray","visualArr","v","setVisualToOption","i","length","pop","isCategory","push","doNotNeedPair","applyValue","Math","round","loop","sourceExtent","pieceIndex","findPieceIndex","map","item","parse","noop","listVisualTypes","visualTypes","handler","key","addVisualHandler","isValidType","eachVisual","callback","context","mapVisual","isPrimary","newVisual","newVal","retrieveVisuals","obj","ret","hasVisual","h","prepareVisualTypes","types","slice","sort","type1","type2","indexOf","dependsOn","visualType1","visualType2","findClosestWhenOutside","possibleI","abs","Infinity","len","pieceValue","updatePossible","interval","close","littleThan","val","newAbs","a","b","_default","module","exports"],"mappings":"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","sourcesContent":["var zrUtil = require(\"zrender/lib/core/util\");\n\nvar zrColor = require(\"zrender/lib/tool/color\");\n\nvar _number = require(\"../util/number\");\n\nvar linearMap = _number.linearMap;\nvar each = zrUtil.each;\nvar isObject = zrUtil.isObject;\nvar CATEGORY_DEFAULT_VISUAL_INDEX = -1;\n/**\n * @param {Object} option\n * @param {string} [option.type] See visualHandlers.\n * @param {string} [option.mappingMethod] 'linear' or 'piecewise' or 'category' or 'fixed'\n * @param {Array.<number>=} [option.dataExtent] [minExtent, maxExtent],\n *                                              required when mappingMethod is 'linear'\n * @param {Array.<Object>=} [option.pieceList] [\n *                                             {value: someValue},\n *                                             {interval: [min1, max1], visual: {...}},\n *                                             {interval: [min2, max2]}\n *                                             ],\n *                                            required when mappingMethod is 'piecewise'.\n *                                            Visual for only each piece can be specified.\n * @param {Array.<string|Object>=} [option.categories] ['cate1', 'cate2']\n *                                            required when mappingMethod is 'category'.\n *                                            If no option.categories, categories is set\n *                                            as [0, 1, 2, ...].\n * @param {boolean} [option.loop=false] Whether loop mapping when mappingMethod is 'category'.\n * @param {(Array|Object|*)} [option.visual]  Visual data.\n *                                            when mappingMethod is 'category',\n *                                            visual data can be array or object\n *                                            (like: {cate1: '#222', none: '#fff'})\n *                                            or primary types (which represents\n *                                            defualt category visual), otherwise visual\n *                                            can be array or primary (which will be\n *                                            normalized to array).\n *\n */\n\nvar VisualMapping = function (option) {\n  var mappingMethod = option.mappingMethod;\n  var visualType = option.type;\n  /**\n   * @readOnly\n   * @type {Object}\n   */\n\n  var thisOption = this.option = zrUtil.clone(option);\n  /**\n   * @readOnly\n   * @type {string}\n   */\n\n  this.type = visualType;\n  /**\n   * @readOnly\n   * @type {string}\n   */\n\n  this.mappingMethod = mappingMethod;\n  /**\n   * @private\n   * @type {Function}\n   */\n\n  this._normalizeData = normalizers[mappingMethod];\n  var visualHandler = visualHandlers[visualType];\n  /**\n   * @public\n   * @type {Function}\n   */\n\n  this.applyVisual = visualHandler.applyVisual;\n  /**\n   * @public\n   * @type {Function}\n   */\n\n  this.getColorMapper = visualHandler.getColorMapper;\n  /**\n   * @private\n   * @type {Function}\n   */\n\n  this._doMap = visualHandler._doMap[mappingMethod];\n\n  if (mappingMethod === 'piecewise') {\n    normalizeVisualRange(thisOption);\n    preprocessForPiecewise(thisOption);\n  } else if (mappingMethod === 'category') {\n    thisOption.categories ? preprocessForSpecifiedCategory(thisOption) // categories is ordinal when thisOption.categories not specified,\n    // which need no more preprocess except normalize visual.\n    : normalizeVisualRange(thisOption, true);\n  } else {\n    // mappingMethod === 'linear' or 'fixed'\n    zrUtil.assert(mappingMethod !== 'linear' || thisOption.dataExtent);\n    normalizeVisualRange(thisOption);\n  }\n};\n\nVisualMapping.prototype = {\n  constructor: VisualMapping,\n  mapValueToVisual: function (value) {\n    var normalized = this._normalizeData(value);\n\n    return this._doMap(normalized, value);\n  },\n  getNormalizer: function () {\n    return zrUtil.bind(this._normalizeData, this);\n  }\n};\nvar visualHandlers = VisualMapping.visualHandlers = {\n  color: {\n    applyVisual: makeApplyVisual('color'),\n\n    /**\n     * Create a mapper function\n     * @return {Function}\n     */\n    getColorMapper: function () {\n      var thisOption = this.option;\n      return zrUtil.bind(thisOption.mappingMethod === 'category' ? function (value, isNormalized) {\n        !isNormalized && (value = this._normalizeData(value));\n        return doMapCategory.call(this, value);\n      } : function (value, isNormalized, out) {\n        // If output rgb array\n        // which will be much faster and useful in pixel manipulation\n        var returnRGBArray = !!out;\n        !isNormalized && (value = this._normalizeData(value));\n        out = zrColor.fastLerp(value, thisOption.parsedVisual, out);\n        return returnRGBArray ? out : zrColor.stringify(out, 'rgba');\n      }, this);\n    },\n    _doMap: {\n      linear: function (normalized) {\n        return zrColor.stringify(zrColor.fastLerp(normalized, this.option.parsedVisual), 'rgba');\n      },\n      category: doMapCategory,\n      piecewise: function (normalized, value) {\n        var result = getSpecifiedVisual.call(this, value);\n\n        if (result == null) {\n          result = zrColor.stringify(zrColor.fastLerp(normalized, this.option.parsedVisual), 'rgba');\n        }\n\n        return result;\n      },\n      fixed: doMapFixed\n    }\n  },\n  colorHue: makePartialColorVisualHandler(function (color, value) {\n    return zrColor.modifyHSL(color, value);\n  }),\n  colorSaturation: makePartialColorVisualHandler(function (color, value) {\n    return zrColor.modifyHSL(color, null, value);\n  }),\n  colorLightness: makePartialColorVisualHandler(function (color, value) {\n    return zrColor.modifyHSL(color, null, null, value);\n  }),\n  colorAlpha: makePartialColorVisualHandler(function (color, value) {\n    return zrColor.modifyAlpha(color, value);\n  }),\n  opacity: {\n    applyVisual: makeApplyVisual('opacity'),\n    _doMap: makeDoMap([0, 1])\n  },\n  symbol: {\n    applyVisual: function (value, getter, setter) {\n      var symbolCfg = this.mapValueToVisual(value);\n\n      if (zrUtil.isString(symbolCfg)) {\n        setter('symbol', symbolCfg);\n      } else if (isObject(symbolCfg)) {\n        for (var name in symbolCfg) {\n          if (symbolCfg.hasOwnProperty(name)) {\n            setter(name, symbolCfg[name]);\n          }\n        }\n      }\n    },\n    _doMap: {\n      linear: doMapToArray,\n      category: doMapCategory,\n      piecewise: function (normalized, value) {\n        var result = getSpecifiedVisual.call(this, value);\n\n        if (result == null) {\n          result = doMapToArray.call(this, normalized);\n        }\n\n        return result;\n      },\n      fixed: doMapFixed\n    }\n  },\n  symbolSize: {\n    applyVisual: makeApplyVisual('symbolSize'),\n    _doMap: makeDoMap([0, 1])\n  }\n};\n\nfunction preprocessForPiecewise(thisOption) {\n  var pieceList = thisOption.pieceList;\n  thisOption.hasSpecialVisual = false;\n  zrUtil.each(pieceList, function (piece, index) {\n    piece.originIndex = index; // piece.visual is \"result visual value\" but not\n    // a visual range, so it does not need to be normalized.\n\n    if (piece.visual != null) {\n      thisOption.hasSpecialVisual = true;\n    }\n  });\n}\n\nfunction preprocessForSpecifiedCategory(thisOption) {\n  // Hash categories.\n  var categories = thisOption.categories;\n  var visual = thisOption.visual;\n  var categoryMap = thisOption.categoryMap = {};\n  each(categories, function (cate, index) {\n    categoryMap[cate] = index;\n  }); // Process visual map input.\n\n  if (!zrUtil.isArray(visual)) {\n    var visualArr = [];\n\n    if (zrUtil.isObject(visual)) {\n      each(visual, function (v, cate) {\n        var index = categoryMap[cate];\n        visualArr[index != null ? index : CATEGORY_DEFAULT_VISUAL_INDEX] = v;\n      });\n    } else {\n      // Is primary type, represents default visual.\n      visualArr[CATEGORY_DEFAULT_VISUAL_INDEX] = visual;\n    }\n\n    visual = setVisualToOption(thisOption, visualArr);\n  } // Remove categories that has no visual,\n  // then we can mapping them to CATEGORY_DEFAULT_VISUAL_INDEX.\n\n\n  for (var i = categories.length - 1; i >= 0; i--) {\n    if (visual[i] == null) {\n      delete categoryMap[categories[i]];\n      categories.pop();\n    }\n  }\n}\n\nfunction normalizeVisualRange(thisOption, isCategory) {\n  var visual = thisOption.visual;\n  var visualArr = [];\n\n  if (zrUtil.isObject(visual)) {\n    each(visual, function (v) {\n      visualArr.push(v);\n    });\n  } else if (visual != null) {\n    visualArr.push(visual);\n  }\n\n  var doNotNeedPair = {\n    color: 1,\n    symbol: 1\n  };\n\n  if (!isCategory && visualArr.length === 1 && !doNotNeedPair.hasOwnProperty(thisOption.type)) {\n    // Do not care visualArr.length === 0, which is illegal.\n    visualArr[1] = visualArr[0];\n  }\n\n  setVisualToOption(thisOption, visualArr);\n}\n\nfunction makePartialColorVisualHandler(applyValue) {\n  return {\n    applyVisual: function (value, getter, setter) {\n      value = this.mapValueToVisual(value); // Must not be array value\n\n      setter('color', applyValue(getter('color'), value));\n    },\n    _doMap: makeDoMap([0, 1])\n  };\n}\n\nfunction doMapToArray(normalized) {\n  var visual = this.option.visual;\n  return visual[Math.round(linearMap(normalized, [0, 1], [0, visual.length - 1], true))] || {};\n}\n\nfunction makeApplyVisual(visualType) {\n  return function (value, getter, setter) {\n    setter(visualType, this.mapValueToVisual(value));\n  };\n}\n\nfunction doMapCategory(normalized) {\n  var visual = this.option.visual;\n  return visual[this.option.loop && normalized !== CATEGORY_DEFAULT_VISUAL_INDEX ? normalized % visual.length : normalized];\n}\n\nfunction doMapFixed() {\n  return this.option.visual[0];\n}\n\nfunction makeDoMap(sourceExtent) {\n  return {\n    linear: function (normalized) {\n      return linearMap(normalized, sourceExtent, this.option.visual, true);\n    },\n    category: doMapCategory,\n    piecewise: function (normalized, value) {\n      var result = getSpecifiedVisual.call(this, value);\n\n      if (result == null) {\n        result = linearMap(normalized, sourceExtent, this.option.visual, true);\n      }\n\n      return result;\n    },\n    fixed: doMapFixed\n  };\n}\n\nfunction getSpecifiedVisual(value) {\n  var thisOption = this.option;\n  var pieceList = thisOption.pieceList;\n\n  if (thisOption.hasSpecialVisual) {\n    var pieceIndex = VisualMapping.findPieceIndex(value, pieceList);\n    var piece = pieceList[pieceIndex];\n\n    if (piece && piece.visual) {\n      return piece.visual[this.type];\n    }\n  }\n}\n\nfunction setVisualToOption(thisOption, visualArr) {\n  thisOption.visual = visualArr;\n\n  if (thisOption.type === 'color') {\n    thisOption.parsedVisual = zrUtil.map(visualArr, function (item) {\n      return zrColor.parse(item);\n    });\n  }\n\n  return visualArr;\n}\n/**\n * Normalizers by mapping methods.\n */\n\n\nvar normalizers = {\n  linear: function (value) {\n    return linearMap(value, this.option.dataExtent, [0, 1], true);\n  },\n  piecewise: function (value) {\n    var pieceList = this.option.pieceList;\n    var pieceIndex = VisualMapping.findPieceIndex(value, pieceList, true);\n\n    if (pieceIndex != null) {\n      return linearMap(pieceIndex, [0, pieceList.length - 1], [0, 1], true);\n    }\n  },\n  category: function (value) {\n    var index = this.option.categories ? this.option.categoryMap[value] : value; // ordinal\n\n    return index == null ? CATEGORY_DEFAULT_VISUAL_INDEX : index;\n  },\n  fixed: zrUtil.noop\n};\n/**\n * List available visual types.\n *\n * @public\n * @return {Array.<string>}\n */\n\nVisualMapping.listVisualTypes = function () {\n  var visualTypes = [];\n  zrUtil.each(visualHandlers, function (handler, key) {\n    visualTypes.push(key);\n  });\n  return visualTypes;\n};\n/**\n * @public\n */\n\n\nVisualMapping.addVisualHandler = function (name, handler) {\n  visualHandlers[name] = handler;\n};\n/**\n * @public\n */\n\n\nVisualMapping.isValidType = function (visualType) {\n  return visualHandlers.hasOwnProperty(visualType);\n};\n/**\n * Convinent method.\n * Visual can be Object or Array or primary type.\n *\n * @public\n */\n\n\nVisualMapping.eachVisual = function (visual, callback, context) {\n  if (zrUtil.isObject(visual)) {\n    zrUtil.each(visual, callback, context);\n  } else {\n    callback.call(context, visual);\n  }\n};\n\nVisualMapping.mapVisual = function (visual, callback, context) {\n  var isPrimary;\n  var newVisual = zrUtil.isArray(visual) ? [] : zrUtil.isObject(visual) ? {} : (isPrimary = true, null);\n  VisualMapping.eachVisual(visual, function (v, key) {\n    var newVal = callback.call(context, v, key);\n    isPrimary ? newVisual = newVal : newVisual[key] = newVal;\n  });\n  return newVisual;\n};\n/**\n * @public\n * @param {Object} obj\n * @return {Object} new object containers visual values.\n *                 If no visuals, return null.\n */\n\n\nVisualMapping.retrieveVisuals = function (obj) {\n  var ret = {};\n  var hasVisual;\n  obj && each(visualHandlers, function (h, visualType) {\n    if (obj.hasOwnProperty(visualType)) {\n      ret[visualType] = obj[visualType];\n      hasVisual = true;\n    }\n  });\n  return hasVisual ? ret : null;\n};\n/**\n * Give order to visual types, considering colorSaturation, colorAlpha depends on color.\n *\n * @public\n * @param {(Object|Array)} visualTypes If Object, like: {color: ..., colorSaturation: ...}\n *                                     IF Array, like: ['color', 'symbol', 'colorSaturation']\n * @return {Array.<string>} Sorted visual types.\n */\n\n\nVisualMapping.prepareVisualTypes = function (visualTypes) {\n  if (isObject(visualTypes)) {\n    var types = [];\n    each(visualTypes, function (item, type) {\n      types.push(type);\n    });\n    visualTypes = types;\n  } else if (zrUtil.isArray(visualTypes)) {\n    visualTypes = visualTypes.slice();\n  } else {\n    return [];\n  }\n\n  visualTypes.sort(function (type1, type2) {\n    // color should be front of colorSaturation, colorAlpha, ...\n    // symbol and symbolSize do not matter.\n    return type2 === 'color' && type1 !== 'color' && type1.indexOf('color') === 0 ? 1 : -1;\n  });\n  return visualTypes;\n};\n/**\n * 'color', 'colorSaturation', 'colorAlpha', ... are depends on 'color'.\n * Other visuals are only depends on themself.\n *\n * @public\n * @param {string} visualType1\n * @param {string} visualType2\n * @return {boolean}\n */\n\n\nVisualMapping.dependsOn = function (visualType1, visualType2) {\n  return visualType2 === 'color' ? !!(visualType1 && visualType1.indexOf(visualType2) === 0) : visualType1 === visualType2;\n};\n/**\n * @param {number} value\n * @param {Array.<Object>} pieceList [{value: ..., interval: [min, max]}, ...]\n *                         Always from small to big.\n * @param {boolean} [findClosestWhenOutside=false]\n * @return {number} index\n */\n\n\nVisualMapping.findPieceIndex = function (value, pieceList, findClosestWhenOutside) {\n  var possibleI;\n  var abs = Infinity; // value has the higher priority.\n\n  for (var i = 0, len = pieceList.length; i < len; i++) {\n    var pieceValue = pieceList[i].value;\n\n    if (pieceValue != null) {\n      if (pieceValue === value // FIXME\n      // It is supposed to compare value according to value type of dimension,\n      // but currently value type can exactly be string or number.\n      // Compromise for numeric-like string (like '12'), especially\n      // in the case that visualMap.categories is ['22', '33'].\n      || typeof pieceValue === 'string' && pieceValue === value + '') {\n        return i;\n      }\n\n      findClosestWhenOutside && updatePossible(pieceValue, i);\n    }\n  }\n\n  for (var i = 0, len = pieceList.length; i < len; i++) {\n    var piece = pieceList[i];\n    var interval = piece.interval;\n    var close = piece.close;\n\n    if (interval) {\n      if (interval[0] === -Infinity) {\n        if (littleThan(close[1], value, interval[1])) {\n          return i;\n        }\n      } else if (interval[1] === Infinity) {\n        if (littleThan(close[0], interval[0], value)) {\n          return i;\n        }\n      } else if (littleThan(close[0], interval[0], value) && littleThan(close[1], value, interval[1])) {\n        return i;\n      }\n\n      findClosestWhenOutside && updatePossible(interval[0], i);\n      findClosestWhenOutside && updatePossible(interval[1], i);\n    }\n  }\n\n  if (findClosestWhenOutside) {\n    return value === Infinity ? pieceList.length - 1 : value === -Infinity ? 0 : possibleI;\n  }\n\n  function updatePossible(val, index) {\n    var newAbs = Math.abs(val - value);\n\n    if (newAbs < abs) {\n      abs = newAbs;\n      possibleI = index;\n    }\n  }\n};\n\nfunction littleThan(close, a, b) {\n  return close ? a <= b : a < b;\n}\n\nvar _default = VisualMapping;\nmodule.exports = _default;"]},"metadata":{},"sourceType":"script"}