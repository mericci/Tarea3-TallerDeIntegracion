{"ast":null,"code":"var _config = require(\"./config\");\n\nvar devicePixelRatio = _config.devicePixelRatio;\n\nvar util = require(\"./core/util\");\n\nvar log = require(\"./core/log\");\n\nvar BoundingRect = require(\"./core/BoundingRect\");\n\nvar timsort = require(\"./core/timsort\");\n\nvar Layer = require(\"./Layer\");\n\nvar requestAnimationFrame = require(\"./animation/requestAnimationFrame\");\n\nvar Image = require(\"./graphic/Image\");\n/**\n * Default canvas painter\n * @module zrender/Painter\n * @author Kener (@Kener-林峰, kener.linfeng@gmail.com)\n *         errorrik (errorrik@gmail.com)\n *         pissang (https://www.github.com/pissang)\n */\n// PENDIGN\n// Layer exceeds MAX_PROGRESSIVE_LAYER_NUMBER may have some problem when flush directly second time.\n//\n// Maximum progressive layer. When exceeding this number. All elements will be drawed in the last layer.\n\n\nvar MAX_PROGRESSIVE_LAYER_NUMBER = 5;\n\nfunction parseInt10(val) {\n  return parseInt(val, 10);\n}\n\nfunction isLayerValid(layer) {\n  if (!layer) {\n    return false;\n  }\n\n  if (layer.__builtin__) {\n    return true;\n  }\n\n  if (typeof layer.resize !== 'function' || typeof layer.refresh !== 'function') {\n    return false;\n  }\n\n  return true;\n}\n\nfunction preProcessLayer(layer) {\n  layer.__unusedCount++;\n}\n\nfunction postProcessLayer(layer) {\n  if (layer.__unusedCount == 1) {\n    layer.clear();\n  }\n}\n\nvar tmpRect = new BoundingRect(0, 0, 0, 0);\nvar viewRect = new BoundingRect(0, 0, 0, 0);\n\nfunction isDisplayableCulled(el, width, height) {\n  tmpRect.copy(el.getBoundingRect());\n\n  if (el.transform) {\n    tmpRect.applyTransform(el.transform);\n  }\n\n  viewRect.width = width;\n  viewRect.height = height;\n  return !tmpRect.intersect(viewRect);\n}\n\nfunction isClipPathChanged(clipPaths, prevClipPaths) {\n  if (clipPaths == prevClipPaths) {\n    // Can both be null or undefined\n    return false;\n  }\n\n  if (!clipPaths || !prevClipPaths || clipPaths.length !== prevClipPaths.length) {\n    return true;\n  }\n\n  for (var i = 0; i < clipPaths.length; i++) {\n    if (clipPaths[i] !== prevClipPaths[i]) {\n      return true;\n    }\n  }\n}\n\nfunction doClip(clipPaths, ctx) {\n  for (var i = 0; i < clipPaths.length; i++) {\n    var clipPath = clipPaths[i];\n    clipPath.setTransform(ctx);\n    ctx.beginPath();\n    clipPath.buildPath(ctx, clipPath.shape);\n    ctx.clip(); // Transform back\n\n    clipPath.restoreTransform(ctx);\n  }\n}\n\nfunction createRoot(width, height) {\n  var domRoot = document.createElement('div'); // domRoot.onselectstart = returnFalse; // 避免页面选中的尴尬\n\n  domRoot.style.cssText = ['position:relative', 'overflow:hidden', 'width:' + width + 'px', 'height:' + height + 'px', 'padding:0', 'margin:0', 'border-width:0'].join(';') + ';';\n  return domRoot;\n}\n/**\n * @alias module:zrender/Painter\n * @constructor\n * @param {HTMLElement} root 绘图容器\n * @param {module:zrender/Storage} storage\n * @param {Object} opts\n */\n\n\nvar Painter = function (root, storage, opts) {\n  this.type = 'canvas'; // In node environment using node-canvas\n\n  var singleCanvas = !root.nodeName // In node ?\n  || root.nodeName.toUpperCase() === 'CANVAS';\n  this._opts = opts = util.extend({}, opts || {});\n  /**\n   * @type {number}\n   */\n\n  this.dpr = opts.devicePixelRatio || devicePixelRatio;\n  /**\n   * @type {boolean}\n   * @private\n   */\n\n  this._singleCanvas = singleCanvas;\n  /**\n   * 绘图容器\n   * @type {HTMLElement}\n   */\n\n  this.root = root;\n  var rootStyle = root.style;\n\n  if (rootStyle) {\n    rootStyle['-webkit-tap-highlight-color'] = 'transparent';\n    rootStyle['-webkit-user-select'] = rootStyle['user-select'] = rootStyle['-webkit-touch-callout'] = 'none';\n    root.innerHTML = '';\n  }\n  /**\n   * @type {module:zrender/Storage}\n   */\n\n\n  this.storage = storage;\n  /**\n   * @type {Array.<number>}\n   * @private\n   */\n\n  var zlevelList = this._zlevelList = [];\n  /**\n   * @type {Object.<string, module:zrender/Layer>}\n   * @private\n   */\n\n  var layers = this._layers = {};\n  /**\n   * @type {Object.<string, Object>}\n   * @type {private}\n   */\n\n  this._layerConfig = {};\n\n  if (!singleCanvas) {\n    this._width = this._getSize(0);\n    this._height = this._getSize(1);\n    var domRoot = this._domRoot = createRoot(this._width, this._height);\n    root.appendChild(domRoot);\n  } else {\n    if (opts.width != null) {\n      root.width = opts.width;\n    }\n\n    if (opts.height != null) {\n      root.height = opts.height;\n    } // Use canvas width and height directly\n\n\n    var width = root.width;\n    var height = root.height;\n    this._width = width;\n    this._height = height; // Create layer if only one given canvas\n    // Device pixel ratio is fixed to 1 because given canvas has its specified width and height\n\n    var mainLayer = new Layer(root, this, 1);\n    mainLayer.initContext(); // FIXME Use canvas width and height\n    // mainLayer.resize(width, height);\n\n    layers[0] = mainLayer;\n    zlevelList.push(0);\n    this._domRoot = root;\n  } // Layers for progressive rendering\n\n\n  this._progressiveLayers = [];\n  /**\n   * @type {module:zrender/Layer}\n   * @private\n   */\n\n  this._hoverlayer;\n  this._hoverElements = [];\n};\n\nPainter.prototype = {\n  constructor: Painter,\n  getType: function () {\n    return 'canvas';\n  },\n\n  /**\n   * If painter use a single canvas\n   * @return {boolean}\n   */\n  isSingleCanvas: function () {\n    return this._singleCanvas;\n  },\n\n  /**\n   * @return {HTMLDivElement}\n   */\n  getViewportRoot: function () {\n    return this._domRoot;\n  },\n  getViewportRootOffset: function () {\n    var viewportRoot = this.getViewportRoot();\n\n    if (viewportRoot) {\n      return {\n        offsetLeft: viewportRoot.offsetLeft || 0,\n        offsetTop: viewportRoot.offsetTop || 0\n      };\n    }\n  },\n\n  /**\n   * 刷新\n   * @param {boolean} [paintAll=false] 强制绘制所有displayable\n   */\n  refresh: function (paintAll) {\n    var list = this.storage.getDisplayList(true);\n    var zlevelList = this._zlevelList;\n\n    this._paintList(list, paintAll); // Paint custum layers\n\n\n    for (var i = 0; i < zlevelList.length; i++) {\n      var z = zlevelList[i];\n      var layer = this._layers[z];\n\n      if (!layer.__builtin__ && layer.refresh) {\n        layer.refresh();\n      }\n    }\n\n    this.refreshHover();\n\n    if (this._progressiveLayers.length) {\n      this._startProgessive();\n    }\n\n    return this;\n  },\n  addHover: function (el, hoverStyle) {\n    if (el.__hoverMir) {\n      return;\n    }\n\n    var elMirror = new el.constructor({\n      style: el.style,\n      shape: el.shape\n    });\n    elMirror.__from = el;\n    el.__hoverMir = elMirror;\n    elMirror.setStyle(hoverStyle);\n\n    this._hoverElements.push(elMirror);\n  },\n  removeHover: function (el) {\n    var elMirror = el.__hoverMir;\n    var hoverElements = this._hoverElements;\n    var idx = util.indexOf(hoverElements, elMirror);\n\n    if (idx >= 0) {\n      hoverElements.splice(idx, 1);\n    }\n\n    el.__hoverMir = null;\n  },\n  clearHover: function (el) {\n    var hoverElements = this._hoverElements;\n\n    for (var i = 0; i < hoverElements.length; i++) {\n      var from = hoverElements[i].__from;\n\n      if (from) {\n        from.__hoverMir = null;\n      }\n    }\n\n    hoverElements.length = 0;\n  },\n  refreshHover: function () {\n    var hoverElements = this._hoverElements;\n    var len = hoverElements.length;\n    var hoverLayer = this._hoverlayer;\n    hoverLayer && hoverLayer.clear();\n\n    if (!len) {\n      return;\n    }\n\n    timsort(hoverElements, this.storage.displayableSortFunc); // Use a extream large zlevel\n    // FIXME?\n\n    if (!hoverLayer) {\n      hoverLayer = this._hoverlayer = this.getLayer(1e5);\n    }\n\n    var scope = {};\n    hoverLayer.ctx.save();\n\n    for (var i = 0; i < len;) {\n      var el = hoverElements[i];\n      var originalEl = el.__from; // Original el is removed\n      // PENDING\n\n      if (!(originalEl && originalEl.__zr)) {\n        hoverElements.splice(i, 1);\n        originalEl.__hoverMir = null;\n        len--;\n        continue;\n      }\n\n      i++; // Use transform\n      // FIXME style and shape ?\n\n      if (!originalEl.invisible) {\n        el.transform = originalEl.transform;\n        el.invTransform = originalEl.invTransform;\n        el.__clipPaths = originalEl.__clipPaths; // el.\n\n        this._doPaintEl(el, hoverLayer, true, scope);\n      }\n    }\n\n    hoverLayer.ctx.restore();\n  },\n  _startProgessive: function () {\n    var self = this;\n\n    if (!self._furtherProgressive) {\n      return;\n    } // Use a token to stop progress steps triggered by\n    // previous zr.refresh calling.\n\n\n    var token = self._progressiveToken = +new Date();\n    self._progress++;\n    requestAnimationFrame(step);\n\n    function step() {\n      // In case refreshed or disposed\n      if (token === self._progressiveToken && self.storage) {\n        self._doPaintList(self.storage.getDisplayList());\n\n        if (self._furtherProgressive) {\n          self._progress++;\n          requestAnimationFrame(step);\n        } else {\n          self._progressiveToken = -1;\n        }\n      }\n    }\n  },\n  _clearProgressive: function () {\n    this._progressiveToken = -1;\n    this._progress = 0;\n    util.each(this._progressiveLayers, function (layer) {\n      layer.__dirty && layer.clear();\n    });\n  },\n  _paintList: function (list, paintAll) {\n    if (paintAll == null) {\n      paintAll = false;\n    }\n\n    this._updateLayerStatus(list);\n\n    this._clearProgressive();\n\n    this.eachBuiltinLayer(preProcessLayer);\n\n    this._doPaintList(list, paintAll);\n\n    this.eachBuiltinLayer(postProcessLayer);\n  },\n  _doPaintList: function (list, paintAll) {\n    var currentLayer;\n    var currentZLevel;\n    var ctx; // var invTransform = [];\n\n    var scope;\n    var progressiveLayerIdx = 0;\n    var currentProgressiveLayer;\n    var width = this._width;\n    var height = this._height;\n    var layerProgress;\n    var frame = this._progress;\n\n    function flushProgressiveLayer(layer) {\n      var dpr = ctx.dpr || 1;\n      ctx.save();\n      ctx.globalAlpha = 1;\n      ctx.shadowBlur = 0; // Avoid layer don't clear in next progressive frame\n\n      currentLayer.__dirty = true;\n      ctx.setTransform(1, 0, 0, 1, 0, 0);\n      ctx.drawImage(layer.dom, 0, 0, width * dpr, height * dpr);\n      ctx.restore();\n    }\n\n    for (var i = 0, l = list.length; i < l; i++) {\n      var el = list[i];\n      var elZLevel = this._singleCanvas ? 0 : el.zlevel;\n      var elFrame = el.__frame; // Flush at current context\n      // PENDING\n\n      if (elFrame < 0 && currentProgressiveLayer) {\n        flushProgressiveLayer(currentProgressiveLayer);\n        currentProgressiveLayer = null;\n      } // Change draw layer\n\n\n      if (currentZLevel !== elZLevel) {\n        if (ctx) {\n          ctx.restore();\n        } // Reset scope\n\n\n        scope = {}; // Only 0 zlevel if only has one canvas\n\n        currentZLevel = elZLevel;\n        currentLayer = this.getLayer(currentZLevel);\n\n        if (!currentLayer.__builtin__) {\n          log('ZLevel ' + currentZLevel + ' has been used by unkown layer ' + currentLayer.id);\n        }\n\n        ctx = currentLayer.ctx;\n        ctx.save(); // Reset the count\n\n        currentLayer.__unusedCount = 0;\n\n        if (currentLayer.__dirty || paintAll) {\n          currentLayer.clear();\n        }\n      }\n\n      if (!(currentLayer.__dirty || paintAll)) {\n        continue;\n      }\n\n      if (elFrame >= 0) {\n        // Progressive layer changed\n        if (!currentProgressiveLayer) {\n          currentProgressiveLayer = this._progressiveLayers[Math.min(progressiveLayerIdx++, MAX_PROGRESSIVE_LAYER_NUMBER - 1)];\n          currentProgressiveLayer.ctx.save();\n          currentProgressiveLayer.renderScope = {};\n\n          if (currentProgressiveLayer && currentProgressiveLayer.__progress > currentProgressiveLayer.__maxProgress) {\n            // flushProgressiveLayer(currentProgressiveLayer);\n            // Quick jump all progressive elements\n            // All progressive element are not dirty, jump over and flush directly\n            i = currentProgressiveLayer.__nextIdxNotProg - 1; // currentProgressiveLayer = null;\n\n            continue;\n          }\n\n          layerProgress = currentProgressiveLayer.__progress;\n\n          if (!currentProgressiveLayer.__dirty) {\n            // Keep rendering\n            frame = layerProgress;\n          }\n\n          currentProgressiveLayer.__progress = frame + 1;\n        }\n\n        if (elFrame === frame) {\n          this._doPaintEl(el, currentProgressiveLayer, true, currentProgressiveLayer.renderScope);\n        }\n      } else {\n        this._doPaintEl(el, currentLayer, paintAll, scope);\n      }\n\n      el.__dirty = false;\n    }\n\n    if (currentProgressiveLayer) {\n      flushProgressiveLayer(currentProgressiveLayer);\n    } // Restore the lastLayer ctx\n\n\n    ctx && ctx.restore(); // If still has clipping state\n    // if (scope.prevElClipPaths) {\n    //     ctx.restore();\n    // }\n\n    this._furtherProgressive = false;\n    util.each(this._progressiveLayers, function (layer) {\n      if (layer.__maxProgress >= layer.__progress) {\n        this._furtherProgressive = true;\n      }\n    }, this);\n  },\n  _doPaintEl: function (el, currentLayer, forcePaint, scope) {\n    var ctx = currentLayer.ctx;\n    var m = el.transform;\n\n    if ((currentLayer.__dirty || forcePaint) && // Ignore invisible element\n    !el.invisible // Ignore transparent element\n    && el.style.opacity !== 0 // Ignore scale 0 element, in some environment like node-canvas\n    // Draw a scale 0 element can cause all following draw wrong\n    // And setTransform with scale 0 will cause set back transform failed.\n    && !(m && !m[0] && !m[3]) // Ignore culled element\n    && !(el.culling && isDisplayableCulled(el, this._width, this._height))) {\n      var clipPaths = el.__clipPaths; // Optimize when clipping on group with several elements\n\n      if (scope.prevClipLayer !== currentLayer || isClipPathChanged(clipPaths, scope.prevElClipPaths)) {\n        // If has previous clipping state, restore from it\n        if (scope.prevElClipPaths) {\n          scope.prevClipLayer.ctx.restore();\n          scope.prevClipLayer = scope.prevElClipPaths = null; // Reset prevEl since context has been restored\n\n          scope.prevEl = null;\n        } // New clipping state\n\n\n        if (clipPaths) {\n          ctx.save();\n          doClip(clipPaths, ctx);\n          scope.prevClipLayer = currentLayer;\n          scope.prevElClipPaths = clipPaths;\n        }\n      }\n\n      el.beforeBrush && el.beforeBrush(ctx);\n      el.brush(ctx, scope.prevEl || null);\n      scope.prevEl = el;\n      el.afterBrush && el.afterBrush(ctx);\n    }\n  },\n\n  /**\n   * 获取 zlevel 所在层，如果不存在则会创建一个新的层\n   * @param {number} zlevel\n   * @return {module:zrender/Layer}\n   */\n  getLayer: function (zlevel) {\n    if (this._singleCanvas) {\n      return this._layers[0];\n    }\n\n    var layer = this._layers[zlevel];\n\n    if (!layer) {\n      // Create a new layer\n      layer = new Layer('zr_' + zlevel, this, this.dpr);\n      layer.__builtin__ = true;\n\n      if (this._layerConfig[zlevel]) {\n        util.merge(layer, this._layerConfig[zlevel], true);\n      }\n\n      this.insertLayer(zlevel, layer); // Context is created after dom inserted to document\n      // Or excanvas will get 0px clientWidth and clientHeight\n\n      layer.initContext();\n    }\n\n    return layer;\n  },\n  insertLayer: function (zlevel, layer) {\n    var layersMap = this._layers;\n    var zlevelList = this._zlevelList;\n    var len = zlevelList.length;\n    var prevLayer = null;\n    var i = -1;\n    var domRoot = this._domRoot;\n\n    if (layersMap[zlevel]) {\n      log('ZLevel ' + zlevel + ' has been used already');\n      return;\n    } // Check if is a valid layer\n\n\n    if (!isLayerValid(layer)) {\n      log('Layer of zlevel ' + zlevel + ' is not valid');\n      return;\n    }\n\n    if (len > 0 && zlevel > zlevelList[0]) {\n      for (i = 0; i < len - 1; i++) {\n        if (zlevelList[i] < zlevel && zlevelList[i + 1] > zlevel) {\n          break;\n        }\n      }\n\n      prevLayer = layersMap[zlevelList[i]];\n    }\n\n    zlevelList.splice(i + 1, 0, zlevel);\n    layersMap[zlevel] = layer; // Vitual layer will not directly show on the screen.\n    // (It can be a WebGL layer and assigned to a ZImage element)\n    // But it still under management of zrender.\n\n    if (!layer.virtual) {\n      if (prevLayer) {\n        var prevDom = prevLayer.dom;\n\n        if (prevDom.nextSibling) {\n          domRoot.insertBefore(layer.dom, prevDom.nextSibling);\n        } else {\n          domRoot.appendChild(layer.dom);\n        }\n      } else {\n        if (domRoot.firstChild) {\n          domRoot.insertBefore(layer.dom, domRoot.firstChild);\n        } else {\n          domRoot.appendChild(layer.dom);\n        }\n      }\n    }\n  },\n  // Iterate each layer\n  eachLayer: function (cb, context) {\n    var zlevelList = this._zlevelList;\n    var z;\n    var i;\n\n    for (i = 0; i < zlevelList.length; i++) {\n      z = zlevelList[i];\n      cb.call(context, this._layers[z], z);\n    }\n  },\n  // Iterate each buildin layer\n  eachBuiltinLayer: function (cb, context) {\n    var zlevelList = this._zlevelList;\n    var layer;\n    var z;\n    var i;\n\n    for (i = 0; i < zlevelList.length; i++) {\n      z = zlevelList[i];\n      layer = this._layers[z];\n\n      if (layer.__builtin__) {\n        cb.call(context, layer, z);\n      }\n    }\n  },\n  // Iterate each other layer except buildin layer\n  eachOtherLayer: function (cb, context) {\n    var zlevelList = this._zlevelList;\n    var layer;\n    var z;\n    var i;\n\n    for (i = 0; i < zlevelList.length; i++) {\n      z = zlevelList[i];\n      layer = this._layers[z];\n\n      if (!layer.__builtin__) {\n        cb.call(context, layer, z);\n      }\n    }\n  },\n\n  /**\n   * 获取所有已创建的层\n   * @param {Array.<module:zrender/Layer>} [prevLayer]\n   */\n  getLayers: function () {\n    return this._layers;\n  },\n  _updateLayerStatus: function (list) {\n    var layers = this._layers;\n    var progressiveLayers = this._progressiveLayers;\n    var elCountsLastFrame = {};\n    var progressiveElCountsLastFrame = {};\n    this.eachBuiltinLayer(function (layer, z) {\n      elCountsLastFrame[z] = layer.elCount;\n      layer.elCount = 0;\n      layer.__dirty = false;\n    });\n    util.each(progressiveLayers, function (layer, idx) {\n      progressiveElCountsLastFrame[idx] = layer.elCount;\n      layer.elCount = 0;\n      layer.__dirty = false;\n    });\n    var progressiveLayerCount = 0;\n    var currentProgressiveLayer;\n    var lastProgressiveKey;\n    var frameCount = 0;\n\n    for (var i = 0, l = list.length; i < l; i++) {\n      var el = list[i];\n      var zlevel = this._singleCanvas ? 0 : el.zlevel;\n      var layer = layers[zlevel];\n      var elProgress = el.progressive;\n\n      if (layer) {\n        layer.elCount++;\n        layer.__dirty = layer.__dirty || el.__dirty;\n      } /////// Update progressive\n\n\n      if (elProgress >= 0) {\n        // Fix wrong progressive sequence problem.\n        if (lastProgressiveKey !== elProgress) {\n          lastProgressiveKey = elProgress;\n          frameCount++;\n        }\n\n        var elFrame = el.__frame = frameCount - 1;\n\n        if (!currentProgressiveLayer) {\n          var idx = Math.min(progressiveLayerCount, MAX_PROGRESSIVE_LAYER_NUMBER - 1);\n          currentProgressiveLayer = progressiveLayers[idx];\n\n          if (!currentProgressiveLayer) {\n            currentProgressiveLayer = progressiveLayers[idx] = new Layer('progressive', this, this.dpr);\n            currentProgressiveLayer.initContext();\n          }\n\n          currentProgressiveLayer.__maxProgress = 0;\n        }\n\n        currentProgressiveLayer.__dirty = currentProgressiveLayer.__dirty || el.__dirty;\n        currentProgressiveLayer.elCount++;\n        currentProgressiveLayer.__maxProgress = Math.max(currentProgressiveLayer.__maxProgress, elFrame);\n\n        if (currentProgressiveLayer.__maxProgress >= currentProgressiveLayer.__progress) {\n          // Should keep rendering this  layer because progressive rendering is not finished yet\n          layer.__dirty = true;\n        }\n      } else {\n        el.__frame = -1;\n\n        if (currentProgressiveLayer) {\n          currentProgressiveLayer.__nextIdxNotProg = i;\n          progressiveLayerCount++;\n          currentProgressiveLayer = null;\n        }\n      }\n    }\n\n    if (currentProgressiveLayer) {\n      progressiveLayerCount++;\n      currentProgressiveLayer.__nextIdxNotProg = i;\n    } // 层中的元素数量有发生变化\n\n\n    this.eachBuiltinLayer(function (layer, z) {\n      if (elCountsLastFrame[z] !== layer.elCount) {\n        layer.__dirty = true;\n      }\n    });\n    progressiveLayers.length = Math.min(progressiveLayerCount, MAX_PROGRESSIVE_LAYER_NUMBER);\n    util.each(progressiveLayers, function (layer, idx) {\n      if (progressiveElCountsLastFrame[idx] !== layer.elCount) {\n        el.__dirty = true;\n      }\n\n      if (layer.__dirty) {\n        layer.__progress = 0;\n      }\n    });\n  },\n\n  /**\n   * 清除hover层外所有内容\n   */\n  clear: function () {\n    this.eachBuiltinLayer(this._clearLayer);\n    return this;\n  },\n  _clearLayer: function (layer) {\n    layer.clear();\n  },\n\n  /**\n   * 修改指定zlevel的绘制参数\n   *\n   * @param {string} zlevel\n   * @param {Object} config 配置对象\n   * @param {string} [config.clearColor=0] 每次清空画布的颜色\n   * @param {string} [config.motionBlur=false] 是否开启动态模糊\n   * @param {number} [config.lastFrameAlpha=0.7]\n   *                 在开启动态模糊的时候使用，与上一帧混合的alpha值，值越大尾迹越明显\n   */\n  configLayer: function (zlevel, config) {\n    if (config) {\n      var layerConfig = this._layerConfig;\n\n      if (!layerConfig[zlevel]) {\n        layerConfig[zlevel] = config;\n      } else {\n        util.merge(layerConfig[zlevel], config, true);\n      }\n\n      var layer = this._layers[zlevel];\n\n      if (layer) {\n        util.merge(layer, layerConfig[zlevel], true);\n      }\n    }\n  },\n\n  /**\n   * 删除指定层\n   * @param {number} zlevel 层所在的zlevel\n   */\n  delLayer: function (zlevel) {\n    var layers = this._layers;\n    var zlevelList = this._zlevelList;\n    var layer = layers[zlevel];\n\n    if (!layer) {\n      return;\n    }\n\n    layer.dom.parentNode.removeChild(layer.dom);\n    delete layers[zlevel];\n    zlevelList.splice(util.indexOf(zlevelList, zlevel), 1);\n  },\n\n  /**\n   * 区域大小变化后重绘\n   */\n  resize: function (width, height) {\n    var domRoot = this._domRoot; // FIXME Why ?\n\n    domRoot.style.display = 'none'; // Save input w/h\n\n    var opts = this._opts;\n    width != null && (opts.width = width);\n    height != null && (opts.height = height);\n    width = this._getSize(0);\n    height = this._getSize(1);\n    domRoot.style.display = ''; // 优化没有实际改变的resize\n\n    if (this._width != width || height != this._height) {\n      domRoot.style.width = width + 'px';\n      domRoot.style.height = height + 'px';\n\n      for (var id in this._layers) {\n        if (this._layers.hasOwnProperty(id)) {\n          this._layers[id].resize(width, height);\n        }\n      }\n\n      util.each(this._progressiveLayers, function (layer) {\n        layer.resize(width, height);\n      });\n      this.refresh(true);\n    }\n\n    this._width = width;\n    this._height = height;\n    return this;\n  },\n\n  /**\n   * 清除单独的一个层\n   * @param {number} zlevel\n   */\n  clearLayer: function (zlevel) {\n    var layer = this._layers[zlevel];\n\n    if (layer) {\n      layer.clear();\n    }\n  },\n\n  /**\n   * 释放\n   */\n  dispose: function () {\n    this.root.innerHTML = '';\n    this.root = this.storage = this._domRoot = this._layers = null;\n  },\n\n  /**\n   * Get canvas which has all thing rendered\n   * @param {Object} opts\n   * @param {string} [opts.backgroundColor]\n   * @param {number} [opts.pixelRatio]\n   */\n  getRenderedCanvas: function (opts) {\n    opts = opts || {};\n\n    if (this._singleCanvas) {\n      return this._layers[0].dom;\n    }\n\n    var imageLayer = new Layer('image', this, opts.pixelRatio || this.dpr);\n    imageLayer.initContext();\n    imageLayer.clearColor = opts.backgroundColor;\n    imageLayer.clear();\n    var displayList = this.storage.getDisplayList(true);\n    var scope = {};\n    var zlevel;\n    var self = this;\n\n    function findAndDrawOtherLayer(smaller, larger) {\n      var zlevelList = self._zlevelList;\n\n      if (smaller == null) {\n        smaller = -Infinity;\n      }\n\n      var intermediateLayer;\n\n      for (var i = 0; i < zlevelList.length; i++) {\n        var z = zlevelList[i];\n        var layer = self._layers[z];\n\n        if (!layer.__builtin__ && z > smaller && z < larger) {\n          intermediateLayer = layer;\n          break;\n        }\n      }\n\n      if (intermediateLayer && intermediateLayer.renderToCanvas) {\n        imageLayer.ctx.save();\n        intermediateLayer.renderToCanvas(imageLayer.ctx);\n        imageLayer.ctx.restore();\n      }\n    }\n\n    for (var i = 0; i < displayList.length; i++) {\n      var el = displayList[i];\n\n      if (el.zlevel !== zlevel) {\n        findAndDrawOtherLayer(zlevel, el.zlevel);\n        zlevel = el.zlevel;\n      }\n\n      this._doPaintEl(el, imageLayer, true, scope);\n    }\n\n    findAndDrawOtherLayer(zlevel, Infinity);\n    return imageLayer.dom;\n  },\n\n  /**\n   * 获取绘图区域宽度\n   */\n  getWidth: function () {\n    return this._width;\n  },\n\n  /**\n   * 获取绘图区域高度\n   */\n  getHeight: function () {\n    return this._height;\n  },\n  _getSize: function (whIdx) {\n    var opts = this._opts;\n    var wh = ['width', 'height'][whIdx];\n    var cwh = ['clientWidth', 'clientHeight'][whIdx];\n    var plt = ['paddingLeft', 'paddingTop'][whIdx];\n    var prb = ['paddingRight', 'paddingBottom'][whIdx];\n\n    if (opts[wh] != null && opts[wh] !== 'auto') {\n      return parseFloat(opts[wh]);\n    }\n\n    var root = this.root; // IE8 does not support getComputedStyle, but it use VML.\n\n    var stl = document.defaultView.getComputedStyle(root);\n    return (root[cwh] || parseInt10(stl[wh]) || parseInt10(root.style[wh])) - (parseInt10(stl[plt]) || 0) - (parseInt10(stl[prb]) || 0) | 0;\n  },\n  pathToImage: function (path, dpr) {\n    dpr = dpr || this.dpr;\n    var canvas = document.createElement('canvas');\n    var ctx = canvas.getContext('2d');\n    var rect = path.getBoundingRect();\n    var style = path.style;\n    var shadowBlurSize = style.shadowBlur;\n    var shadowOffsetX = style.shadowOffsetX;\n    var shadowOffsetY = style.shadowOffsetY;\n    var lineWidth = style.hasStroke() ? style.lineWidth : 0;\n    var leftMargin = Math.max(lineWidth / 2, -shadowOffsetX + shadowBlurSize);\n    var rightMargin = Math.max(lineWidth / 2, shadowOffsetX + shadowBlurSize);\n    var topMargin = Math.max(lineWidth / 2, -shadowOffsetY + shadowBlurSize);\n    var bottomMargin = Math.max(lineWidth / 2, shadowOffsetY + shadowBlurSize);\n    var width = rect.width + leftMargin + rightMargin;\n    var height = rect.height + topMargin + bottomMargin;\n    canvas.width = width * dpr;\n    canvas.height = height * dpr;\n    ctx.scale(dpr, dpr);\n    ctx.clearRect(0, 0, width, height);\n    ctx.dpr = dpr;\n    var pathTransform = {\n      position: path.position,\n      rotation: path.rotation,\n      scale: path.scale\n    };\n    path.position = [leftMargin - rect.x, topMargin - rect.y];\n    path.rotation = 0;\n    path.scale = [1, 1];\n    path.updateTransform();\n\n    if (path) {\n      path.brush(ctx);\n    }\n\n    var ImageShape = Image;\n    var imgShape = new ImageShape({\n      style: {\n        x: 0,\n        y: 0,\n        image: canvas\n      }\n    });\n\n    if (pathTransform.position != null) {\n      imgShape.position = path.position = pathTransform.position;\n    }\n\n    if (pathTransform.rotation != null) {\n      imgShape.rotation = path.rotation = pathTransform.rotation;\n    }\n\n    if (pathTransform.scale != null) {\n      imgShape.scale = path.scale = pathTransform.scale;\n    }\n\n    return imgShape;\n  }\n};\nvar _default = Painter;\nmodule.exports = _default;","map":{"version":3,"sources":["/home/martin/Escritorio/Taller de Integracion/Tarea3-TallerDeIntegracion/node_modules/react-echarts/node_modules/zrender/lib/Painter.js"],"names":["_config","require","devicePixelRatio","util","log","BoundingRect","timsort","Layer","requestAnimationFrame","Image","MAX_PROGRESSIVE_LAYER_NUMBER","parseInt10","val","parseInt","isLayerValid","layer","__builtin__","resize","refresh","preProcessLayer","__unusedCount","postProcessLayer","clear","tmpRect","viewRect","isDisplayableCulled","el","width","height","copy","getBoundingRect","transform","applyTransform","intersect","isClipPathChanged","clipPaths","prevClipPaths","length","i","doClip","ctx","clipPath","setTransform","beginPath","buildPath","shape","clip","restoreTransform","createRoot","domRoot","document","createElement","style","cssText","join","Painter","root","storage","opts","type","singleCanvas","nodeName","toUpperCase","_opts","extend","dpr","_singleCanvas","rootStyle","innerHTML","zlevelList","_zlevelList","layers","_layers","_layerConfig","_width","_getSize","_height","_domRoot","appendChild","mainLayer","initContext","push","_progressiveLayers","_hoverlayer","_hoverElements","prototype","constructor","getType","isSingleCanvas","getViewportRoot","getViewportRootOffset","viewportRoot","offsetLeft","offsetTop","paintAll","list","getDisplayList","_paintList","z","refreshHover","_startProgessive","addHover","hoverStyle","__hoverMir","elMirror","__from","setStyle","removeHover","hoverElements","idx","indexOf","splice","clearHover","from","len","hoverLayer","displayableSortFunc","getLayer","scope","save","originalEl","__zr","invisible","invTransform","__clipPaths","_doPaintEl","restore","self","_furtherProgressive","token","_progressiveToken","Date","_progress","step","_doPaintList","_clearProgressive","each","__dirty","_updateLayerStatus","eachBuiltinLayer","currentLayer","currentZLevel","progressiveLayerIdx","currentProgressiveLayer","layerProgress","frame","flushProgressiveLayer","globalAlpha","shadowBlur","drawImage","dom","l","elZLevel","zlevel","elFrame","__frame","id","Math","min","renderScope","__progress","__maxProgress","__nextIdxNotProg","forcePaint","m","opacity","culling","prevClipLayer","prevElClipPaths","prevEl","beforeBrush","brush","afterBrush","merge","insertLayer","layersMap","prevLayer","virtual","prevDom","nextSibling","insertBefore","firstChild","eachLayer","cb","context","call","eachOtherLayer","getLayers","progressiveLayers","elCountsLastFrame","progressiveElCountsLastFrame","elCount","progressiveLayerCount","lastProgressiveKey","frameCount","elProgress","progressive","max","_clearLayer","configLayer","config","layerConfig","delLayer","parentNode","removeChild","display","hasOwnProperty","clearLayer","dispose","getRenderedCanvas","imageLayer","pixelRatio","clearColor","backgroundColor","displayList","findAndDrawOtherLayer","smaller","larger","Infinity","intermediateLayer","renderToCanvas","getWidth","getHeight","whIdx","wh","cwh","plt","prb","parseFloat","stl","defaultView","getComputedStyle","pathToImage","path","canvas","getContext","rect","shadowBlurSize","shadowOffsetX","shadowOffsetY","lineWidth","hasStroke","leftMargin","rightMargin","topMargin","bottomMargin","scale","clearRect","pathTransform","position","rotation","x","y","updateTransform","ImageShape","imgShape","image","_default","module","exports"],"mappings":"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","sourcesContent":["var _config = require(\"./config\");\n\nvar devicePixelRatio = _config.devicePixelRatio;\n\nvar util = require(\"./core/util\");\n\nvar log = require(\"./core/log\");\n\nvar BoundingRect = require(\"./core/BoundingRect\");\n\nvar timsort = require(\"./core/timsort\");\n\nvar Layer = require(\"./Layer\");\n\nvar requestAnimationFrame = require(\"./animation/requestAnimationFrame\");\n\nvar Image = require(\"./graphic/Image\");\n\n/**\n * Default canvas painter\n * @module zrender/Painter\n * @author Kener (@Kener-林峰, kener.linfeng@gmail.com)\n *         errorrik (errorrik@gmail.com)\n *         pissang (https://www.github.com/pissang)\n */\n// PENDIGN\n// Layer exceeds MAX_PROGRESSIVE_LAYER_NUMBER may have some problem when flush directly second time.\n//\n// Maximum progressive layer. When exceeding this number. All elements will be drawed in the last layer.\nvar MAX_PROGRESSIVE_LAYER_NUMBER = 5;\n\nfunction parseInt10(val) {\n  return parseInt(val, 10);\n}\n\nfunction isLayerValid(layer) {\n  if (!layer) {\n    return false;\n  }\n\n  if (layer.__builtin__) {\n    return true;\n  }\n\n  if (typeof layer.resize !== 'function' || typeof layer.refresh !== 'function') {\n    return false;\n  }\n\n  return true;\n}\n\nfunction preProcessLayer(layer) {\n  layer.__unusedCount++;\n}\n\nfunction postProcessLayer(layer) {\n  if (layer.__unusedCount == 1) {\n    layer.clear();\n  }\n}\n\nvar tmpRect = new BoundingRect(0, 0, 0, 0);\nvar viewRect = new BoundingRect(0, 0, 0, 0);\n\nfunction isDisplayableCulled(el, width, height) {\n  tmpRect.copy(el.getBoundingRect());\n\n  if (el.transform) {\n    tmpRect.applyTransform(el.transform);\n  }\n\n  viewRect.width = width;\n  viewRect.height = height;\n  return !tmpRect.intersect(viewRect);\n}\n\nfunction isClipPathChanged(clipPaths, prevClipPaths) {\n  if (clipPaths == prevClipPaths) {\n    // Can both be null or undefined\n    return false;\n  }\n\n  if (!clipPaths || !prevClipPaths || clipPaths.length !== prevClipPaths.length) {\n    return true;\n  }\n\n  for (var i = 0; i < clipPaths.length; i++) {\n    if (clipPaths[i] !== prevClipPaths[i]) {\n      return true;\n    }\n  }\n}\n\nfunction doClip(clipPaths, ctx) {\n  for (var i = 0; i < clipPaths.length; i++) {\n    var clipPath = clipPaths[i];\n    clipPath.setTransform(ctx);\n    ctx.beginPath();\n    clipPath.buildPath(ctx, clipPath.shape);\n    ctx.clip(); // Transform back\n\n    clipPath.restoreTransform(ctx);\n  }\n}\n\nfunction createRoot(width, height) {\n  var domRoot = document.createElement('div'); // domRoot.onselectstart = returnFalse; // 避免页面选中的尴尬\n\n  domRoot.style.cssText = ['position:relative', 'overflow:hidden', 'width:' + width + 'px', 'height:' + height + 'px', 'padding:0', 'margin:0', 'border-width:0'].join(';') + ';';\n  return domRoot;\n}\n/**\n * @alias module:zrender/Painter\n * @constructor\n * @param {HTMLElement} root 绘图容器\n * @param {module:zrender/Storage} storage\n * @param {Object} opts\n */\n\n\nvar Painter = function (root, storage, opts) {\n  this.type = 'canvas'; // In node environment using node-canvas\n\n  var singleCanvas = !root.nodeName // In node ?\n  || root.nodeName.toUpperCase() === 'CANVAS';\n  this._opts = opts = util.extend({}, opts || {});\n  /**\n   * @type {number}\n   */\n\n  this.dpr = opts.devicePixelRatio || devicePixelRatio;\n  /**\n   * @type {boolean}\n   * @private\n   */\n\n  this._singleCanvas = singleCanvas;\n  /**\n   * 绘图容器\n   * @type {HTMLElement}\n   */\n\n  this.root = root;\n  var rootStyle = root.style;\n\n  if (rootStyle) {\n    rootStyle['-webkit-tap-highlight-color'] = 'transparent';\n    rootStyle['-webkit-user-select'] = rootStyle['user-select'] = rootStyle['-webkit-touch-callout'] = 'none';\n    root.innerHTML = '';\n  }\n  /**\n   * @type {module:zrender/Storage}\n   */\n\n\n  this.storage = storage;\n  /**\n   * @type {Array.<number>}\n   * @private\n   */\n\n  var zlevelList = this._zlevelList = [];\n  /**\n   * @type {Object.<string, module:zrender/Layer>}\n   * @private\n   */\n\n  var layers = this._layers = {};\n  /**\n   * @type {Object.<string, Object>}\n   * @type {private}\n   */\n\n  this._layerConfig = {};\n\n  if (!singleCanvas) {\n    this._width = this._getSize(0);\n    this._height = this._getSize(1);\n    var domRoot = this._domRoot = createRoot(this._width, this._height);\n    root.appendChild(domRoot);\n  } else {\n    if (opts.width != null) {\n      root.width = opts.width;\n    }\n\n    if (opts.height != null) {\n      root.height = opts.height;\n    } // Use canvas width and height directly\n\n\n    var width = root.width;\n    var height = root.height;\n    this._width = width;\n    this._height = height; // Create layer if only one given canvas\n    // Device pixel ratio is fixed to 1 because given canvas has its specified width and height\n\n    var mainLayer = new Layer(root, this, 1);\n    mainLayer.initContext(); // FIXME Use canvas width and height\n    // mainLayer.resize(width, height);\n\n    layers[0] = mainLayer;\n    zlevelList.push(0);\n    this._domRoot = root;\n  } // Layers for progressive rendering\n\n\n  this._progressiveLayers = [];\n  /**\n   * @type {module:zrender/Layer}\n   * @private\n   */\n\n  this._hoverlayer;\n  this._hoverElements = [];\n};\n\nPainter.prototype = {\n  constructor: Painter,\n  getType: function () {\n    return 'canvas';\n  },\n\n  /**\n   * If painter use a single canvas\n   * @return {boolean}\n   */\n  isSingleCanvas: function () {\n    return this._singleCanvas;\n  },\n\n  /**\n   * @return {HTMLDivElement}\n   */\n  getViewportRoot: function () {\n    return this._domRoot;\n  },\n  getViewportRootOffset: function () {\n    var viewportRoot = this.getViewportRoot();\n\n    if (viewportRoot) {\n      return {\n        offsetLeft: viewportRoot.offsetLeft || 0,\n        offsetTop: viewportRoot.offsetTop || 0\n      };\n    }\n  },\n\n  /**\n   * 刷新\n   * @param {boolean} [paintAll=false] 强制绘制所有displayable\n   */\n  refresh: function (paintAll) {\n    var list = this.storage.getDisplayList(true);\n    var zlevelList = this._zlevelList;\n\n    this._paintList(list, paintAll); // Paint custum layers\n\n\n    for (var i = 0; i < zlevelList.length; i++) {\n      var z = zlevelList[i];\n      var layer = this._layers[z];\n\n      if (!layer.__builtin__ && layer.refresh) {\n        layer.refresh();\n      }\n    }\n\n    this.refreshHover();\n\n    if (this._progressiveLayers.length) {\n      this._startProgessive();\n    }\n\n    return this;\n  },\n  addHover: function (el, hoverStyle) {\n    if (el.__hoverMir) {\n      return;\n    }\n\n    var elMirror = new el.constructor({\n      style: el.style,\n      shape: el.shape\n    });\n    elMirror.__from = el;\n    el.__hoverMir = elMirror;\n    elMirror.setStyle(hoverStyle);\n\n    this._hoverElements.push(elMirror);\n  },\n  removeHover: function (el) {\n    var elMirror = el.__hoverMir;\n    var hoverElements = this._hoverElements;\n    var idx = util.indexOf(hoverElements, elMirror);\n\n    if (idx >= 0) {\n      hoverElements.splice(idx, 1);\n    }\n\n    el.__hoverMir = null;\n  },\n  clearHover: function (el) {\n    var hoverElements = this._hoverElements;\n\n    for (var i = 0; i < hoverElements.length; i++) {\n      var from = hoverElements[i].__from;\n\n      if (from) {\n        from.__hoverMir = null;\n      }\n    }\n\n    hoverElements.length = 0;\n  },\n  refreshHover: function () {\n    var hoverElements = this._hoverElements;\n    var len = hoverElements.length;\n    var hoverLayer = this._hoverlayer;\n    hoverLayer && hoverLayer.clear();\n\n    if (!len) {\n      return;\n    }\n\n    timsort(hoverElements, this.storage.displayableSortFunc); // Use a extream large zlevel\n    // FIXME?\n\n    if (!hoverLayer) {\n      hoverLayer = this._hoverlayer = this.getLayer(1e5);\n    }\n\n    var scope = {};\n    hoverLayer.ctx.save();\n\n    for (var i = 0; i < len;) {\n      var el = hoverElements[i];\n      var originalEl = el.__from; // Original el is removed\n      // PENDING\n\n      if (!(originalEl && originalEl.__zr)) {\n        hoverElements.splice(i, 1);\n        originalEl.__hoverMir = null;\n        len--;\n        continue;\n      }\n\n      i++; // Use transform\n      // FIXME style and shape ?\n\n      if (!originalEl.invisible) {\n        el.transform = originalEl.transform;\n        el.invTransform = originalEl.invTransform;\n        el.__clipPaths = originalEl.__clipPaths; // el.\n\n        this._doPaintEl(el, hoverLayer, true, scope);\n      }\n    }\n\n    hoverLayer.ctx.restore();\n  },\n  _startProgessive: function () {\n    var self = this;\n\n    if (!self._furtherProgressive) {\n      return;\n    } // Use a token to stop progress steps triggered by\n    // previous zr.refresh calling.\n\n\n    var token = self._progressiveToken = +new Date();\n    self._progress++;\n    requestAnimationFrame(step);\n\n    function step() {\n      // In case refreshed or disposed\n      if (token === self._progressiveToken && self.storage) {\n        self._doPaintList(self.storage.getDisplayList());\n\n        if (self._furtherProgressive) {\n          self._progress++;\n          requestAnimationFrame(step);\n        } else {\n          self._progressiveToken = -1;\n        }\n      }\n    }\n  },\n  _clearProgressive: function () {\n    this._progressiveToken = -1;\n    this._progress = 0;\n    util.each(this._progressiveLayers, function (layer) {\n      layer.__dirty && layer.clear();\n    });\n  },\n  _paintList: function (list, paintAll) {\n    if (paintAll == null) {\n      paintAll = false;\n    }\n\n    this._updateLayerStatus(list);\n\n    this._clearProgressive();\n\n    this.eachBuiltinLayer(preProcessLayer);\n\n    this._doPaintList(list, paintAll);\n\n    this.eachBuiltinLayer(postProcessLayer);\n  },\n  _doPaintList: function (list, paintAll) {\n    var currentLayer;\n    var currentZLevel;\n    var ctx; // var invTransform = [];\n\n    var scope;\n    var progressiveLayerIdx = 0;\n    var currentProgressiveLayer;\n    var width = this._width;\n    var height = this._height;\n    var layerProgress;\n    var frame = this._progress;\n\n    function flushProgressiveLayer(layer) {\n      var dpr = ctx.dpr || 1;\n      ctx.save();\n      ctx.globalAlpha = 1;\n      ctx.shadowBlur = 0; // Avoid layer don't clear in next progressive frame\n\n      currentLayer.__dirty = true;\n      ctx.setTransform(1, 0, 0, 1, 0, 0);\n      ctx.drawImage(layer.dom, 0, 0, width * dpr, height * dpr);\n      ctx.restore();\n    }\n\n    for (var i = 0, l = list.length; i < l; i++) {\n      var el = list[i];\n      var elZLevel = this._singleCanvas ? 0 : el.zlevel;\n      var elFrame = el.__frame; // Flush at current context\n      // PENDING\n\n      if (elFrame < 0 && currentProgressiveLayer) {\n        flushProgressiveLayer(currentProgressiveLayer);\n        currentProgressiveLayer = null;\n      } // Change draw layer\n\n\n      if (currentZLevel !== elZLevel) {\n        if (ctx) {\n          ctx.restore();\n        } // Reset scope\n\n\n        scope = {}; // Only 0 zlevel if only has one canvas\n\n        currentZLevel = elZLevel;\n        currentLayer = this.getLayer(currentZLevel);\n\n        if (!currentLayer.__builtin__) {\n          log('ZLevel ' + currentZLevel + ' has been used by unkown layer ' + currentLayer.id);\n        }\n\n        ctx = currentLayer.ctx;\n        ctx.save(); // Reset the count\n\n        currentLayer.__unusedCount = 0;\n\n        if (currentLayer.__dirty || paintAll) {\n          currentLayer.clear();\n        }\n      }\n\n      if (!(currentLayer.__dirty || paintAll)) {\n        continue;\n      }\n\n      if (elFrame >= 0) {\n        // Progressive layer changed\n        if (!currentProgressiveLayer) {\n          currentProgressiveLayer = this._progressiveLayers[Math.min(progressiveLayerIdx++, MAX_PROGRESSIVE_LAYER_NUMBER - 1)];\n          currentProgressiveLayer.ctx.save();\n          currentProgressiveLayer.renderScope = {};\n\n          if (currentProgressiveLayer && currentProgressiveLayer.__progress > currentProgressiveLayer.__maxProgress) {\n            // flushProgressiveLayer(currentProgressiveLayer);\n            // Quick jump all progressive elements\n            // All progressive element are not dirty, jump over and flush directly\n            i = currentProgressiveLayer.__nextIdxNotProg - 1; // currentProgressiveLayer = null;\n\n            continue;\n          }\n\n          layerProgress = currentProgressiveLayer.__progress;\n\n          if (!currentProgressiveLayer.__dirty) {\n            // Keep rendering\n            frame = layerProgress;\n          }\n\n          currentProgressiveLayer.__progress = frame + 1;\n        }\n\n        if (elFrame === frame) {\n          this._doPaintEl(el, currentProgressiveLayer, true, currentProgressiveLayer.renderScope);\n        }\n      } else {\n        this._doPaintEl(el, currentLayer, paintAll, scope);\n      }\n\n      el.__dirty = false;\n    }\n\n    if (currentProgressiveLayer) {\n      flushProgressiveLayer(currentProgressiveLayer);\n    } // Restore the lastLayer ctx\n\n\n    ctx && ctx.restore(); // If still has clipping state\n    // if (scope.prevElClipPaths) {\n    //     ctx.restore();\n    // }\n\n    this._furtherProgressive = false;\n    util.each(this._progressiveLayers, function (layer) {\n      if (layer.__maxProgress >= layer.__progress) {\n        this._furtherProgressive = true;\n      }\n    }, this);\n  },\n  _doPaintEl: function (el, currentLayer, forcePaint, scope) {\n    var ctx = currentLayer.ctx;\n    var m = el.transform;\n\n    if ((currentLayer.__dirty || forcePaint) && // Ignore invisible element\n    !el.invisible // Ignore transparent element\n    && el.style.opacity !== 0 // Ignore scale 0 element, in some environment like node-canvas\n    // Draw a scale 0 element can cause all following draw wrong\n    // And setTransform with scale 0 will cause set back transform failed.\n    && !(m && !m[0] && !m[3]) // Ignore culled element\n    && !(el.culling && isDisplayableCulled(el, this._width, this._height))) {\n      var clipPaths = el.__clipPaths; // Optimize when clipping on group with several elements\n\n      if (scope.prevClipLayer !== currentLayer || isClipPathChanged(clipPaths, scope.prevElClipPaths)) {\n        // If has previous clipping state, restore from it\n        if (scope.prevElClipPaths) {\n          scope.prevClipLayer.ctx.restore();\n          scope.prevClipLayer = scope.prevElClipPaths = null; // Reset prevEl since context has been restored\n\n          scope.prevEl = null;\n        } // New clipping state\n\n\n        if (clipPaths) {\n          ctx.save();\n          doClip(clipPaths, ctx);\n          scope.prevClipLayer = currentLayer;\n          scope.prevElClipPaths = clipPaths;\n        }\n      }\n\n      el.beforeBrush && el.beforeBrush(ctx);\n      el.brush(ctx, scope.prevEl || null);\n      scope.prevEl = el;\n      el.afterBrush && el.afterBrush(ctx);\n    }\n  },\n\n  /**\n   * 获取 zlevel 所在层，如果不存在则会创建一个新的层\n   * @param {number} zlevel\n   * @return {module:zrender/Layer}\n   */\n  getLayer: function (zlevel) {\n    if (this._singleCanvas) {\n      return this._layers[0];\n    }\n\n    var layer = this._layers[zlevel];\n\n    if (!layer) {\n      // Create a new layer\n      layer = new Layer('zr_' + zlevel, this, this.dpr);\n      layer.__builtin__ = true;\n\n      if (this._layerConfig[zlevel]) {\n        util.merge(layer, this._layerConfig[zlevel], true);\n      }\n\n      this.insertLayer(zlevel, layer); // Context is created after dom inserted to document\n      // Or excanvas will get 0px clientWidth and clientHeight\n\n      layer.initContext();\n    }\n\n    return layer;\n  },\n  insertLayer: function (zlevel, layer) {\n    var layersMap = this._layers;\n    var zlevelList = this._zlevelList;\n    var len = zlevelList.length;\n    var prevLayer = null;\n    var i = -1;\n    var domRoot = this._domRoot;\n\n    if (layersMap[zlevel]) {\n      log('ZLevel ' + zlevel + ' has been used already');\n      return;\n    } // Check if is a valid layer\n\n\n    if (!isLayerValid(layer)) {\n      log('Layer of zlevel ' + zlevel + ' is not valid');\n      return;\n    }\n\n    if (len > 0 && zlevel > zlevelList[0]) {\n      for (i = 0; i < len - 1; i++) {\n        if (zlevelList[i] < zlevel && zlevelList[i + 1] > zlevel) {\n          break;\n        }\n      }\n\n      prevLayer = layersMap[zlevelList[i]];\n    }\n\n    zlevelList.splice(i + 1, 0, zlevel);\n    layersMap[zlevel] = layer; // Vitual layer will not directly show on the screen.\n    // (It can be a WebGL layer and assigned to a ZImage element)\n    // But it still under management of zrender.\n\n    if (!layer.virtual) {\n      if (prevLayer) {\n        var prevDom = prevLayer.dom;\n\n        if (prevDom.nextSibling) {\n          domRoot.insertBefore(layer.dom, prevDom.nextSibling);\n        } else {\n          domRoot.appendChild(layer.dom);\n        }\n      } else {\n        if (domRoot.firstChild) {\n          domRoot.insertBefore(layer.dom, domRoot.firstChild);\n        } else {\n          domRoot.appendChild(layer.dom);\n        }\n      }\n    }\n  },\n  // Iterate each layer\n  eachLayer: function (cb, context) {\n    var zlevelList = this._zlevelList;\n    var z;\n    var i;\n\n    for (i = 0; i < zlevelList.length; i++) {\n      z = zlevelList[i];\n      cb.call(context, this._layers[z], z);\n    }\n  },\n  // Iterate each buildin layer\n  eachBuiltinLayer: function (cb, context) {\n    var zlevelList = this._zlevelList;\n    var layer;\n    var z;\n    var i;\n\n    for (i = 0; i < zlevelList.length; i++) {\n      z = zlevelList[i];\n      layer = this._layers[z];\n\n      if (layer.__builtin__) {\n        cb.call(context, layer, z);\n      }\n    }\n  },\n  // Iterate each other layer except buildin layer\n  eachOtherLayer: function (cb, context) {\n    var zlevelList = this._zlevelList;\n    var layer;\n    var z;\n    var i;\n\n    for (i = 0; i < zlevelList.length; i++) {\n      z = zlevelList[i];\n      layer = this._layers[z];\n\n      if (!layer.__builtin__) {\n        cb.call(context, layer, z);\n      }\n    }\n  },\n\n  /**\n   * 获取所有已创建的层\n   * @param {Array.<module:zrender/Layer>} [prevLayer]\n   */\n  getLayers: function () {\n    return this._layers;\n  },\n  _updateLayerStatus: function (list) {\n    var layers = this._layers;\n    var progressiveLayers = this._progressiveLayers;\n    var elCountsLastFrame = {};\n    var progressiveElCountsLastFrame = {};\n    this.eachBuiltinLayer(function (layer, z) {\n      elCountsLastFrame[z] = layer.elCount;\n      layer.elCount = 0;\n      layer.__dirty = false;\n    });\n    util.each(progressiveLayers, function (layer, idx) {\n      progressiveElCountsLastFrame[idx] = layer.elCount;\n      layer.elCount = 0;\n      layer.__dirty = false;\n    });\n    var progressiveLayerCount = 0;\n    var currentProgressiveLayer;\n    var lastProgressiveKey;\n    var frameCount = 0;\n\n    for (var i = 0, l = list.length; i < l; i++) {\n      var el = list[i];\n      var zlevel = this._singleCanvas ? 0 : el.zlevel;\n      var layer = layers[zlevel];\n      var elProgress = el.progressive;\n\n      if (layer) {\n        layer.elCount++;\n        layer.__dirty = layer.__dirty || el.__dirty;\n      } /////// Update progressive\n\n\n      if (elProgress >= 0) {\n        // Fix wrong progressive sequence problem.\n        if (lastProgressiveKey !== elProgress) {\n          lastProgressiveKey = elProgress;\n          frameCount++;\n        }\n\n        var elFrame = el.__frame = frameCount - 1;\n\n        if (!currentProgressiveLayer) {\n          var idx = Math.min(progressiveLayerCount, MAX_PROGRESSIVE_LAYER_NUMBER - 1);\n          currentProgressiveLayer = progressiveLayers[idx];\n\n          if (!currentProgressiveLayer) {\n            currentProgressiveLayer = progressiveLayers[idx] = new Layer('progressive', this, this.dpr);\n            currentProgressiveLayer.initContext();\n          }\n\n          currentProgressiveLayer.__maxProgress = 0;\n        }\n\n        currentProgressiveLayer.__dirty = currentProgressiveLayer.__dirty || el.__dirty;\n        currentProgressiveLayer.elCount++;\n        currentProgressiveLayer.__maxProgress = Math.max(currentProgressiveLayer.__maxProgress, elFrame);\n\n        if (currentProgressiveLayer.__maxProgress >= currentProgressiveLayer.__progress) {\n          // Should keep rendering this  layer because progressive rendering is not finished yet\n          layer.__dirty = true;\n        }\n      } else {\n        el.__frame = -1;\n\n        if (currentProgressiveLayer) {\n          currentProgressiveLayer.__nextIdxNotProg = i;\n          progressiveLayerCount++;\n          currentProgressiveLayer = null;\n        }\n      }\n    }\n\n    if (currentProgressiveLayer) {\n      progressiveLayerCount++;\n      currentProgressiveLayer.__nextIdxNotProg = i;\n    } // 层中的元素数量有发生变化\n\n\n    this.eachBuiltinLayer(function (layer, z) {\n      if (elCountsLastFrame[z] !== layer.elCount) {\n        layer.__dirty = true;\n      }\n    });\n    progressiveLayers.length = Math.min(progressiveLayerCount, MAX_PROGRESSIVE_LAYER_NUMBER);\n    util.each(progressiveLayers, function (layer, idx) {\n      if (progressiveElCountsLastFrame[idx] !== layer.elCount) {\n        el.__dirty = true;\n      }\n\n      if (layer.__dirty) {\n        layer.__progress = 0;\n      }\n    });\n  },\n\n  /**\n   * 清除hover层外所有内容\n   */\n  clear: function () {\n    this.eachBuiltinLayer(this._clearLayer);\n    return this;\n  },\n  _clearLayer: function (layer) {\n    layer.clear();\n  },\n\n  /**\n   * 修改指定zlevel的绘制参数\n   *\n   * @param {string} zlevel\n   * @param {Object} config 配置对象\n   * @param {string} [config.clearColor=0] 每次清空画布的颜色\n   * @param {string} [config.motionBlur=false] 是否开启动态模糊\n   * @param {number} [config.lastFrameAlpha=0.7]\n   *                 在开启动态模糊的时候使用，与上一帧混合的alpha值，值越大尾迹越明显\n   */\n  configLayer: function (zlevel, config) {\n    if (config) {\n      var layerConfig = this._layerConfig;\n\n      if (!layerConfig[zlevel]) {\n        layerConfig[zlevel] = config;\n      } else {\n        util.merge(layerConfig[zlevel], config, true);\n      }\n\n      var layer = this._layers[zlevel];\n\n      if (layer) {\n        util.merge(layer, layerConfig[zlevel], true);\n      }\n    }\n  },\n\n  /**\n   * 删除指定层\n   * @param {number} zlevel 层所在的zlevel\n   */\n  delLayer: function (zlevel) {\n    var layers = this._layers;\n    var zlevelList = this._zlevelList;\n    var layer = layers[zlevel];\n\n    if (!layer) {\n      return;\n    }\n\n    layer.dom.parentNode.removeChild(layer.dom);\n    delete layers[zlevel];\n    zlevelList.splice(util.indexOf(zlevelList, zlevel), 1);\n  },\n\n  /**\n   * 区域大小变化后重绘\n   */\n  resize: function (width, height) {\n    var domRoot = this._domRoot; // FIXME Why ?\n\n    domRoot.style.display = 'none'; // Save input w/h\n\n    var opts = this._opts;\n    width != null && (opts.width = width);\n    height != null && (opts.height = height);\n    width = this._getSize(0);\n    height = this._getSize(1);\n    domRoot.style.display = ''; // 优化没有实际改变的resize\n\n    if (this._width != width || height != this._height) {\n      domRoot.style.width = width + 'px';\n      domRoot.style.height = height + 'px';\n\n      for (var id in this._layers) {\n        if (this._layers.hasOwnProperty(id)) {\n          this._layers[id].resize(width, height);\n        }\n      }\n\n      util.each(this._progressiveLayers, function (layer) {\n        layer.resize(width, height);\n      });\n      this.refresh(true);\n    }\n\n    this._width = width;\n    this._height = height;\n    return this;\n  },\n\n  /**\n   * 清除单独的一个层\n   * @param {number} zlevel\n   */\n  clearLayer: function (zlevel) {\n    var layer = this._layers[zlevel];\n\n    if (layer) {\n      layer.clear();\n    }\n  },\n\n  /**\n   * 释放\n   */\n  dispose: function () {\n    this.root.innerHTML = '';\n    this.root = this.storage = this._domRoot = this._layers = null;\n  },\n\n  /**\n   * Get canvas which has all thing rendered\n   * @param {Object} opts\n   * @param {string} [opts.backgroundColor]\n   * @param {number} [opts.pixelRatio]\n   */\n  getRenderedCanvas: function (opts) {\n    opts = opts || {};\n\n    if (this._singleCanvas) {\n      return this._layers[0].dom;\n    }\n\n    var imageLayer = new Layer('image', this, opts.pixelRatio || this.dpr);\n    imageLayer.initContext();\n    imageLayer.clearColor = opts.backgroundColor;\n    imageLayer.clear();\n    var displayList = this.storage.getDisplayList(true);\n    var scope = {};\n    var zlevel;\n    var self = this;\n\n    function findAndDrawOtherLayer(smaller, larger) {\n      var zlevelList = self._zlevelList;\n\n      if (smaller == null) {\n        smaller = -Infinity;\n      }\n\n      var intermediateLayer;\n\n      for (var i = 0; i < zlevelList.length; i++) {\n        var z = zlevelList[i];\n        var layer = self._layers[z];\n\n        if (!layer.__builtin__ && z > smaller && z < larger) {\n          intermediateLayer = layer;\n          break;\n        }\n      }\n\n      if (intermediateLayer && intermediateLayer.renderToCanvas) {\n        imageLayer.ctx.save();\n        intermediateLayer.renderToCanvas(imageLayer.ctx);\n        imageLayer.ctx.restore();\n      }\n    }\n\n    for (var i = 0; i < displayList.length; i++) {\n      var el = displayList[i];\n\n      if (el.zlevel !== zlevel) {\n        findAndDrawOtherLayer(zlevel, el.zlevel);\n        zlevel = el.zlevel;\n      }\n\n      this._doPaintEl(el, imageLayer, true, scope);\n    }\n\n    findAndDrawOtherLayer(zlevel, Infinity);\n    return imageLayer.dom;\n  },\n\n  /**\n   * 获取绘图区域宽度\n   */\n  getWidth: function () {\n    return this._width;\n  },\n\n  /**\n   * 获取绘图区域高度\n   */\n  getHeight: function () {\n    return this._height;\n  },\n  _getSize: function (whIdx) {\n    var opts = this._opts;\n    var wh = ['width', 'height'][whIdx];\n    var cwh = ['clientWidth', 'clientHeight'][whIdx];\n    var plt = ['paddingLeft', 'paddingTop'][whIdx];\n    var prb = ['paddingRight', 'paddingBottom'][whIdx];\n\n    if (opts[wh] != null && opts[wh] !== 'auto') {\n      return parseFloat(opts[wh]);\n    }\n\n    var root = this.root; // IE8 does not support getComputedStyle, but it use VML.\n\n    var stl = document.defaultView.getComputedStyle(root);\n    return (root[cwh] || parseInt10(stl[wh]) || parseInt10(root.style[wh])) - (parseInt10(stl[plt]) || 0) - (parseInt10(stl[prb]) || 0) | 0;\n  },\n  pathToImage: function (path, dpr) {\n    dpr = dpr || this.dpr;\n    var canvas = document.createElement('canvas');\n    var ctx = canvas.getContext('2d');\n    var rect = path.getBoundingRect();\n    var style = path.style;\n    var shadowBlurSize = style.shadowBlur;\n    var shadowOffsetX = style.shadowOffsetX;\n    var shadowOffsetY = style.shadowOffsetY;\n    var lineWidth = style.hasStroke() ? style.lineWidth : 0;\n    var leftMargin = Math.max(lineWidth / 2, -shadowOffsetX + shadowBlurSize);\n    var rightMargin = Math.max(lineWidth / 2, shadowOffsetX + shadowBlurSize);\n    var topMargin = Math.max(lineWidth / 2, -shadowOffsetY + shadowBlurSize);\n    var bottomMargin = Math.max(lineWidth / 2, shadowOffsetY + shadowBlurSize);\n    var width = rect.width + leftMargin + rightMargin;\n    var height = rect.height + topMargin + bottomMargin;\n    canvas.width = width * dpr;\n    canvas.height = height * dpr;\n    ctx.scale(dpr, dpr);\n    ctx.clearRect(0, 0, width, height);\n    ctx.dpr = dpr;\n    var pathTransform = {\n      position: path.position,\n      rotation: path.rotation,\n      scale: path.scale\n    };\n    path.position = [leftMargin - rect.x, topMargin - rect.y];\n    path.rotation = 0;\n    path.scale = [1, 1];\n    path.updateTransform();\n\n    if (path) {\n      path.brush(ctx);\n    }\n\n    var ImageShape = Image;\n    var imgShape = new ImageShape({\n      style: {\n        x: 0,\n        y: 0,\n        image: canvas\n      }\n    });\n\n    if (pathTransform.position != null) {\n      imgShape.position = path.position = pathTransform.position;\n    }\n\n    if (pathTransform.rotation != null) {\n      imgShape.rotation = path.rotation = pathTransform.rotation;\n    }\n\n    if (pathTransform.scale != null) {\n      imgShape.scale = path.scale = pathTransform.scale;\n    }\n\n    return imgShape;\n  }\n};\nvar _default = Painter;\nmodule.exports = _default;"]},"metadata":{},"sourceType":"script"}