{"ast":null,"code":"var zrUtil = require(\"zrender/lib/core/util\");\n\nvar _number = require(\"../../util/number\");\n\nvar parsePercent = _number.parsePercent;\nvar each = zrUtil.each;\n\nfunction _default(ecModel) {\n  var groupResult = groupSeriesByAxis(ecModel);\n  each(groupResult, function (groupItem) {\n    var seriesModels = groupItem.seriesModels;\n\n    if (!seriesModels.length) {\n      return;\n    }\n\n    calculateBase(groupItem);\n    each(seriesModels, function (seriesModel, idx) {\n      layoutSingleSeries(seriesModel, groupItem.boxOffsetList[idx], groupItem.boxWidthList[idx]);\n    });\n  });\n}\n/**\n * Group series by axis.\n */\n\n\nfunction groupSeriesByAxis(ecModel) {\n  var result = [];\n  var axisList = [];\n  ecModel.eachSeriesByType('boxplot', function (seriesModel) {\n    var baseAxis = seriesModel.getBaseAxis();\n    var idx = zrUtil.indexOf(axisList, baseAxis);\n\n    if (idx < 0) {\n      idx = axisList.length;\n      axisList[idx] = baseAxis;\n      result[idx] = {\n        axis: baseAxis,\n        seriesModels: []\n      };\n    }\n\n    result[idx].seriesModels.push(seriesModel);\n  });\n  return result;\n}\n/**\n * Calculate offset and box width for each series.\n */\n\n\nfunction calculateBase(groupItem) {\n  var extent;\n  var baseAxis = groupItem.axis;\n  var seriesModels = groupItem.seriesModels;\n  var seriesCount = seriesModels.length;\n  var boxWidthList = groupItem.boxWidthList = [];\n  var boxOffsetList = groupItem.boxOffsetList = [];\n  var boundList = [];\n  var bandWidth;\n\n  if (baseAxis.type === 'category') {\n    bandWidth = baseAxis.getBandWidth();\n  } else {\n    var maxDataCount = 0;\n    each(seriesModels, function (seriesModel) {\n      maxDataCount = Math.max(maxDataCount, seriesModel.getData().count());\n    });\n    extent = baseAxis.getExtent(), Math.abs(extent[1] - extent[0]) / maxDataCount;\n  }\n\n  each(seriesModels, function (seriesModel) {\n    var boxWidthBound = seriesModel.get('boxWidth');\n\n    if (!zrUtil.isArray(boxWidthBound)) {\n      boxWidthBound = [boxWidthBound, boxWidthBound];\n    }\n\n    boundList.push([parsePercent(boxWidthBound[0], bandWidth) || 0, parsePercent(boxWidthBound[1], bandWidth) || 0]);\n  });\n  var availableWidth = bandWidth * 0.8 - 2;\n  var boxGap = availableWidth / seriesCount * 0.3;\n  var boxWidth = (availableWidth - boxGap * (seriesCount - 1)) / seriesCount;\n  var base = boxWidth / 2 - availableWidth / 2;\n  each(seriesModels, function (seriesModel, idx) {\n    boxOffsetList.push(base);\n    base += boxGap + boxWidth;\n    boxWidthList.push(Math.min(Math.max(boxWidth, boundList[idx][0]), boundList[idx][1]));\n  });\n}\n/**\n * Calculate points location for each series.\n */\n\n\nfunction layoutSingleSeries(seriesModel, offset, boxWidth) {\n  var coordSys = seriesModel.coordinateSystem;\n  var data = seriesModel.getData();\n  var halfWidth = boxWidth / 2;\n  var chartLayout = seriesModel.get('layout');\n  var variableDim = chartLayout === 'horizontal' ? 0 : 1;\n  var constDim = 1 - variableDim;\n  var coordDims = ['x', 'y'];\n  var vDims = [];\n  var cDim;\n  zrUtil.each(data.dimensions, function (dimName) {\n    var dimInfo = data.getDimensionInfo(dimName);\n    var coordDim = dimInfo.coordDim;\n\n    if (coordDim === coordDims[constDim]) {\n      vDims.push(dimName);\n    } else if (coordDim === coordDims[variableDim]) {\n      cDim = dimName;\n    }\n  });\n\n  if (cDim == null || vDims.length < 5) {\n    return;\n  }\n\n  data.each([cDim].concat(vDims), function () {\n    var args = arguments;\n    var axisDimVal = args[0];\n    var idx = args[vDims.length + 1];\n    var median = getPoint(args[3]);\n    var end1 = getPoint(args[1]);\n    var end5 = getPoint(args[5]);\n    var whiskerEnds = [[end1, getPoint(args[2])], [end5, getPoint(args[4])]];\n    layEndLine(end1);\n    layEndLine(end5);\n    layEndLine(median);\n    var bodyEnds = [];\n    addBodyEnd(whiskerEnds[0][1], 0);\n    addBodyEnd(whiskerEnds[1][1], 1);\n    data.setItemLayout(idx, {\n      chartLayout: chartLayout,\n      initBaseline: median[constDim],\n      median: median,\n      bodyEnds: bodyEnds,\n      whiskerEnds: whiskerEnds\n    });\n\n    function getPoint(val) {\n      var p = [];\n      p[variableDim] = axisDimVal;\n      p[constDim] = val;\n      var point;\n\n      if (isNaN(axisDimVal) || isNaN(val)) {\n        point = [NaN, NaN];\n      } else {\n        point = coordSys.dataToPoint(p);\n        point[variableDim] += offset;\n      }\n\n      return point;\n    }\n\n    function addBodyEnd(point, start) {\n      var point1 = point.slice();\n      var point2 = point.slice();\n      point1[variableDim] += halfWidth;\n      point2[variableDim] -= halfWidth;\n      start ? bodyEnds.push(point1, point2) : bodyEnds.push(point2, point1);\n    }\n\n    function layEndLine(endCenter) {\n      var line = [endCenter.slice(), endCenter.slice()];\n      line[0][variableDim] -= halfWidth;\n      line[1][variableDim] += halfWidth;\n      whiskerEnds.push(line);\n    }\n  });\n}\n\nmodule.exports = _default;","map":{"version":3,"sources":["/home/martin/Escritorio/Taller de Integracion/Tarea3-TallerDeIntegracion/node_modules/react-echarts/node_modules/echarts/lib/chart/boxplot/boxplotLayout.js"],"names":["zrUtil","require","_number","parsePercent","each","_default","ecModel","groupResult","groupSeriesByAxis","groupItem","seriesModels","length","calculateBase","seriesModel","idx","layoutSingleSeries","boxOffsetList","boxWidthList","result","axisList","eachSeriesByType","baseAxis","getBaseAxis","indexOf","axis","push","extent","seriesCount","boundList","bandWidth","type","getBandWidth","maxDataCount","Math","max","getData","count","getExtent","abs","boxWidthBound","get","isArray","availableWidth","boxGap","boxWidth","base","min","offset","coordSys","coordinateSystem","data","halfWidth","chartLayout","variableDim","constDim","coordDims","vDims","cDim","dimensions","dimName","dimInfo","getDimensionInfo","coordDim","concat","args","arguments","axisDimVal","median","getPoint","end1","end5","whiskerEnds","layEndLine","bodyEnds","addBodyEnd","setItemLayout","initBaseline","val","p","point","isNaN","NaN","dataToPoint","start","point1","slice","point2","endCenter","line","module","exports"],"mappings":"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","sourcesContent":["var zrUtil = require(\"zrender/lib/core/util\");\n\nvar _number = require(\"../../util/number\");\n\nvar parsePercent = _number.parsePercent;\nvar each = zrUtil.each;\n\nfunction _default(ecModel) {\n  var groupResult = groupSeriesByAxis(ecModel);\n  each(groupResult, function (groupItem) {\n    var seriesModels = groupItem.seriesModels;\n\n    if (!seriesModels.length) {\n      return;\n    }\n\n    calculateBase(groupItem);\n    each(seriesModels, function (seriesModel, idx) {\n      layoutSingleSeries(seriesModel, groupItem.boxOffsetList[idx], groupItem.boxWidthList[idx]);\n    });\n  });\n}\n/**\n * Group series by axis.\n */\n\n\nfunction groupSeriesByAxis(ecModel) {\n  var result = [];\n  var axisList = [];\n  ecModel.eachSeriesByType('boxplot', function (seriesModel) {\n    var baseAxis = seriesModel.getBaseAxis();\n    var idx = zrUtil.indexOf(axisList, baseAxis);\n\n    if (idx < 0) {\n      idx = axisList.length;\n      axisList[idx] = baseAxis;\n      result[idx] = {\n        axis: baseAxis,\n        seriesModels: []\n      };\n    }\n\n    result[idx].seriesModels.push(seriesModel);\n  });\n  return result;\n}\n/**\n * Calculate offset and box width for each series.\n */\n\n\nfunction calculateBase(groupItem) {\n  var extent;\n  var baseAxis = groupItem.axis;\n  var seriesModels = groupItem.seriesModels;\n  var seriesCount = seriesModels.length;\n  var boxWidthList = groupItem.boxWidthList = [];\n  var boxOffsetList = groupItem.boxOffsetList = [];\n  var boundList = [];\n  var bandWidth;\n\n  if (baseAxis.type === 'category') {\n    bandWidth = baseAxis.getBandWidth();\n  } else {\n    var maxDataCount = 0;\n    each(seriesModels, function (seriesModel) {\n      maxDataCount = Math.max(maxDataCount, seriesModel.getData().count());\n    });\n    extent = baseAxis.getExtent(), Math.abs(extent[1] - extent[0]) / maxDataCount;\n  }\n\n  each(seriesModels, function (seriesModel) {\n    var boxWidthBound = seriesModel.get('boxWidth');\n\n    if (!zrUtil.isArray(boxWidthBound)) {\n      boxWidthBound = [boxWidthBound, boxWidthBound];\n    }\n\n    boundList.push([parsePercent(boxWidthBound[0], bandWidth) || 0, parsePercent(boxWidthBound[1], bandWidth) || 0]);\n  });\n  var availableWidth = bandWidth * 0.8 - 2;\n  var boxGap = availableWidth / seriesCount * 0.3;\n  var boxWidth = (availableWidth - boxGap * (seriesCount - 1)) / seriesCount;\n  var base = boxWidth / 2 - availableWidth / 2;\n  each(seriesModels, function (seriesModel, idx) {\n    boxOffsetList.push(base);\n    base += boxGap + boxWidth;\n    boxWidthList.push(Math.min(Math.max(boxWidth, boundList[idx][0]), boundList[idx][1]));\n  });\n}\n/**\n * Calculate points location for each series.\n */\n\n\nfunction layoutSingleSeries(seriesModel, offset, boxWidth) {\n  var coordSys = seriesModel.coordinateSystem;\n  var data = seriesModel.getData();\n  var halfWidth = boxWidth / 2;\n  var chartLayout = seriesModel.get('layout');\n  var variableDim = chartLayout === 'horizontal' ? 0 : 1;\n  var constDim = 1 - variableDim;\n  var coordDims = ['x', 'y'];\n  var vDims = [];\n  var cDim;\n  zrUtil.each(data.dimensions, function (dimName) {\n    var dimInfo = data.getDimensionInfo(dimName);\n    var coordDim = dimInfo.coordDim;\n\n    if (coordDim === coordDims[constDim]) {\n      vDims.push(dimName);\n    } else if (coordDim === coordDims[variableDim]) {\n      cDim = dimName;\n    }\n  });\n\n  if (cDim == null || vDims.length < 5) {\n    return;\n  }\n\n  data.each([cDim].concat(vDims), function () {\n    var args = arguments;\n    var axisDimVal = args[0];\n    var idx = args[vDims.length + 1];\n    var median = getPoint(args[3]);\n    var end1 = getPoint(args[1]);\n    var end5 = getPoint(args[5]);\n    var whiskerEnds = [[end1, getPoint(args[2])], [end5, getPoint(args[4])]];\n    layEndLine(end1);\n    layEndLine(end5);\n    layEndLine(median);\n    var bodyEnds = [];\n    addBodyEnd(whiskerEnds[0][1], 0);\n    addBodyEnd(whiskerEnds[1][1], 1);\n    data.setItemLayout(idx, {\n      chartLayout: chartLayout,\n      initBaseline: median[constDim],\n      median: median,\n      bodyEnds: bodyEnds,\n      whiskerEnds: whiskerEnds\n    });\n\n    function getPoint(val) {\n      var p = [];\n      p[variableDim] = axisDimVal;\n      p[constDim] = val;\n      var point;\n\n      if (isNaN(axisDimVal) || isNaN(val)) {\n        point = [NaN, NaN];\n      } else {\n        point = coordSys.dataToPoint(p);\n        point[variableDim] += offset;\n      }\n\n      return point;\n    }\n\n    function addBodyEnd(point, start) {\n      var point1 = point.slice();\n      var point2 = point.slice();\n      point1[variableDim] += halfWidth;\n      point2[variableDim] -= halfWidth;\n      start ? bodyEnds.push(point1, point2) : bodyEnds.push(point2, point1);\n    }\n\n    function layEndLine(endCenter) {\n      var line = [endCenter.slice(), endCenter.slice()];\n      line[0][variableDim] -= halfWidth;\n      line[1][variableDim] += halfWidth;\n      whiskerEnds.push(line);\n    }\n  });\n}\n\nmodule.exports = _default;"]},"metadata":{},"sourceType":"script"}