{"ast":null,"code":"var _config = require(\"../config\");\n\nvar __DEV__ = _config.__DEV__;\n\nvar zrUtil = require(\"zrender/lib/core/util\");\n\nvar Model = require(\"../model/Model\");\n\nvar DataDiffer = require(\"./DataDiffer\");\n\nvar modelUtil = require(\"../util/model\");\n/**\n * List for data storage\n * @module echarts/data/List\n */\n\n\nvar isObject = zrUtil.isObject;\nvar UNDEFINED = 'undefined';\nvar globalObj = typeof window === UNDEFINED ? global : window;\nvar dataCtors = {\n  'float': typeof globalObj.Float64Array === UNDEFINED ? Array : globalObj.Float64Array,\n  'int': typeof globalObj.Int32Array === UNDEFINED ? Array : globalObj.Int32Array,\n  // Ordinal data type can be string or int\n  'ordinal': Array,\n  'number': Array,\n  'time': Array\n};\nvar TRANSFERABLE_PROPERTIES = ['stackedOn', 'hasItemOption', '_nameList', '_idList', '_rawData'];\n\nfunction transferProperties(a, b) {\n  zrUtil.each(TRANSFERABLE_PROPERTIES.concat(b.__wrappedMethods || []), function (propName) {\n    if (b.hasOwnProperty(propName)) {\n      a[propName] = b[propName];\n    }\n  });\n  a.__wrappedMethods = b.__wrappedMethods;\n}\n\nfunction DefaultDataProvider(dataArray) {\n  this._array = dataArray || [];\n}\n\nDefaultDataProvider.prototype.pure = false;\n\nDefaultDataProvider.prototype.count = function () {\n  return this._array.length;\n};\n\nDefaultDataProvider.prototype.getItem = function (idx) {\n  return this._array[idx];\n};\n/**\n * @constructor\n * @alias module:echarts/data/List\n *\n * @param {Array.<string|Object>} dimensions\n *      For example, ['someDimName', {name: 'someDimName', type: 'someDimType'}, ...].\n *      Dimensions should be concrete names like x, y, z, lng, lat, angle, radius\n * @param {module:echarts/model/Model} hostModel\n */\n\n\nvar List = function (dimensions, hostModel) {\n  dimensions = dimensions || ['x', 'y'];\n  var dimensionInfos = {};\n  var dimensionNames = [];\n\n  for (var i = 0; i < dimensions.length; i++) {\n    var dimensionName;\n    var dimensionInfo = {};\n\n    if (typeof dimensions[i] === 'string') {\n      dimensionName = dimensions[i];\n      dimensionInfo = {\n        name: dimensionName,\n        coordDim: dimensionName,\n        coordDimIndex: 0,\n        stackable: false,\n        // Type can be 'float', 'int', 'number'\n        // Default is number, Precision of float may not enough\n        type: 'number'\n      };\n    } else {\n      dimensionInfo = dimensions[i];\n      dimensionName = dimensionInfo.name;\n      dimensionInfo.type = dimensionInfo.type || 'number';\n\n      if (!dimensionInfo.coordDim) {\n        dimensionInfo.coordDim = dimensionName;\n        dimensionInfo.coordDimIndex = 0;\n      }\n    }\n\n    dimensionInfo.otherDims = dimensionInfo.otherDims || {};\n    dimensionNames.push(dimensionName);\n    dimensionInfos[dimensionName] = dimensionInfo;\n  }\n  /**\n   * @readOnly\n   * @type {Array.<string>}\n   */\n\n\n  this.dimensions = dimensionNames;\n  /**\n   * Infomation of each data dimension, like data type.\n   * @type {Object}\n   */\n\n  this._dimensionInfos = dimensionInfos;\n  /**\n   * @type {module:echarts/model/Model}\n   */\n\n  this.hostModel = hostModel;\n  /**\n   * @type {module:echarts/model/Model}\n   */\n\n  this.dataType;\n  /**\n   * Indices stores the indices of data subset after filtered.\n   * This data subset will be used in chart.\n   * @type {Array.<number>}\n   * @readOnly\n   */\n\n  this.indices = [];\n  /**\n   * Data storage\n   * @type {Object.<key, TypedArray|Array>}\n   * @private\n   */\n\n  this._storage = {};\n  /**\n   * @type {Array.<string>}\n   */\n\n  this._nameList = [];\n  /**\n   * @type {Array.<string>}\n   */\n\n  this._idList = [];\n  /**\n   * Models of data option is stored sparse for optimizing memory cost\n   * @type {Array.<module:echarts/model/Model>}\n   * @private\n   */\n\n  this._optionModels = [];\n  /**\n   * @param {module:echarts/data/List}\n   */\n\n  this.stackedOn = null;\n  /**\n   * Global visual properties after visual coding\n   * @type {Object}\n   * @private\n   */\n\n  this._visual = {};\n  /**\n   * Globel layout properties.\n   * @type {Object}\n   * @private\n   */\n\n  this._layout = {};\n  /**\n   * Item visual properties after visual coding\n   * @type {Array.<Object>}\n   * @private\n   */\n\n  this._itemVisuals = [];\n  /**\n   * Item layout properties after layout\n   * @type {Array.<Object>}\n   * @private\n   */\n\n  this._itemLayouts = [];\n  /**\n   * Graphic elemnents\n   * @type {Array.<module:zrender/Element>}\n   * @private\n   */\n\n  this._graphicEls = [];\n  /**\n   * @type {Array.<Array|Object>}\n   * @private\n   */\n\n  this._rawData;\n  /**\n   * @type {Object}\n   * @private\n   */\n\n  this._extent;\n};\n\nvar listProto = List.prototype;\nlistProto.type = 'list';\n/**\n * If each data item has it's own option\n * @type {boolean}\n */\n\nlistProto.hasItemOption = true;\n/**\n * Get dimension name\n * @param {string|number} dim\n *        Dimension can be concrete names like x, y, z, lng, lat, angle, radius\n *        Or a ordinal number. For example getDimensionInfo(0) will return 'x' or 'lng' or 'radius'\n * @return {string} Concrete dim name.\n */\n\nlistProto.getDimension = function (dim) {\n  if (!isNaN(dim)) {\n    dim = this.dimensions[dim] || dim;\n  }\n\n  return dim;\n};\n/**\n * Get type and stackable info of particular dimension\n * @param {string|number} dim\n *        Dimension can be concrete names like x, y, z, lng, lat, angle, radius\n *        Or a ordinal number. For example getDimensionInfo(0) will return 'x' or 'lng' or 'radius'\n */\n\n\nlistProto.getDimensionInfo = function (dim) {\n  return zrUtil.clone(this._dimensionInfos[this.getDimension(dim)]);\n};\n/**\n * Initialize from data\n * @param {Array.<Object|number|Array>} data\n * @param {Array.<string>} [nameList]\n * @param {Function} [dimValueGetter] (dataItem, dimName, dataIndex, dimIndex) => number\n */\n\n\nlistProto.initData = function (data, nameList, dimValueGetter) {\n  data = data || [];\n  var isDataArray = zrUtil.isArray(data);\n\n  if (isDataArray) {\n    data = new DefaultDataProvider(data);\n  }\n\n  this._rawData = data; // Clear\n\n  var storage = this._storage = {};\n  var indices = this.indices = [];\n  var dimensions = this.dimensions;\n  var dimensionInfoMap = this._dimensionInfos;\n  var size = data.count();\n  var idList = [];\n  var nameRepeatCount = {};\n  var nameDimIdx;\n  nameList = nameList || []; // Init storage\n\n  for (var i = 0; i < dimensions.length; i++) {\n    var dimInfo = dimensionInfoMap[dimensions[i]];\n    dimInfo.otherDims.itemName === 0 && (nameDimIdx = i);\n    var DataCtor = dataCtors[dimInfo.type];\n    storage[dimensions[i]] = new DataCtor(size);\n  }\n\n  var self = this;\n\n  if (!dimValueGetter) {\n    self.hasItemOption = false;\n  } // Default dim value getter\n\n\n  dimValueGetter = dimValueGetter || function (dataItem, dimName, dataIndex, dimIndex) {\n    var value = modelUtil.getDataItemValue(dataItem); // If any dataItem is like { value: 10 }\n\n    if (modelUtil.isDataItemOption(dataItem)) {\n      self.hasItemOption = true;\n    }\n\n    return modelUtil.converDataValue(value instanceof Array ? value[dimIndex] // If value is a single number or something else not array.\n    : value, dimensionInfoMap[dimName]);\n  };\n\n  for (var i = 0; i < size; i++) {\n    // NOTICE: Try not to write things into dataItem\n    var dataItem = data.getItem(i); // Each data item is value\n    // [1, 2]\n    // 2\n    // Bar chart, line chart which uses category axis\n    // only gives the 'y' value. 'x' value is the indices of cateogry\n    // Use a tempValue to normalize the value to be a (x, y) value\n    // Store the data by dimensions\n\n    for (var k = 0; k < dimensions.length; k++) {\n      var dim = dimensions[k];\n      var dimStorage = storage[dim]; // PENDING NULL is empty or zero\n\n      dimStorage[i] = dimValueGetter(dataItem, dim, i, k);\n    }\n\n    indices.push(i);\n  } // Use the name in option and create id\n\n\n  for (var i = 0; i < size; i++) {\n    var dataItem = data.getItem(i);\n\n    if (!nameList[i] && dataItem) {\n      if (dataItem.name != null) {\n        nameList[i] = dataItem.name;\n      } else if (nameDimIdx != null) {\n        nameList[i] = storage[dimensions[nameDimIdx]][i];\n      }\n    }\n\n    var name = nameList[i] || ''; // Try using the id in option\n\n    var id = dataItem && dataItem.id;\n\n    if (!id && name) {\n      // Use name as id and add counter to avoid same name\n      nameRepeatCount[name] = nameRepeatCount[name] || 0;\n      id = name;\n\n      if (nameRepeatCount[name] > 0) {\n        id += '__ec__' + nameRepeatCount[name];\n      }\n\n      nameRepeatCount[name]++;\n    }\n\n    id && (idList[i] = id);\n  }\n\n  this._nameList = nameList;\n  this._idList = idList;\n};\n/**\n * @return {number}\n */\n\n\nlistProto.count = function () {\n  return this.indices.length;\n};\n/**\n * Get value. Return NaN if idx is out of range.\n * @param {string} dim Dim must be concrete name.\n * @param {number} idx\n * @param {boolean} stack\n * @return {number}\n */\n\n\nlistProto.get = function (dim, idx, stack) {\n  var storage = this._storage;\n  var dataIndex = this.indices[idx]; // If value not exists\n\n  if (dataIndex == null || !storage[dim]) {\n    return NaN;\n  }\n\n  var value = storage[dim][dataIndex]; // FIXME ordinal data type is not stackable\n\n  if (stack) {\n    var dimensionInfo = this._dimensionInfos[dim];\n\n    if (dimensionInfo && dimensionInfo.stackable) {\n      var stackedOn = this.stackedOn;\n\n      while (stackedOn) {\n        // Get no stacked data of stacked on\n        var stackedValue = stackedOn.get(dim, idx); // Considering positive stack, negative stack and empty data\n\n        if (value >= 0 && stackedValue > 0 || // Positive stack\n        value <= 0 && stackedValue < 0 // Negative stack\n        ) {\n            value += stackedValue;\n          }\n\n        stackedOn = stackedOn.stackedOn;\n      }\n    }\n  }\n\n  return value;\n};\n/**\n * Get value for multi dimensions.\n * @param {Array.<string>} [dimensions] If ignored, using all dimensions.\n * @param {number} idx\n * @param {boolean} stack\n * @return {number}\n */\n\n\nlistProto.getValues = function (dimensions, idx, stack) {\n  var values = [];\n\n  if (!zrUtil.isArray(dimensions)) {\n    stack = idx;\n    idx = dimensions;\n    dimensions = this.dimensions;\n  }\n\n  for (var i = 0, len = dimensions.length; i < len; i++) {\n    values.push(this.get(dimensions[i], idx, stack));\n  }\n\n  return values;\n};\n/**\n * If value is NaN. Inlcuding '-'\n * @param {string} dim\n * @param {number} idx\n * @return {number}\n */\n\n\nlistProto.hasValue = function (idx) {\n  var dimensions = this.dimensions;\n  var dimensionInfos = this._dimensionInfos;\n\n  for (var i = 0, len = dimensions.length; i < len; i++) {\n    if ( // Ordinal type can be string or number\n    dimensionInfos[dimensions[i]].type !== 'ordinal' && isNaN(this.get(dimensions[i], idx))) {\n      return false;\n    }\n  }\n\n  return true;\n};\n/**\n * Get extent of data in one dimension\n * @param {string} dim\n * @param {boolean} stack\n * @param {Function} filter\n */\n\n\nlistProto.getDataExtent = function (dim, stack, filter) {\n  dim = this.getDimension(dim);\n  var dimData = this._storage[dim];\n  var dimInfo = this.getDimensionInfo(dim);\n  stack = dimInfo && dimInfo.stackable && stack;\n  var dimExtent = (this._extent || (this._extent = {}))[dim + !!stack];\n  var value;\n\n  if (dimExtent) {\n    return dimExtent;\n  } // var dimInfo = this._dimensionInfos[dim];\n\n\n  if (dimData) {\n    var min = Infinity;\n    var max = -Infinity; // var isOrdinal = dimInfo.type === 'ordinal';\n\n    for (var i = 0, len = this.count(); i < len; i++) {\n      value = this.get(dim, i, stack); // FIXME\n      // if (isOrdinal && typeof value === 'string') {\n      //     value = zrUtil.indexOf(dimData, value);\n      // }\n\n      if (!filter || filter(value, dim, i)) {\n        value < min && (min = value);\n        value > max && (max = value);\n      }\n    }\n\n    return this._extent[dim + !!stack] = [min, max];\n  } else {\n    return [Infinity, -Infinity];\n  }\n};\n/**\n * Get sum of data in one dimension\n * @param {string} dim\n * @param {boolean} stack\n */\n\n\nlistProto.getSum = function (dim, stack) {\n  var dimData = this._storage[dim];\n  var sum = 0;\n\n  if (dimData) {\n    for (var i = 0, len = this.count(); i < len; i++) {\n      var value = this.get(dim, i, stack);\n\n      if (!isNaN(value)) {\n        sum += value;\n      }\n    }\n  }\n\n  return sum;\n};\n/**\n * Retreive the index with given value\n * @param {number} idx\n * @param {number} value\n * @return {number}\n */\n// FIXME Precision of float value\n\n\nlistProto.indexOf = function (dim, value) {\n  var storage = this._storage;\n  var dimData = storage[dim];\n  var indices = this.indices;\n\n  if (dimData) {\n    for (var i = 0, len = indices.length; i < len; i++) {\n      var rawIndex = indices[i];\n\n      if (dimData[rawIndex] === value) {\n        return i;\n      }\n    }\n  }\n\n  return -1;\n};\n/**\n * Retreive the index with given name\n * @param {number} idx\n * @param {number} name\n * @return {number}\n */\n\n\nlistProto.indexOfName = function (name) {\n  var indices = this.indices;\n  var nameList = this._nameList;\n\n  for (var i = 0, len = indices.length; i < len; i++) {\n    var rawIndex = indices[i];\n\n    if (nameList[rawIndex] === name) {\n      return i;\n    }\n  }\n\n  return -1;\n};\n/**\n * Retreive the index with given raw data index\n * @param {number} idx\n * @param {number} name\n * @return {number}\n */\n\n\nlistProto.indexOfRawIndex = function (rawIndex) {\n  // Indices are ascending\n  var indices = this.indices; // If rawIndex === dataIndex\n\n  var rawDataIndex = indices[rawIndex];\n\n  if (rawDataIndex != null && rawDataIndex === rawIndex) {\n    return rawIndex;\n  }\n\n  var left = 0;\n  var right = indices.length - 1;\n\n  while (left <= right) {\n    var mid = (left + right) / 2 | 0;\n\n    if (indices[mid] < rawIndex) {\n      left = mid + 1;\n    } else if (indices[mid] > rawIndex) {\n      right = mid - 1;\n    } else {\n      return mid;\n    }\n  }\n\n  return -1;\n};\n/**\n * Retreive the index of nearest value\n * @param {string} dim\n * @param {number} value\n * @param {boolean} stack If given value is after stacked\n * @param {number} [maxDistance=Infinity]\n * @return {Array.<number>} Considere multiple points has the same value.\n */\n\n\nlistProto.indicesOfNearest = function (dim, value, stack, maxDistance) {\n  var storage = this._storage;\n  var dimData = storage[dim];\n  var nearestIndices = [];\n\n  if (!dimData) {\n    return nearestIndices;\n  }\n\n  if (maxDistance == null) {\n    maxDistance = Infinity;\n  }\n\n  var minDist = Number.MAX_VALUE;\n  var minDiff = -1;\n\n  for (var i = 0, len = this.count(); i < len; i++) {\n    var diff = value - this.get(dim, i, stack);\n    var dist = Math.abs(diff);\n\n    if (diff <= maxDistance && dist <= minDist) {\n      // For the case of two data are same on xAxis, which has sequence data.\n      // Show the nearest index\n      // https://github.com/ecomfe/echarts/issues/2869\n      if (dist < minDist || diff >= 0 && minDiff < 0) {\n        minDist = dist;\n        minDiff = diff;\n        nearestIndices.length = 0;\n      }\n\n      nearestIndices.push(i);\n    }\n  }\n\n  return nearestIndices;\n};\n/**\n * Get raw data index\n * @param {number} idx\n * @return {number}\n */\n\n\nlistProto.getRawIndex = function (idx) {\n  var rawIdx = this.indices[idx];\n  return rawIdx == null ? -1 : rawIdx;\n};\n/**\n * Get raw data item\n * @param {number} idx\n * @return {number}\n */\n\n\nlistProto.getRawDataItem = function (idx) {\n  return this._rawData.getItem(this.getRawIndex(idx));\n};\n/**\n * @param {number} idx\n * @param {boolean} [notDefaultIdx=false]\n * @return {string}\n */\n\n\nlistProto.getName = function (idx) {\n  return this._nameList[this.indices[idx]] || '';\n};\n/**\n * @param {number} idx\n * @param {boolean} [notDefaultIdx=false]\n * @return {string}\n */\n\n\nlistProto.getId = function (idx) {\n  return this._idList[this.indices[idx]] || this.getRawIndex(idx) + '';\n};\n\nfunction normalizeDimensions(dimensions) {\n  if (!zrUtil.isArray(dimensions)) {\n    dimensions = [dimensions];\n  }\n\n  return dimensions;\n}\n/**\n * Data iteration\n * @param {string|Array.<string>}\n * @param {Function} cb\n * @param {boolean} [stack=false]\n * @param {*} [context=this]\n *\n * @example\n *  list.each('x', function (x, idx) {});\n *  list.each(['x', 'y'], function (x, y, idx) {});\n *  list.each(function (idx) {})\n */\n\n\nlistProto.each = function (dims, cb, stack, context) {\n  if (typeof dims === 'function') {\n    context = stack;\n    stack = cb;\n    cb = dims;\n    dims = [];\n  }\n\n  dims = zrUtil.map(normalizeDimensions(dims), this.getDimension, this);\n  var value = [];\n  var dimSize = dims.length;\n  var indices = this.indices;\n  context = context || this;\n\n  for (var i = 0; i < indices.length; i++) {\n    // Simple optimization\n    switch (dimSize) {\n      case 0:\n        cb.call(context, i);\n        break;\n\n      case 1:\n        cb.call(context, this.get(dims[0], i, stack), i);\n        break;\n\n      case 2:\n        cb.call(context, this.get(dims[0], i, stack), this.get(dims[1], i, stack), i);\n        break;\n\n      default:\n        for (var k = 0; k < dimSize; k++) {\n          value[k] = this.get(dims[k], i, stack);\n        } // Index\n\n\n        value[k] = i;\n        cb.apply(context, value);\n    }\n  }\n};\n/**\n * Data filter\n * @param {string|Array.<string>}\n * @param {Function} cb\n * @param {boolean} [stack=false]\n * @param {*} [context=this]\n */\n\n\nlistProto.filterSelf = function (dimensions, cb, stack, context) {\n  if (typeof dimensions === 'function') {\n    context = stack;\n    stack = cb;\n    cb = dimensions;\n    dimensions = [];\n  }\n\n  dimensions = zrUtil.map(normalizeDimensions(dimensions), this.getDimension, this);\n  var newIndices = [];\n  var value = [];\n  var dimSize = dimensions.length;\n  var indices = this.indices;\n  context = context || this;\n\n  for (var i = 0; i < indices.length; i++) {\n    var keep; // Simple optimization\n\n    if (!dimSize) {\n      keep = cb.call(context, i);\n    } else if (dimSize === 1) {\n      keep = cb.call(context, this.get(dimensions[0], i, stack), i);\n    } else {\n      for (var k = 0; k < dimSize; k++) {\n        value[k] = this.get(dimensions[k], i, stack);\n      }\n\n      value[k] = i;\n      keep = cb.apply(context, value);\n    }\n\n    if (keep) {\n      newIndices.push(indices[i]);\n    }\n  }\n\n  this.indices = newIndices; // Reset data extent\n\n  this._extent = {};\n  return this;\n};\n/**\n * Data mapping to a plain array\n * @param {string|Array.<string>} [dimensions]\n * @param {Function} cb\n * @param {boolean} [stack=false]\n * @param {*} [context=this]\n * @return {Array}\n */\n\n\nlistProto.mapArray = function (dimensions, cb, stack, context) {\n  if (typeof dimensions === 'function') {\n    context = stack;\n    stack = cb;\n    cb = dimensions;\n    dimensions = [];\n  }\n\n  var result = [];\n  this.each(dimensions, function () {\n    result.push(cb && cb.apply(this, arguments));\n  }, stack, context);\n  return result;\n};\n\nfunction cloneListForMapAndSample(original, excludeDimensions) {\n  var allDimensions = original.dimensions;\n  var list = new List(zrUtil.map(allDimensions, original.getDimensionInfo, original), original.hostModel); // FIXME If needs stackedOn, value may already been stacked\n\n  transferProperties(list, original);\n  var storage = list._storage = {};\n  var originalStorage = original._storage; // Init storage\n\n  for (var i = 0; i < allDimensions.length; i++) {\n    var dim = allDimensions[i];\n    var dimStore = originalStorage[dim];\n\n    if (zrUtil.indexOf(excludeDimensions, dim) >= 0) {\n      storage[dim] = new dimStore.constructor(originalStorage[dim].length);\n    } else {\n      // Direct reference for other dimensions\n      storage[dim] = originalStorage[dim];\n    }\n  }\n\n  return list;\n}\n/**\n * Data mapping to a new List with given dimensions\n * @param {string|Array.<string>} dimensions\n * @param {Function} cb\n * @param {boolean} [stack=false]\n * @param {*} [context=this]\n * @return {Array}\n */\n\n\nlistProto.map = function (dimensions, cb, stack, context) {\n  dimensions = zrUtil.map(normalizeDimensions(dimensions), this.getDimension, this);\n  var list = cloneListForMapAndSample(this, dimensions); // Following properties are all immutable.\n  // So we can reference to the same value\n\n  var indices = list.indices = this.indices;\n  var storage = list._storage;\n  var tmpRetValue = [];\n  this.each(dimensions, function () {\n    var idx = arguments[arguments.length - 1];\n    var retValue = cb && cb.apply(this, arguments);\n\n    if (retValue != null) {\n      // a number\n      if (typeof retValue === 'number') {\n        tmpRetValue[0] = retValue;\n        retValue = tmpRetValue;\n      }\n\n      for (var i = 0; i < retValue.length; i++) {\n        var dim = dimensions[i];\n        var dimStore = storage[dim];\n        var rawIdx = indices[idx];\n\n        if (dimStore) {\n          dimStore[rawIdx] = retValue[i];\n        }\n      }\n    }\n  }, stack, context);\n  return list;\n};\n/**\n * Large data down sampling on given dimension\n * @param {string} dimension\n * @param {number} rate\n * @param {Function} sampleValue\n * @param {Function} sampleIndex Sample index for name and id\n */\n\n\nlistProto.downSample = function (dimension, rate, sampleValue, sampleIndex) {\n  var list = cloneListForMapAndSample(this, [dimension]);\n  var storage = this._storage;\n  var targetStorage = list._storage;\n  var originalIndices = this.indices;\n  var indices = list.indices = [];\n  var frameValues = [];\n  var frameIndices = [];\n  var frameSize = Math.floor(1 / rate);\n  var dimStore = targetStorage[dimension];\n  var len = this.count(); // Copy data from original data\n\n  for (var i = 0; i < storage[dimension].length; i++) {\n    targetStorage[dimension][i] = storage[dimension][i];\n  }\n\n  for (var i = 0; i < len; i += frameSize) {\n    // Last frame\n    if (frameSize > len - i) {\n      frameSize = len - i;\n      frameValues.length = frameSize;\n    }\n\n    for (var k = 0; k < frameSize; k++) {\n      var idx = originalIndices[i + k];\n      frameValues[k] = dimStore[idx];\n      frameIndices[k] = idx;\n    }\n\n    var value = sampleValue(frameValues);\n    var idx = frameIndices[sampleIndex(frameValues, value) || 0]; // Only write value on the filtered data\n\n    dimStore[idx] = value;\n    indices.push(idx);\n  }\n\n  return list;\n};\n/**\n * Get model of one data item.\n *\n * @param {number} idx\n */\n// FIXME Model proxy ?\n\n\nlistProto.getItemModel = function (idx) {\n  var hostModel = this.hostModel;\n  idx = this.indices[idx];\n  return new Model(this._rawData.getItem(idx), hostModel, hostModel && hostModel.ecModel);\n};\n/**\n * Create a data differ\n * @param {module:echarts/data/List} otherList\n * @return {module:echarts/data/DataDiffer}\n */\n\n\nlistProto.diff = function (otherList) {\n  var idList = this._idList;\n  var otherIdList = otherList && otherList._idList;\n  var val; // Use prefix to avoid index to be the same as otherIdList[idx],\n  // which will cause weird udpate animation.\n\n  var prefix = 'e\\0\\0';\n  return new DataDiffer(otherList ? otherList.indices : [], this.indices, function (idx) {\n    return (val = otherIdList[idx]) != null ? val : prefix + idx;\n  }, function (idx) {\n    return (val = idList[idx]) != null ? val : prefix + idx;\n  });\n};\n/**\n * Get visual property.\n * @param {string} key\n */\n\n\nlistProto.getVisual = function (key) {\n  var visual = this._visual;\n  return visual && visual[key];\n};\n/**\n * Set visual property\n * @param {string|Object} key\n * @param {*} [value]\n *\n * @example\n *  setVisual('color', color);\n *  setVisual({\n *      'color': color\n *  });\n */\n\n\nlistProto.setVisual = function (key, val) {\n  if (isObject(key)) {\n    for (var name in key) {\n      if (key.hasOwnProperty(name)) {\n        this.setVisual(name, key[name]);\n      }\n    }\n\n    return;\n  }\n\n  this._visual = this._visual || {};\n  this._visual[key] = val;\n};\n/**\n * Set layout property.\n * @param {string|Object} key\n * @param {*} [val]\n */\n\n\nlistProto.setLayout = function (key, val) {\n  if (isObject(key)) {\n    for (var name in key) {\n      if (key.hasOwnProperty(name)) {\n        this.setLayout(name, key[name]);\n      }\n    }\n\n    return;\n  }\n\n  this._layout[key] = val;\n};\n/**\n * Get layout property.\n * @param  {string} key.\n * @return {*}\n */\n\n\nlistProto.getLayout = function (key) {\n  return this._layout[key];\n};\n/**\n * Get layout of single data item\n * @param {number} idx\n */\n\n\nlistProto.getItemLayout = function (idx) {\n  return this._itemLayouts[idx];\n};\n/**\n * Set layout of single data item\n * @param {number} idx\n * @param {Object} layout\n * @param {boolean=} [merge=false]\n */\n\n\nlistProto.setItemLayout = function (idx, layout, merge) {\n  this._itemLayouts[idx] = merge ? zrUtil.extend(this._itemLayouts[idx] || {}, layout) : layout;\n};\n/**\n * Clear all layout of single data item\n */\n\n\nlistProto.clearItemLayouts = function () {\n  this._itemLayouts.length = 0;\n};\n/**\n * Get visual property of single data item\n * @param {number} idx\n * @param {string} key\n * @param {boolean} [ignoreParent=false]\n */\n\n\nlistProto.getItemVisual = function (idx, key, ignoreParent) {\n  var itemVisual = this._itemVisuals[idx];\n  var val = itemVisual && itemVisual[key];\n\n  if (val == null && !ignoreParent) {\n    // Use global visual property\n    return this.getVisual(key);\n  }\n\n  return val;\n};\n/**\n * Set visual property of single data item\n *\n * @param {number} idx\n * @param {string|Object} key\n * @param {*} [value]\n *\n * @example\n *  setItemVisual(0, 'color', color);\n *  setItemVisual(0, {\n *      'color': color\n *  });\n */\n\n\nlistProto.setItemVisual = function (idx, key, value) {\n  var itemVisual = this._itemVisuals[idx] || {};\n  this._itemVisuals[idx] = itemVisual;\n\n  if (isObject(key)) {\n    for (var name in key) {\n      if (key.hasOwnProperty(name)) {\n        itemVisual[name] = key[name];\n      }\n    }\n\n    return;\n  }\n\n  itemVisual[key] = value;\n};\n/**\n * Clear itemVisuals and list visual.\n */\n\n\nlistProto.clearAllVisual = function () {\n  this._visual = {};\n  this._itemVisuals = [];\n};\n\nvar setItemDataAndSeriesIndex = function (child) {\n  child.seriesIndex = this.seriesIndex;\n  child.dataIndex = this.dataIndex;\n  child.dataType = this.dataType;\n};\n/**\n * Set graphic element relative to data. It can be set as null\n * @param {number} idx\n * @param {module:zrender/Element} [el]\n */\n\n\nlistProto.setItemGraphicEl = function (idx, el) {\n  var hostModel = this.hostModel;\n\n  if (el) {\n    // Add data index and series index for indexing the data by element\n    // Useful in tooltip\n    el.dataIndex = idx;\n    el.dataType = this.dataType;\n    el.seriesIndex = hostModel && hostModel.seriesIndex;\n\n    if (el.type === 'group') {\n      el.traverse(setItemDataAndSeriesIndex, el);\n    }\n  }\n\n  this._graphicEls[idx] = el;\n};\n/**\n * @param {number} idx\n * @return {module:zrender/Element}\n */\n\n\nlistProto.getItemGraphicEl = function (idx) {\n  return this._graphicEls[idx];\n};\n/**\n * @param {Function} cb\n * @param {*} context\n */\n\n\nlistProto.eachItemGraphicEl = function (cb, context) {\n  zrUtil.each(this._graphicEls, function (el, idx) {\n    if (el) {\n      cb && cb.call(context, el, idx);\n    }\n  });\n};\n/**\n * Shallow clone a new list except visual and layout properties, and graph elements.\n * New list only change the indices.\n */\n\n\nlistProto.cloneShallow = function () {\n  var dimensionInfoList = zrUtil.map(this.dimensions, this.getDimensionInfo, this);\n  var list = new List(dimensionInfoList, this.hostModel); // FIXME\n\n  list._storage = this._storage;\n  transferProperties(list, this); // Clone will not change the data extent and indices\n\n  list.indices = this.indices.slice();\n\n  if (this._extent) {\n    list._extent = zrUtil.extend({}, this._extent);\n  }\n\n  return list;\n};\n/**\n * Wrap some method to add more feature\n * @param {string} methodName\n * @param {Function} injectFunction\n */\n\n\nlistProto.wrapMethod = function (methodName, injectFunction) {\n  var originalMethod = this[methodName];\n\n  if (typeof originalMethod !== 'function') {\n    return;\n  }\n\n  this.__wrappedMethods = this.__wrappedMethods || [];\n\n  this.__wrappedMethods.push(methodName);\n\n  this[methodName] = function () {\n    var res = originalMethod.apply(this, arguments);\n    return injectFunction.apply(this, [res].concat(zrUtil.slice(arguments)));\n  };\n}; // Methods that create a new list based on this list should be listed here.\n// Notice that those method should `RETURN` the new list.\n\n\nlistProto.TRANSFERABLE_METHODS = ['cloneShallow', 'downSample', 'map']; // Methods that change indices of this list should be listed here.\n\nlistProto.CHANGABLE_METHODS = ['filterSelf'];\nvar _default = List;\nmodule.exports = _default;","map":{"version":3,"sources":["/home/martin/Escritorio/Taller de Integracion/Tarea3-TallerDeIntegracion/node_modules/react-echarts/node_modules/echarts/lib/data/List.js"],"names":["_config","require","__DEV__","zrUtil","Model","DataDiffer","modelUtil","isObject","UNDEFINED","globalObj","window","global","dataCtors","Float64Array","Array","Int32Array","TRANSFERABLE_PROPERTIES","transferProperties","a","b","each","concat","__wrappedMethods","propName","hasOwnProperty","DefaultDataProvider","dataArray","_array","prototype","pure","count","length","getItem","idx","List","dimensions","hostModel","dimensionInfos","dimensionNames","i","dimensionName","dimensionInfo","name","coordDim","coordDimIndex","stackable","type","otherDims","push","_dimensionInfos","dataType","indices","_storage","_nameList","_idList","_optionModels","stackedOn","_visual","_layout","_itemVisuals","_itemLayouts","_graphicEls","_rawData","_extent","listProto","hasItemOption","getDimension","dim","isNaN","getDimensionInfo","clone","initData","data","nameList","dimValueGetter","isDataArray","isArray","storage","dimensionInfoMap","size","idList","nameRepeatCount","nameDimIdx","dimInfo","itemName","DataCtor","self","dataItem","dimName","dataIndex","dimIndex","value","getDataItemValue","isDataItemOption","converDataValue","k","dimStorage","id","get","stack","NaN","stackedValue","getValues","values","len","hasValue","getDataExtent","filter","dimData","dimExtent","min","Infinity","max","getSum","sum","indexOf","rawIndex","indexOfName","indexOfRawIndex","rawDataIndex","left","right","mid","indicesOfNearest","maxDistance","nearestIndices","minDist","Number","MAX_VALUE","minDiff","diff","dist","Math","abs","getRawIndex","rawIdx","getRawDataItem","getName","getId","normalizeDimensions","dims","cb","context","map","dimSize","call","apply","filterSelf","newIndices","keep","mapArray","result","arguments","cloneListForMapAndSample","original","excludeDimensions","allDimensions","list","originalStorage","dimStore","constructor","tmpRetValue","retValue","downSample","dimension","rate","sampleValue","sampleIndex","targetStorage","originalIndices","frameValues","frameIndices","frameSize","floor","getItemModel","ecModel","otherList","otherIdList","val","prefix","getVisual","key","visual","setVisual","setLayout","getLayout","getItemLayout","setItemLayout","layout","merge","extend","clearItemLayouts","getItemVisual","ignoreParent","itemVisual","setItemVisual","clearAllVisual","setItemDataAndSeriesIndex","child","seriesIndex","setItemGraphicEl","el","traverse","getItemGraphicEl","eachItemGraphicEl","cloneShallow","dimensionInfoList","slice","wrapMethod","methodName","injectFunction","originalMethod","res","TRANSFERABLE_METHODS","CHANGABLE_METHODS","_default","module","exports"],"mappings":"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","sourcesContent":["var _config = require(\"../config\");\n\nvar __DEV__ = _config.__DEV__;\n\nvar zrUtil = require(\"zrender/lib/core/util\");\n\nvar Model = require(\"../model/Model\");\n\nvar DataDiffer = require(\"./DataDiffer\");\n\nvar modelUtil = require(\"../util/model\");\n\n/**\n * List for data storage\n * @module echarts/data/List\n */\nvar isObject = zrUtil.isObject;\nvar UNDEFINED = 'undefined';\nvar globalObj = typeof window === UNDEFINED ? global : window;\nvar dataCtors = {\n  'float': typeof globalObj.Float64Array === UNDEFINED ? Array : globalObj.Float64Array,\n  'int': typeof globalObj.Int32Array === UNDEFINED ? Array : globalObj.Int32Array,\n  // Ordinal data type can be string or int\n  'ordinal': Array,\n  'number': Array,\n  'time': Array\n};\nvar TRANSFERABLE_PROPERTIES = ['stackedOn', 'hasItemOption', '_nameList', '_idList', '_rawData'];\n\nfunction transferProperties(a, b) {\n  zrUtil.each(TRANSFERABLE_PROPERTIES.concat(b.__wrappedMethods || []), function (propName) {\n    if (b.hasOwnProperty(propName)) {\n      a[propName] = b[propName];\n    }\n  });\n  a.__wrappedMethods = b.__wrappedMethods;\n}\n\nfunction DefaultDataProvider(dataArray) {\n  this._array = dataArray || [];\n}\n\nDefaultDataProvider.prototype.pure = false;\n\nDefaultDataProvider.prototype.count = function () {\n  return this._array.length;\n};\n\nDefaultDataProvider.prototype.getItem = function (idx) {\n  return this._array[idx];\n};\n/**\n * @constructor\n * @alias module:echarts/data/List\n *\n * @param {Array.<string|Object>} dimensions\n *      For example, ['someDimName', {name: 'someDimName', type: 'someDimType'}, ...].\n *      Dimensions should be concrete names like x, y, z, lng, lat, angle, radius\n * @param {module:echarts/model/Model} hostModel\n */\n\n\nvar List = function (dimensions, hostModel) {\n  dimensions = dimensions || ['x', 'y'];\n  var dimensionInfos = {};\n  var dimensionNames = [];\n\n  for (var i = 0; i < dimensions.length; i++) {\n    var dimensionName;\n    var dimensionInfo = {};\n\n    if (typeof dimensions[i] === 'string') {\n      dimensionName = dimensions[i];\n      dimensionInfo = {\n        name: dimensionName,\n        coordDim: dimensionName,\n        coordDimIndex: 0,\n        stackable: false,\n        // Type can be 'float', 'int', 'number'\n        // Default is number, Precision of float may not enough\n        type: 'number'\n      };\n    } else {\n      dimensionInfo = dimensions[i];\n      dimensionName = dimensionInfo.name;\n      dimensionInfo.type = dimensionInfo.type || 'number';\n\n      if (!dimensionInfo.coordDim) {\n        dimensionInfo.coordDim = dimensionName;\n        dimensionInfo.coordDimIndex = 0;\n      }\n    }\n\n    dimensionInfo.otherDims = dimensionInfo.otherDims || {};\n    dimensionNames.push(dimensionName);\n    dimensionInfos[dimensionName] = dimensionInfo;\n  }\n  /**\n   * @readOnly\n   * @type {Array.<string>}\n   */\n\n\n  this.dimensions = dimensionNames;\n  /**\n   * Infomation of each data dimension, like data type.\n   * @type {Object}\n   */\n\n  this._dimensionInfos = dimensionInfos;\n  /**\n   * @type {module:echarts/model/Model}\n   */\n\n  this.hostModel = hostModel;\n  /**\n   * @type {module:echarts/model/Model}\n   */\n\n  this.dataType;\n  /**\n   * Indices stores the indices of data subset after filtered.\n   * This data subset will be used in chart.\n   * @type {Array.<number>}\n   * @readOnly\n   */\n\n  this.indices = [];\n  /**\n   * Data storage\n   * @type {Object.<key, TypedArray|Array>}\n   * @private\n   */\n\n  this._storage = {};\n  /**\n   * @type {Array.<string>}\n   */\n\n  this._nameList = [];\n  /**\n   * @type {Array.<string>}\n   */\n\n  this._idList = [];\n  /**\n   * Models of data option is stored sparse for optimizing memory cost\n   * @type {Array.<module:echarts/model/Model>}\n   * @private\n   */\n\n  this._optionModels = [];\n  /**\n   * @param {module:echarts/data/List}\n   */\n\n  this.stackedOn = null;\n  /**\n   * Global visual properties after visual coding\n   * @type {Object}\n   * @private\n   */\n\n  this._visual = {};\n  /**\n   * Globel layout properties.\n   * @type {Object}\n   * @private\n   */\n\n  this._layout = {};\n  /**\n   * Item visual properties after visual coding\n   * @type {Array.<Object>}\n   * @private\n   */\n\n  this._itemVisuals = [];\n  /**\n   * Item layout properties after layout\n   * @type {Array.<Object>}\n   * @private\n   */\n\n  this._itemLayouts = [];\n  /**\n   * Graphic elemnents\n   * @type {Array.<module:zrender/Element>}\n   * @private\n   */\n\n  this._graphicEls = [];\n  /**\n   * @type {Array.<Array|Object>}\n   * @private\n   */\n\n  this._rawData;\n  /**\n   * @type {Object}\n   * @private\n   */\n\n  this._extent;\n};\n\nvar listProto = List.prototype;\nlistProto.type = 'list';\n/**\n * If each data item has it's own option\n * @type {boolean}\n */\n\nlistProto.hasItemOption = true;\n/**\n * Get dimension name\n * @param {string|number} dim\n *        Dimension can be concrete names like x, y, z, lng, lat, angle, radius\n *        Or a ordinal number. For example getDimensionInfo(0) will return 'x' or 'lng' or 'radius'\n * @return {string} Concrete dim name.\n */\n\nlistProto.getDimension = function (dim) {\n  if (!isNaN(dim)) {\n    dim = this.dimensions[dim] || dim;\n  }\n\n  return dim;\n};\n/**\n * Get type and stackable info of particular dimension\n * @param {string|number} dim\n *        Dimension can be concrete names like x, y, z, lng, lat, angle, radius\n *        Or a ordinal number. For example getDimensionInfo(0) will return 'x' or 'lng' or 'radius'\n */\n\n\nlistProto.getDimensionInfo = function (dim) {\n  return zrUtil.clone(this._dimensionInfos[this.getDimension(dim)]);\n};\n/**\n * Initialize from data\n * @param {Array.<Object|number|Array>} data\n * @param {Array.<string>} [nameList]\n * @param {Function} [dimValueGetter] (dataItem, dimName, dataIndex, dimIndex) => number\n */\n\n\nlistProto.initData = function (data, nameList, dimValueGetter) {\n  data = data || [];\n  var isDataArray = zrUtil.isArray(data);\n\n  if (isDataArray) {\n    data = new DefaultDataProvider(data);\n  }\n\n  this._rawData = data; // Clear\n\n  var storage = this._storage = {};\n  var indices = this.indices = [];\n  var dimensions = this.dimensions;\n  var dimensionInfoMap = this._dimensionInfos;\n  var size = data.count();\n  var idList = [];\n  var nameRepeatCount = {};\n  var nameDimIdx;\n  nameList = nameList || []; // Init storage\n\n  for (var i = 0; i < dimensions.length; i++) {\n    var dimInfo = dimensionInfoMap[dimensions[i]];\n    dimInfo.otherDims.itemName === 0 && (nameDimIdx = i);\n    var DataCtor = dataCtors[dimInfo.type];\n    storage[dimensions[i]] = new DataCtor(size);\n  }\n\n  var self = this;\n\n  if (!dimValueGetter) {\n    self.hasItemOption = false;\n  } // Default dim value getter\n\n\n  dimValueGetter = dimValueGetter || function (dataItem, dimName, dataIndex, dimIndex) {\n    var value = modelUtil.getDataItemValue(dataItem); // If any dataItem is like { value: 10 }\n\n    if (modelUtil.isDataItemOption(dataItem)) {\n      self.hasItemOption = true;\n    }\n\n    return modelUtil.converDataValue(value instanceof Array ? value[dimIndex] // If value is a single number or something else not array.\n    : value, dimensionInfoMap[dimName]);\n  };\n\n  for (var i = 0; i < size; i++) {\n    // NOTICE: Try not to write things into dataItem\n    var dataItem = data.getItem(i); // Each data item is value\n    // [1, 2]\n    // 2\n    // Bar chart, line chart which uses category axis\n    // only gives the 'y' value. 'x' value is the indices of cateogry\n    // Use a tempValue to normalize the value to be a (x, y) value\n    // Store the data by dimensions\n\n    for (var k = 0; k < dimensions.length; k++) {\n      var dim = dimensions[k];\n      var dimStorage = storage[dim]; // PENDING NULL is empty or zero\n\n      dimStorage[i] = dimValueGetter(dataItem, dim, i, k);\n    }\n\n    indices.push(i);\n  } // Use the name in option and create id\n\n\n  for (var i = 0; i < size; i++) {\n    var dataItem = data.getItem(i);\n\n    if (!nameList[i] && dataItem) {\n      if (dataItem.name != null) {\n        nameList[i] = dataItem.name;\n      } else if (nameDimIdx != null) {\n        nameList[i] = storage[dimensions[nameDimIdx]][i];\n      }\n    }\n\n    var name = nameList[i] || ''; // Try using the id in option\n\n    var id = dataItem && dataItem.id;\n\n    if (!id && name) {\n      // Use name as id and add counter to avoid same name\n      nameRepeatCount[name] = nameRepeatCount[name] || 0;\n      id = name;\n\n      if (nameRepeatCount[name] > 0) {\n        id += '__ec__' + nameRepeatCount[name];\n      }\n\n      nameRepeatCount[name]++;\n    }\n\n    id && (idList[i] = id);\n  }\n\n  this._nameList = nameList;\n  this._idList = idList;\n};\n/**\n * @return {number}\n */\n\n\nlistProto.count = function () {\n  return this.indices.length;\n};\n/**\n * Get value. Return NaN if idx is out of range.\n * @param {string} dim Dim must be concrete name.\n * @param {number} idx\n * @param {boolean} stack\n * @return {number}\n */\n\n\nlistProto.get = function (dim, idx, stack) {\n  var storage = this._storage;\n  var dataIndex = this.indices[idx]; // If value not exists\n\n  if (dataIndex == null || !storage[dim]) {\n    return NaN;\n  }\n\n  var value = storage[dim][dataIndex]; // FIXME ordinal data type is not stackable\n\n  if (stack) {\n    var dimensionInfo = this._dimensionInfos[dim];\n\n    if (dimensionInfo && dimensionInfo.stackable) {\n      var stackedOn = this.stackedOn;\n\n      while (stackedOn) {\n        // Get no stacked data of stacked on\n        var stackedValue = stackedOn.get(dim, idx); // Considering positive stack, negative stack and empty data\n\n        if (value >= 0 && stackedValue > 0 || // Positive stack\n        value <= 0 && stackedValue < 0 // Negative stack\n        ) {\n            value += stackedValue;\n          }\n\n        stackedOn = stackedOn.stackedOn;\n      }\n    }\n  }\n\n  return value;\n};\n/**\n * Get value for multi dimensions.\n * @param {Array.<string>} [dimensions] If ignored, using all dimensions.\n * @param {number} idx\n * @param {boolean} stack\n * @return {number}\n */\n\n\nlistProto.getValues = function (dimensions, idx, stack) {\n  var values = [];\n\n  if (!zrUtil.isArray(dimensions)) {\n    stack = idx;\n    idx = dimensions;\n    dimensions = this.dimensions;\n  }\n\n  for (var i = 0, len = dimensions.length; i < len; i++) {\n    values.push(this.get(dimensions[i], idx, stack));\n  }\n\n  return values;\n};\n/**\n * If value is NaN. Inlcuding '-'\n * @param {string} dim\n * @param {number} idx\n * @return {number}\n */\n\n\nlistProto.hasValue = function (idx) {\n  var dimensions = this.dimensions;\n  var dimensionInfos = this._dimensionInfos;\n\n  for (var i = 0, len = dimensions.length; i < len; i++) {\n    if ( // Ordinal type can be string or number\n    dimensionInfos[dimensions[i]].type !== 'ordinal' && isNaN(this.get(dimensions[i], idx))) {\n      return false;\n    }\n  }\n\n  return true;\n};\n/**\n * Get extent of data in one dimension\n * @param {string} dim\n * @param {boolean} stack\n * @param {Function} filter\n */\n\n\nlistProto.getDataExtent = function (dim, stack, filter) {\n  dim = this.getDimension(dim);\n  var dimData = this._storage[dim];\n  var dimInfo = this.getDimensionInfo(dim);\n  stack = dimInfo && dimInfo.stackable && stack;\n  var dimExtent = (this._extent || (this._extent = {}))[dim + !!stack];\n  var value;\n\n  if (dimExtent) {\n    return dimExtent;\n  } // var dimInfo = this._dimensionInfos[dim];\n\n\n  if (dimData) {\n    var min = Infinity;\n    var max = -Infinity; // var isOrdinal = dimInfo.type === 'ordinal';\n\n    for (var i = 0, len = this.count(); i < len; i++) {\n      value = this.get(dim, i, stack); // FIXME\n      // if (isOrdinal && typeof value === 'string') {\n      //     value = zrUtil.indexOf(dimData, value);\n      // }\n\n      if (!filter || filter(value, dim, i)) {\n        value < min && (min = value);\n        value > max && (max = value);\n      }\n    }\n\n    return this._extent[dim + !!stack] = [min, max];\n  } else {\n    return [Infinity, -Infinity];\n  }\n};\n/**\n * Get sum of data in one dimension\n * @param {string} dim\n * @param {boolean} stack\n */\n\n\nlistProto.getSum = function (dim, stack) {\n  var dimData = this._storage[dim];\n  var sum = 0;\n\n  if (dimData) {\n    for (var i = 0, len = this.count(); i < len; i++) {\n      var value = this.get(dim, i, stack);\n\n      if (!isNaN(value)) {\n        sum += value;\n      }\n    }\n  }\n\n  return sum;\n};\n/**\n * Retreive the index with given value\n * @param {number} idx\n * @param {number} value\n * @return {number}\n */\n// FIXME Precision of float value\n\n\nlistProto.indexOf = function (dim, value) {\n  var storage = this._storage;\n  var dimData = storage[dim];\n  var indices = this.indices;\n\n  if (dimData) {\n    for (var i = 0, len = indices.length; i < len; i++) {\n      var rawIndex = indices[i];\n\n      if (dimData[rawIndex] === value) {\n        return i;\n      }\n    }\n  }\n\n  return -1;\n};\n/**\n * Retreive the index with given name\n * @param {number} idx\n * @param {number} name\n * @return {number}\n */\n\n\nlistProto.indexOfName = function (name) {\n  var indices = this.indices;\n  var nameList = this._nameList;\n\n  for (var i = 0, len = indices.length; i < len; i++) {\n    var rawIndex = indices[i];\n\n    if (nameList[rawIndex] === name) {\n      return i;\n    }\n  }\n\n  return -1;\n};\n/**\n * Retreive the index with given raw data index\n * @param {number} idx\n * @param {number} name\n * @return {number}\n */\n\n\nlistProto.indexOfRawIndex = function (rawIndex) {\n  // Indices are ascending\n  var indices = this.indices; // If rawIndex === dataIndex\n\n  var rawDataIndex = indices[rawIndex];\n\n  if (rawDataIndex != null && rawDataIndex === rawIndex) {\n    return rawIndex;\n  }\n\n  var left = 0;\n  var right = indices.length - 1;\n\n  while (left <= right) {\n    var mid = (left + right) / 2 | 0;\n\n    if (indices[mid] < rawIndex) {\n      left = mid + 1;\n    } else if (indices[mid] > rawIndex) {\n      right = mid - 1;\n    } else {\n      return mid;\n    }\n  }\n\n  return -1;\n};\n/**\n * Retreive the index of nearest value\n * @param {string} dim\n * @param {number} value\n * @param {boolean} stack If given value is after stacked\n * @param {number} [maxDistance=Infinity]\n * @return {Array.<number>} Considere multiple points has the same value.\n */\n\n\nlistProto.indicesOfNearest = function (dim, value, stack, maxDistance) {\n  var storage = this._storage;\n  var dimData = storage[dim];\n  var nearestIndices = [];\n\n  if (!dimData) {\n    return nearestIndices;\n  }\n\n  if (maxDistance == null) {\n    maxDistance = Infinity;\n  }\n\n  var minDist = Number.MAX_VALUE;\n  var minDiff = -1;\n\n  for (var i = 0, len = this.count(); i < len; i++) {\n    var diff = value - this.get(dim, i, stack);\n    var dist = Math.abs(diff);\n\n    if (diff <= maxDistance && dist <= minDist) {\n      // For the case of two data are same on xAxis, which has sequence data.\n      // Show the nearest index\n      // https://github.com/ecomfe/echarts/issues/2869\n      if (dist < minDist || diff >= 0 && minDiff < 0) {\n        minDist = dist;\n        minDiff = diff;\n        nearestIndices.length = 0;\n      }\n\n      nearestIndices.push(i);\n    }\n  }\n\n  return nearestIndices;\n};\n/**\n * Get raw data index\n * @param {number} idx\n * @return {number}\n */\n\n\nlistProto.getRawIndex = function (idx) {\n  var rawIdx = this.indices[idx];\n  return rawIdx == null ? -1 : rawIdx;\n};\n/**\n * Get raw data item\n * @param {number} idx\n * @return {number}\n */\n\n\nlistProto.getRawDataItem = function (idx) {\n  return this._rawData.getItem(this.getRawIndex(idx));\n};\n/**\n * @param {number} idx\n * @param {boolean} [notDefaultIdx=false]\n * @return {string}\n */\n\n\nlistProto.getName = function (idx) {\n  return this._nameList[this.indices[idx]] || '';\n};\n/**\n * @param {number} idx\n * @param {boolean} [notDefaultIdx=false]\n * @return {string}\n */\n\n\nlistProto.getId = function (idx) {\n  return this._idList[this.indices[idx]] || this.getRawIndex(idx) + '';\n};\n\nfunction normalizeDimensions(dimensions) {\n  if (!zrUtil.isArray(dimensions)) {\n    dimensions = [dimensions];\n  }\n\n  return dimensions;\n}\n/**\n * Data iteration\n * @param {string|Array.<string>}\n * @param {Function} cb\n * @param {boolean} [stack=false]\n * @param {*} [context=this]\n *\n * @example\n *  list.each('x', function (x, idx) {});\n *  list.each(['x', 'y'], function (x, y, idx) {});\n *  list.each(function (idx) {})\n */\n\n\nlistProto.each = function (dims, cb, stack, context) {\n  if (typeof dims === 'function') {\n    context = stack;\n    stack = cb;\n    cb = dims;\n    dims = [];\n  }\n\n  dims = zrUtil.map(normalizeDimensions(dims), this.getDimension, this);\n  var value = [];\n  var dimSize = dims.length;\n  var indices = this.indices;\n  context = context || this;\n\n  for (var i = 0; i < indices.length; i++) {\n    // Simple optimization\n    switch (dimSize) {\n      case 0:\n        cb.call(context, i);\n        break;\n\n      case 1:\n        cb.call(context, this.get(dims[0], i, stack), i);\n        break;\n\n      case 2:\n        cb.call(context, this.get(dims[0], i, stack), this.get(dims[1], i, stack), i);\n        break;\n\n      default:\n        for (var k = 0; k < dimSize; k++) {\n          value[k] = this.get(dims[k], i, stack);\n        } // Index\n\n\n        value[k] = i;\n        cb.apply(context, value);\n    }\n  }\n};\n/**\n * Data filter\n * @param {string|Array.<string>}\n * @param {Function} cb\n * @param {boolean} [stack=false]\n * @param {*} [context=this]\n */\n\n\nlistProto.filterSelf = function (dimensions, cb, stack, context) {\n  if (typeof dimensions === 'function') {\n    context = stack;\n    stack = cb;\n    cb = dimensions;\n    dimensions = [];\n  }\n\n  dimensions = zrUtil.map(normalizeDimensions(dimensions), this.getDimension, this);\n  var newIndices = [];\n  var value = [];\n  var dimSize = dimensions.length;\n  var indices = this.indices;\n  context = context || this;\n\n  for (var i = 0; i < indices.length; i++) {\n    var keep; // Simple optimization\n\n    if (!dimSize) {\n      keep = cb.call(context, i);\n    } else if (dimSize === 1) {\n      keep = cb.call(context, this.get(dimensions[0], i, stack), i);\n    } else {\n      for (var k = 0; k < dimSize; k++) {\n        value[k] = this.get(dimensions[k], i, stack);\n      }\n\n      value[k] = i;\n      keep = cb.apply(context, value);\n    }\n\n    if (keep) {\n      newIndices.push(indices[i]);\n    }\n  }\n\n  this.indices = newIndices; // Reset data extent\n\n  this._extent = {};\n  return this;\n};\n/**\n * Data mapping to a plain array\n * @param {string|Array.<string>} [dimensions]\n * @param {Function} cb\n * @param {boolean} [stack=false]\n * @param {*} [context=this]\n * @return {Array}\n */\n\n\nlistProto.mapArray = function (dimensions, cb, stack, context) {\n  if (typeof dimensions === 'function') {\n    context = stack;\n    stack = cb;\n    cb = dimensions;\n    dimensions = [];\n  }\n\n  var result = [];\n  this.each(dimensions, function () {\n    result.push(cb && cb.apply(this, arguments));\n  }, stack, context);\n  return result;\n};\n\nfunction cloneListForMapAndSample(original, excludeDimensions) {\n  var allDimensions = original.dimensions;\n  var list = new List(zrUtil.map(allDimensions, original.getDimensionInfo, original), original.hostModel); // FIXME If needs stackedOn, value may already been stacked\n\n  transferProperties(list, original);\n  var storage = list._storage = {};\n  var originalStorage = original._storage; // Init storage\n\n  for (var i = 0; i < allDimensions.length; i++) {\n    var dim = allDimensions[i];\n    var dimStore = originalStorage[dim];\n\n    if (zrUtil.indexOf(excludeDimensions, dim) >= 0) {\n      storage[dim] = new dimStore.constructor(originalStorage[dim].length);\n    } else {\n      // Direct reference for other dimensions\n      storage[dim] = originalStorage[dim];\n    }\n  }\n\n  return list;\n}\n/**\n * Data mapping to a new List with given dimensions\n * @param {string|Array.<string>} dimensions\n * @param {Function} cb\n * @param {boolean} [stack=false]\n * @param {*} [context=this]\n * @return {Array}\n */\n\n\nlistProto.map = function (dimensions, cb, stack, context) {\n  dimensions = zrUtil.map(normalizeDimensions(dimensions), this.getDimension, this);\n  var list = cloneListForMapAndSample(this, dimensions); // Following properties are all immutable.\n  // So we can reference to the same value\n\n  var indices = list.indices = this.indices;\n  var storage = list._storage;\n  var tmpRetValue = [];\n  this.each(dimensions, function () {\n    var idx = arguments[arguments.length - 1];\n    var retValue = cb && cb.apply(this, arguments);\n\n    if (retValue != null) {\n      // a number\n      if (typeof retValue === 'number') {\n        tmpRetValue[0] = retValue;\n        retValue = tmpRetValue;\n      }\n\n      for (var i = 0; i < retValue.length; i++) {\n        var dim = dimensions[i];\n        var dimStore = storage[dim];\n        var rawIdx = indices[idx];\n\n        if (dimStore) {\n          dimStore[rawIdx] = retValue[i];\n        }\n      }\n    }\n  }, stack, context);\n  return list;\n};\n/**\n * Large data down sampling on given dimension\n * @param {string} dimension\n * @param {number} rate\n * @param {Function} sampleValue\n * @param {Function} sampleIndex Sample index for name and id\n */\n\n\nlistProto.downSample = function (dimension, rate, sampleValue, sampleIndex) {\n  var list = cloneListForMapAndSample(this, [dimension]);\n  var storage = this._storage;\n  var targetStorage = list._storage;\n  var originalIndices = this.indices;\n  var indices = list.indices = [];\n  var frameValues = [];\n  var frameIndices = [];\n  var frameSize = Math.floor(1 / rate);\n  var dimStore = targetStorage[dimension];\n  var len = this.count(); // Copy data from original data\n\n  for (var i = 0; i < storage[dimension].length; i++) {\n    targetStorage[dimension][i] = storage[dimension][i];\n  }\n\n  for (var i = 0; i < len; i += frameSize) {\n    // Last frame\n    if (frameSize > len - i) {\n      frameSize = len - i;\n      frameValues.length = frameSize;\n    }\n\n    for (var k = 0; k < frameSize; k++) {\n      var idx = originalIndices[i + k];\n      frameValues[k] = dimStore[idx];\n      frameIndices[k] = idx;\n    }\n\n    var value = sampleValue(frameValues);\n    var idx = frameIndices[sampleIndex(frameValues, value) || 0]; // Only write value on the filtered data\n\n    dimStore[idx] = value;\n    indices.push(idx);\n  }\n\n  return list;\n};\n/**\n * Get model of one data item.\n *\n * @param {number} idx\n */\n// FIXME Model proxy ?\n\n\nlistProto.getItemModel = function (idx) {\n  var hostModel = this.hostModel;\n  idx = this.indices[idx];\n  return new Model(this._rawData.getItem(idx), hostModel, hostModel && hostModel.ecModel);\n};\n/**\n * Create a data differ\n * @param {module:echarts/data/List} otherList\n * @return {module:echarts/data/DataDiffer}\n */\n\n\nlistProto.diff = function (otherList) {\n  var idList = this._idList;\n  var otherIdList = otherList && otherList._idList;\n  var val; // Use prefix to avoid index to be the same as otherIdList[idx],\n  // which will cause weird udpate animation.\n\n  var prefix = 'e\\0\\0';\n  return new DataDiffer(otherList ? otherList.indices : [], this.indices, function (idx) {\n    return (val = otherIdList[idx]) != null ? val : prefix + idx;\n  }, function (idx) {\n    return (val = idList[idx]) != null ? val : prefix + idx;\n  });\n};\n/**\n * Get visual property.\n * @param {string} key\n */\n\n\nlistProto.getVisual = function (key) {\n  var visual = this._visual;\n  return visual && visual[key];\n};\n/**\n * Set visual property\n * @param {string|Object} key\n * @param {*} [value]\n *\n * @example\n *  setVisual('color', color);\n *  setVisual({\n *      'color': color\n *  });\n */\n\n\nlistProto.setVisual = function (key, val) {\n  if (isObject(key)) {\n    for (var name in key) {\n      if (key.hasOwnProperty(name)) {\n        this.setVisual(name, key[name]);\n      }\n    }\n\n    return;\n  }\n\n  this._visual = this._visual || {};\n  this._visual[key] = val;\n};\n/**\n * Set layout property.\n * @param {string|Object} key\n * @param {*} [val]\n */\n\n\nlistProto.setLayout = function (key, val) {\n  if (isObject(key)) {\n    for (var name in key) {\n      if (key.hasOwnProperty(name)) {\n        this.setLayout(name, key[name]);\n      }\n    }\n\n    return;\n  }\n\n  this._layout[key] = val;\n};\n/**\n * Get layout property.\n * @param  {string} key.\n * @return {*}\n */\n\n\nlistProto.getLayout = function (key) {\n  return this._layout[key];\n};\n/**\n * Get layout of single data item\n * @param {number} idx\n */\n\n\nlistProto.getItemLayout = function (idx) {\n  return this._itemLayouts[idx];\n};\n/**\n * Set layout of single data item\n * @param {number} idx\n * @param {Object} layout\n * @param {boolean=} [merge=false]\n */\n\n\nlistProto.setItemLayout = function (idx, layout, merge) {\n  this._itemLayouts[idx] = merge ? zrUtil.extend(this._itemLayouts[idx] || {}, layout) : layout;\n};\n/**\n * Clear all layout of single data item\n */\n\n\nlistProto.clearItemLayouts = function () {\n  this._itemLayouts.length = 0;\n};\n/**\n * Get visual property of single data item\n * @param {number} idx\n * @param {string} key\n * @param {boolean} [ignoreParent=false]\n */\n\n\nlistProto.getItemVisual = function (idx, key, ignoreParent) {\n  var itemVisual = this._itemVisuals[idx];\n  var val = itemVisual && itemVisual[key];\n\n  if (val == null && !ignoreParent) {\n    // Use global visual property\n    return this.getVisual(key);\n  }\n\n  return val;\n};\n/**\n * Set visual property of single data item\n *\n * @param {number} idx\n * @param {string|Object} key\n * @param {*} [value]\n *\n * @example\n *  setItemVisual(0, 'color', color);\n *  setItemVisual(0, {\n *      'color': color\n *  });\n */\n\n\nlistProto.setItemVisual = function (idx, key, value) {\n  var itemVisual = this._itemVisuals[idx] || {};\n  this._itemVisuals[idx] = itemVisual;\n\n  if (isObject(key)) {\n    for (var name in key) {\n      if (key.hasOwnProperty(name)) {\n        itemVisual[name] = key[name];\n      }\n    }\n\n    return;\n  }\n\n  itemVisual[key] = value;\n};\n/**\n * Clear itemVisuals and list visual.\n */\n\n\nlistProto.clearAllVisual = function () {\n  this._visual = {};\n  this._itemVisuals = [];\n};\n\nvar setItemDataAndSeriesIndex = function (child) {\n  child.seriesIndex = this.seriesIndex;\n  child.dataIndex = this.dataIndex;\n  child.dataType = this.dataType;\n};\n/**\n * Set graphic element relative to data. It can be set as null\n * @param {number} idx\n * @param {module:zrender/Element} [el]\n */\n\n\nlistProto.setItemGraphicEl = function (idx, el) {\n  var hostModel = this.hostModel;\n\n  if (el) {\n    // Add data index and series index for indexing the data by element\n    // Useful in tooltip\n    el.dataIndex = idx;\n    el.dataType = this.dataType;\n    el.seriesIndex = hostModel && hostModel.seriesIndex;\n\n    if (el.type === 'group') {\n      el.traverse(setItemDataAndSeriesIndex, el);\n    }\n  }\n\n  this._graphicEls[idx] = el;\n};\n/**\n * @param {number} idx\n * @return {module:zrender/Element}\n */\n\n\nlistProto.getItemGraphicEl = function (idx) {\n  return this._graphicEls[idx];\n};\n/**\n * @param {Function} cb\n * @param {*} context\n */\n\n\nlistProto.eachItemGraphicEl = function (cb, context) {\n  zrUtil.each(this._graphicEls, function (el, idx) {\n    if (el) {\n      cb && cb.call(context, el, idx);\n    }\n  });\n};\n/**\n * Shallow clone a new list except visual and layout properties, and graph elements.\n * New list only change the indices.\n */\n\n\nlistProto.cloneShallow = function () {\n  var dimensionInfoList = zrUtil.map(this.dimensions, this.getDimensionInfo, this);\n  var list = new List(dimensionInfoList, this.hostModel); // FIXME\n\n  list._storage = this._storage;\n  transferProperties(list, this); // Clone will not change the data extent and indices\n\n  list.indices = this.indices.slice();\n\n  if (this._extent) {\n    list._extent = zrUtil.extend({}, this._extent);\n  }\n\n  return list;\n};\n/**\n * Wrap some method to add more feature\n * @param {string} methodName\n * @param {Function} injectFunction\n */\n\n\nlistProto.wrapMethod = function (methodName, injectFunction) {\n  var originalMethod = this[methodName];\n\n  if (typeof originalMethod !== 'function') {\n    return;\n  }\n\n  this.__wrappedMethods = this.__wrappedMethods || [];\n\n  this.__wrappedMethods.push(methodName);\n\n  this[methodName] = function () {\n    var res = originalMethod.apply(this, arguments);\n    return injectFunction.apply(this, [res].concat(zrUtil.slice(arguments)));\n  };\n}; // Methods that create a new list based on this list should be listed here.\n// Notice that those method should `RETURN` the new list.\n\n\nlistProto.TRANSFERABLE_METHODS = ['cloneShallow', 'downSample', 'map']; // Methods that change indices of this list should be listed here.\n\nlistProto.CHANGABLE_METHODS = ['filterSelf'];\nvar _default = List;\nmodule.exports = _default;"]},"metadata":{},"sourceType":"script"}