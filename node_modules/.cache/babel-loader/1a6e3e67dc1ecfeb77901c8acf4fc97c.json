{"ast":null,"code":"var zrUtil = require(\"zrender/lib/core/util\");\n\nvar graphic = require(\"../../util/graphic\");\n\nvar AxisBuilder = require(\"./AxisBuilder\");\n\nvar AxisView = require(\"./AxisView\");\n\nvar cartesianAxisHelper = require(\"./cartesianAxisHelper\");\n\nvar ifIgnoreOnTick = AxisBuilder.ifIgnoreOnTick;\nvar getInterval = AxisBuilder.getInterval;\nvar axisBuilderAttrs = ['axisLine', 'axisTickLabel', 'axisName'];\nvar selfBuilderAttrs = ['splitArea', 'splitLine']; // function getAlignWithLabel(model, axisModel) {\n//     var alignWithLabel = model.get('alignWithLabel');\n//     if (alignWithLabel === 'auto') {\n//         alignWithLabel = axisModel.get('axisTick.alignWithLabel');\n//     }\n//     return alignWithLabel;\n// }\n\nvar CartesianAxisView = AxisView.extend({\n  type: 'cartesianAxis',\n  axisPointerClass: 'CartesianAxisPointer',\n\n  /**\n   * @override\n   */\n  render: function (axisModel, ecModel, api, payload) {\n    this.group.removeAll();\n    var oldAxisGroup = this._axisGroup;\n    this._axisGroup = new graphic.Group();\n    this.group.add(this._axisGroup);\n\n    if (!axisModel.get('show')) {\n      return;\n    }\n\n    var gridModel = axisModel.getCoordSysModel();\n    var layout = cartesianAxisHelper.layout(gridModel, axisModel);\n    var axisBuilder = new AxisBuilder(axisModel, layout);\n    zrUtil.each(axisBuilderAttrs, axisBuilder.add, axisBuilder);\n\n    this._axisGroup.add(axisBuilder.getGroup());\n\n    zrUtil.each(selfBuilderAttrs, function (name) {\n      if (axisModel.get(name + '.show')) {\n        this['_' + name](axisModel, gridModel, layout.labelInterval);\n      }\n    }, this);\n    graphic.groupTransition(oldAxisGroup, this._axisGroup, axisModel);\n    CartesianAxisView.superCall(this, 'render', axisModel, ecModel, api, payload);\n  },\n\n  /**\n   * @param {module:echarts/coord/cartesian/AxisModel} axisModel\n   * @param {module:echarts/coord/cartesian/GridModel} gridModel\n   * @param {number|Function} labelInterval\n   * @private\n   */\n  _splitLine: function (axisModel, gridModel, labelInterval) {\n    var axis = axisModel.axis;\n\n    if (axis.scale.isBlank()) {\n      return;\n    }\n\n    var splitLineModel = axisModel.getModel('splitLine');\n    var lineStyleModel = splitLineModel.getModel('lineStyle');\n    var lineColors = lineStyleModel.get('color');\n    var lineInterval = getInterval(splitLineModel, labelInterval);\n    lineColors = zrUtil.isArray(lineColors) ? lineColors : [lineColors];\n    var gridRect = gridModel.coordinateSystem.getRect();\n    var isHorizontal = axis.isHorizontal();\n    var lineCount = 0;\n    var ticksCoords = axis.getTicksCoords();\n    var ticks = axis.scale.getTicks();\n    var showMinLabel = axisModel.get('axisLabel.showMinLabel');\n    var showMaxLabel = axisModel.get('axisLabel.showMaxLabel');\n    var p1 = [];\n    var p2 = []; // Simple optimization\n    // Batching the lines if color are the same\n\n    var lineStyle = lineStyleModel.getLineStyle();\n\n    for (var i = 0; i < ticksCoords.length; i++) {\n      if (ifIgnoreOnTick(axis, i, lineInterval, ticksCoords.length, showMinLabel, showMaxLabel)) {\n        continue;\n      }\n\n      var tickCoord = axis.toGlobalCoord(ticksCoords[i]);\n\n      if (isHorizontal) {\n        p1[0] = tickCoord;\n        p1[1] = gridRect.y;\n        p2[0] = tickCoord;\n        p2[1] = gridRect.y + gridRect.height;\n      } else {\n        p1[0] = gridRect.x;\n        p1[1] = tickCoord;\n        p2[0] = gridRect.x + gridRect.width;\n        p2[1] = tickCoord;\n      }\n\n      var colorIndex = lineCount++ % lineColors.length;\n\n      this._axisGroup.add(new graphic.Line(graphic.subPixelOptimizeLine({\n        anid: 'line_' + ticks[i],\n        shape: {\n          x1: p1[0],\n          y1: p1[1],\n          x2: p2[0],\n          y2: p2[1]\n        },\n        style: zrUtil.defaults({\n          stroke: lineColors[colorIndex]\n        }, lineStyle),\n        silent: true\n      })));\n    }\n  },\n\n  /**\n   * @param {module:echarts/coord/cartesian/AxisModel} axisModel\n   * @param {module:echarts/coord/cartesian/GridModel} gridModel\n   * @param {number|Function} labelInterval\n   * @private\n   */\n  _splitArea: function (axisModel, gridModel, labelInterval) {\n    var axis = axisModel.axis;\n\n    if (axis.scale.isBlank()) {\n      return;\n    }\n\n    var splitAreaModel = axisModel.getModel('splitArea');\n    var areaStyleModel = splitAreaModel.getModel('areaStyle');\n    var areaColors = areaStyleModel.get('color');\n    var gridRect = gridModel.coordinateSystem.getRect();\n    var ticksCoords = axis.getTicksCoords();\n    var ticks = axis.scale.getTicks();\n    var prevX = axis.toGlobalCoord(ticksCoords[0]);\n    var prevY = axis.toGlobalCoord(ticksCoords[0]);\n    var count = 0;\n    var areaInterval = getInterval(splitAreaModel, labelInterval);\n    var areaStyle = areaStyleModel.getAreaStyle();\n    areaColors = zrUtil.isArray(areaColors) ? areaColors : [areaColors];\n    var showMinLabel = axisModel.get('axisLabel.showMinLabel');\n    var showMaxLabel = axisModel.get('axisLabel.showMaxLabel');\n\n    for (var i = 1; i < ticksCoords.length; i++) {\n      if (ifIgnoreOnTick(axis, i, areaInterval, ticksCoords.length, showMinLabel, showMaxLabel)) {\n        continue;\n      }\n\n      var tickCoord = axis.toGlobalCoord(ticksCoords[i]);\n      var x;\n      var y;\n      var width;\n      var height;\n\n      if (axis.isHorizontal()) {\n        x = prevX;\n        y = gridRect.y;\n        width = tickCoord - x;\n        height = gridRect.height;\n      } else {\n        x = gridRect.x;\n        y = prevY;\n        width = gridRect.width;\n        height = tickCoord - y;\n      }\n\n      var colorIndex = count++ % areaColors.length;\n\n      this._axisGroup.add(new graphic.Rect({\n        anid: 'area_' + ticks[i],\n        shape: {\n          x: x,\n          y: y,\n          width: width,\n          height: height\n        },\n        style: zrUtil.defaults({\n          fill: areaColors[colorIndex]\n        }, areaStyle),\n        silent: true\n      }));\n\n      prevX = x + width;\n      prevY = y + height;\n    }\n  }\n});\nCartesianAxisView.extend({\n  type: 'xAxis'\n});\nCartesianAxisView.extend({\n  type: 'yAxis'\n});","map":{"version":3,"sources":["/home/martin/Escritorio/Taller de Integracion/Tarea3-TallerDeIntegracion/node_modules/react-echarts/node_modules/echarts/lib/component/axis/CartesianAxisView.js"],"names":["zrUtil","require","graphic","AxisBuilder","AxisView","cartesianAxisHelper","ifIgnoreOnTick","getInterval","axisBuilderAttrs","selfBuilderAttrs","CartesianAxisView","extend","type","axisPointerClass","render","axisModel","ecModel","api","payload","group","removeAll","oldAxisGroup","_axisGroup","Group","add","get","gridModel","getCoordSysModel","layout","axisBuilder","each","getGroup","name","labelInterval","groupTransition","superCall","_splitLine","axis","scale","isBlank","splitLineModel","getModel","lineStyleModel","lineColors","lineInterval","isArray","gridRect","coordinateSystem","getRect","isHorizontal","lineCount","ticksCoords","getTicksCoords","ticks","getTicks","showMinLabel","showMaxLabel","p1","p2","lineStyle","getLineStyle","i","length","tickCoord","toGlobalCoord","y","height","x","width","colorIndex","Line","subPixelOptimizeLine","anid","shape","x1","y1","x2","y2","style","defaults","stroke","silent","_splitArea","splitAreaModel","areaStyleModel","areaColors","prevX","prevY","count","areaInterval","areaStyle","getAreaStyle","Rect","fill"],"mappings":"AAAA,IAAIA,MAAM,GAAGC,OAAO,CAAC,uBAAD,CAApB;;AAEA,IAAIC,OAAO,GAAGD,OAAO,CAAC,oBAAD,CAArB;;AAEA,IAAIE,WAAW,GAAGF,OAAO,CAAC,eAAD,CAAzB;;AAEA,IAAIG,QAAQ,GAAGH,OAAO,CAAC,YAAD,CAAtB;;AAEA,IAAII,mBAAmB,GAAGJ,OAAO,CAAC,uBAAD,CAAjC;;AAEA,IAAIK,cAAc,GAAGH,WAAW,CAACG,cAAjC;AACA,IAAIC,WAAW,GAAGJ,WAAW,CAACI,WAA9B;AACA,IAAIC,gBAAgB,GAAG,CAAC,UAAD,EAAa,eAAb,EAA8B,UAA9B,CAAvB;AACA,IAAIC,gBAAgB,GAAG,CAAC,WAAD,EAAc,WAAd,CAAvB,C,CAAmD;AACnD;AACA;AACA;AACA;AACA;AACA;;AAEA,IAAIC,iBAAiB,GAAGN,QAAQ,CAACO,MAAT,CAAgB;AACtCC,EAAAA,IAAI,EAAE,eADgC;AAEtCC,EAAAA,gBAAgB,EAAE,sBAFoB;;AAItC;;;AAGAC,EAAAA,MAAM,EAAE,UAAUC,SAAV,EAAqBC,OAArB,EAA8BC,GAA9B,EAAmCC,OAAnC,EAA4C;AAClD,SAAKC,KAAL,CAAWC,SAAX;AACA,QAAIC,YAAY,GAAG,KAAKC,UAAxB;AACA,SAAKA,UAAL,GAAkB,IAAIpB,OAAO,CAACqB,KAAZ,EAAlB;AACA,SAAKJ,KAAL,CAAWK,GAAX,CAAe,KAAKF,UAApB;;AAEA,QAAI,CAACP,SAAS,CAACU,GAAV,CAAc,MAAd,CAAL,EAA4B;AAC1B;AACD;;AAED,QAAIC,SAAS,GAAGX,SAAS,CAACY,gBAAV,EAAhB;AACA,QAAIC,MAAM,GAAGvB,mBAAmB,CAACuB,MAApB,CAA2BF,SAA3B,EAAsCX,SAAtC,CAAb;AACA,QAAIc,WAAW,GAAG,IAAI1B,WAAJ,CAAgBY,SAAhB,EAA2Ba,MAA3B,CAAlB;AACA5B,IAAAA,MAAM,CAAC8B,IAAP,CAAYtB,gBAAZ,EAA8BqB,WAAW,CAACL,GAA1C,EAA+CK,WAA/C;;AAEA,SAAKP,UAAL,CAAgBE,GAAhB,CAAoBK,WAAW,CAACE,QAAZ,EAApB;;AAEA/B,IAAAA,MAAM,CAAC8B,IAAP,CAAYrB,gBAAZ,EAA8B,UAAUuB,IAAV,EAAgB;AAC5C,UAAIjB,SAAS,CAACU,GAAV,CAAcO,IAAI,GAAG,OAArB,CAAJ,EAAmC;AACjC,aAAK,MAAMA,IAAX,EAAiBjB,SAAjB,EAA4BW,SAA5B,EAAuCE,MAAM,CAACK,aAA9C;AACD;AACF,KAJD,EAIG,IAJH;AAKA/B,IAAAA,OAAO,CAACgC,eAAR,CAAwBb,YAAxB,EAAsC,KAAKC,UAA3C,EAAuDP,SAAvD;AACAL,IAAAA,iBAAiB,CAACyB,SAAlB,CAA4B,IAA5B,EAAkC,QAAlC,EAA4CpB,SAA5C,EAAuDC,OAAvD,EAAgEC,GAAhE,EAAqEC,OAArE;AACD,GA/BqC;;AAiCtC;;;;;;AAMAkB,EAAAA,UAAU,EAAE,UAAUrB,SAAV,EAAqBW,SAArB,EAAgCO,aAAhC,EAA+C;AACzD,QAAII,IAAI,GAAGtB,SAAS,CAACsB,IAArB;;AAEA,QAAIA,IAAI,CAACC,KAAL,CAAWC,OAAX,EAAJ,EAA0B;AACxB;AACD;;AAED,QAAIC,cAAc,GAAGzB,SAAS,CAAC0B,QAAV,CAAmB,WAAnB,CAArB;AACA,QAAIC,cAAc,GAAGF,cAAc,CAACC,QAAf,CAAwB,WAAxB,CAArB;AACA,QAAIE,UAAU,GAAGD,cAAc,CAACjB,GAAf,CAAmB,OAAnB,CAAjB;AACA,QAAImB,YAAY,GAAGrC,WAAW,CAACiC,cAAD,EAAiBP,aAAjB,CAA9B;AACAU,IAAAA,UAAU,GAAG3C,MAAM,CAAC6C,OAAP,CAAeF,UAAf,IAA6BA,UAA7B,GAA0C,CAACA,UAAD,CAAvD;AACA,QAAIG,QAAQ,GAAGpB,SAAS,CAACqB,gBAAV,CAA2BC,OAA3B,EAAf;AACA,QAAIC,YAAY,GAAGZ,IAAI,CAACY,YAAL,EAAnB;AACA,QAAIC,SAAS,GAAG,CAAhB;AACA,QAAIC,WAAW,GAAGd,IAAI,CAACe,cAAL,EAAlB;AACA,QAAIC,KAAK,GAAGhB,IAAI,CAACC,KAAL,CAAWgB,QAAX,EAAZ;AACA,QAAIC,YAAY,GAAGxC,SAAS,CAACU,GAAV,CAAc,wBAAd,CAAnB;AACA,QAAI+B,YAAY,GAAGzC,SAAS,CAACU,GAAV,CAAc,wBAAd,CAAnB;AACA,QAAIgC,EAAE,GAAG,EAAT;AACA,QAAIC,EAAE,GAAG,EAAT,CApByD,CAoB5C;AACb;;AAEA,QAAIC,SAAS,GAAGjB,cAAc,CAACkB,YAAf,EAAhB;;AAEA,SAAK,IAAIC,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGV,WAAW,CAACW,MAAhC,EAAwCD,CAAC,EAAzC,EAA6C;AAC3C,UAAIvD,cAAc,CAAC+B,IAAD,EAAOwB,CAAP,EAAUjB,YAAV,EAAwBO,WAAW,CAACW,MAApC,EAA4CP,YAA5C,EAA0DC,YAA1D,CAAlB,EAA2F;AACzF;AACD;;AAED,UAAIO,SAAS,GAAG1B,IAAI,CAAC2B,aAAL,CAAmBb,WAAW,CAACU,CAAD,CAA9B,CAAhB;;AAEA,UAAIZ,YAAJ,EAAkB;AAChBQ,QAAAA,EAAE,CAAC,CAAD,CAAF,GAAQM,SAAR;AACAN,QAAAA,EAAE,CAAC,CAAD,CAAF,GAAQX,QAAQ,CAACmB,CAAjB;AACAP,QAAAA,EAAE,CAAC,CAAD,CAAF,GAAQK,SAAR;AACAL,QAAAA,EAAE,CAAC,CAAD,CAAF,GAAQZ,QAAQ,CAACmB,CAAT,GAAanB,QAAQ,CAACoB,MAA9B;AACD,OALD,MAKO;AACLT,QAAAA,EAAE,CAAC,CAAD,CAAF,GAAQX,QAAQ,CAACqB,CAAjB;AACAV,QAAAA,EAAE,CAAC,CAAD,CAAF,GAAQM,SAAR;AACAL,QAAAA,EAAE,CAAC,CAAD,CAAF,GAAQZ,QAAQ,CAACqB,CAAT,GAAarB,QAAQ,CAACsB,KAA9B;AACAV,QAAAA,EAAE,CAAC,CAAD,CAAF,GAAQK,SAAR;AACD;;AAED,UAAIM,UAAU,GAAGnB,SAAS,KAAKP,UAAU,CAACmB,MAA1C;;AAEA,WAAKxC,UAAL,CAAgBE,GAAhB,CAAoB,IAAItB,OAAO,CAACoE,IAAZ,CAAiBpE,OAAO,CAACqE,oBAAR,CAA6B;AAChEC,QAAAA,IAAI,EAAE,UAAUnB,KAAK,CAACQ,CAAD,CAD2C;AAEhEY,QAAAA,KAAK,EAAE;AACLC,UAAAA,EAAE,EAAEjB,EAAE,CAAC,CAAD,CADD;AAELkB,UAAAA,EAAE,EAAElB,EAAE,CAAC,CAAD,CAFD;AAGLmB,UAAAA,EAAE,EAAElB,EAAE,CAAC,CAAD,CAHD;AAILmB,UAAAA,EAAE,EAAEnB,EAAE,CAAC,CAAD;AAJD,SAFyD;AAQhEoB,QAAAA,KAAK,EAAE9E,MAAM,CAAC+E,QAAP,CAAgB;AACrBC,UAAAA,MAAM,EAAErC,UAAU,CAAC0B,UAAD;AADG,SAAhB,EAEJV,SAFI,CARyD;AAWhEsB,QAAAA,MAAM,EAAE;AAXwD,OAA7B,CAAjB,CAApB;AAaD;AACF,GAnGqC;;AAqGtC;;;;;;AAMAC,EAAAA,UAAU,EAAE,UAAUnE,SAAV,EAAqBW,SAArB,EAAgCO,aAAhC,EAA+C;AACzD,QAAII,IAAI,GAAGtB,SAAS,CAACsB,IAArB;;AAEA,QAAIA,IAAI,CAACC,KAAL,CAAWC,OAAX,EAAJ,EAA0B;AACxB;AACD;;AAED,QAAI4C,cAAc,GAAGpE,SAAS,CAAC0B,QAAV,CAAmB,WAAnB,CAArB;AACA,QAAI2C,cAAc,GAAGD,cAAc,CAAC1C,QAAf,CAAwB,WAAxB,CAArB;AACA,QAAI4C,UAAU,GAAGD,cAAc,CAAC3D,GAAf,CAAmB,OAAnB,CAAjB;AACA,QAAIqB,QAAQ,GAAGpB,SAAS,CAACqB,gBAAV,CAA2BC,OAA3B,EAAf;AACA,QAAIG,WAAW,GAAGd,IAAI,CAACe,cAAL,EAAlB;AACA,QAAIC,KAAK,GAAGhB,IAAI,CAACC,KAAL,CAAWgB,QAAX,EAAZ;AACA,QAAIgC,KAAK,GAAGjD,IAAI,CAAC2B,aAAL,CAAmBb,WAAW,CAAC,CAAD,CAA9B,CAAZ;AACA,QAAIoC,KAAK,GAAGlD,IAAI,CAAC2B,aAAL,CAAmBb,WAAW,CAAC,CAAD,CAA9B,CAAZ;AACA,QAAIqC,KAAK,GAAG,CAAZ;AACA,QAAIC,YAAY,GAAGlF,WAAW,CAAC4E,cAAD,EAAiBlD,aAAjB,CAA9B;AACA,QAAIyD,SAAS,GAAGN,cAAc,CAACO,YAAf,EAAhB;AACAN,IAAAA,UAAU,GAAGrF,MAAM,CAAC6C,OAAP,CAAewC,UAAf,IAA6BA,UAA7B,GAA0C,CAACA,UAAD,CAAvD;AACA,QAAI9B,YAAY,GAAGxC,SAAS,CAACU,GAAV,CAAc,wBAAd,CAAnB;AACA,QAAI+B,YAAY,GAAGzC,SAAS,CAACU,GAAV,CAAc,wBAAd,CAAnB;;AAEA,SAAK,IAAIoC,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGV,WAAW,CAACW,MAAhC,EAAwCD,CAAC,EAAzC,EAA6C;AAC3C,UAAIvD,cAAc,CAAC+B,IAAD,EAAOwB,CAAP,EAAU4B,YAAV,EAAwBtC,WAAW,CAACW,MAApC,EAA4CP,YAA5C,EAA0DC,YAA1D,CAAlB,EAA2F;AACzF;AACD;;AAED,UAAIO,SAAS,GAAG1B,IAAI,CAAC2B,aAAL,CAAmBb,WAAW,CAACU,CAAD,CAA9B,CAAhB;AACA,UAAIM,CAAJ;AACA,UAAIF,CAAJ;AACA,UAAIG,KAAJ;AACA,UAAIF,MAAJ;;AAEA,UAAI7B,IAAI,CAACY,YAAL,EAAJ,EAAyB;AACvBkB,QAAAA,CAAC,GAAGmB,KAAJ;AACArB,QAAAA,CAAC,GAAGnB,QAAQ,CAACmB,CAAb;AACAG,QAAAA,KAAK,GAAGL,SAAS,GAAGI,CAApB;AACAD,QAAAA,MAAM,GAAGpB,QAAQ,CAACoB,MAAlB;AACD,OALD,MAKO;AACLC,QAAAA,CAAC,GAAGrB,QAAQ,CAACqB,CAAb;AACAF,QAAAA,CAAC,GAAGsB,KAAJ;AACAnB,QAAAA,KAAK,GAAGtB,QAAQ,CAACsB,KAAjB;AACAF,QAAAA,MAAM,GAAGH,SAAS,GAAGE,CAArB;AACD;;AAED,UAAII,UAAU,GAAGmB,KAAK,KAAKH,UAAU,CAACvB,MAAtC;;AAEA,WAAKxC,UAAL,CAAgBE,GAAhB,CAAoB,IAAItB,OAAO,CAAC0F,IAAZ,CAAiB;AACnCpB,QAAAA,IAAI,EAAE,UAAUnB,KAAK,CAACQ,CAAD,CADc;AAEnCY,QAAAA,KAAK,EAAE;AACLN,UAAAA,CAAC,EAAEA,CADE;AAELF,UAAAA,CAAC,EAAEA,CAFE;AAGLG,UAAAA,KAAK,EAAEA,KAHF;AAILF,UAAAA,MAAM,EAAEA;AAJH,SAF4B;AAQnCY,QAAAA,KAAK,EAAE9E,MAAM,CAAC+E,QAAP,CAAgB;AACrBc,UAAAA,IAAI,EAAER,UAAU,CAAChB,UAAD;AADK,SAAhB,EAEJqB,SAFI,CAR4B;AAWnCT,QAAAA,MAAM,EAAE;AAX2B,OAAjB,CAApB;;AAcAK,MAAAA,KAAK,GAAGnB,CAAC,GAAGC,KAAZ;AACAmB,MAAAA,KAAK,GAAGtB,CAAC,GAAGC,MAAZ;AACD;AACF;AA3KqC,CAAhB,CAAxB;AA6KAxD,iBAAiB,CAACC,MAAlB,CAAyB;AACvBC,EAAAA,IAAI,EAAE;AADiB,CAAzB;AAGAF,iBAAiB,CAACC,MAAlB,CAAyB;AACvBC,EAAAA,IAAI,EAAE;AADiB,CAAzB","sourcesContent":["var zrUtil = require(\"zrender/lib/core/util\");\n\nvar graphic = require(\"../../util/graphic\");\n\nvar AxisBuilder = require(\"./AxisBuilder\");\n\nvar AxisView = require(\"./AxisView\");\n\nvar cartesianAxisHelper = require(\"./cartesianAxisHelper\");\n\nvar ifIgnoreOnTick = AxisBuilder.ifIgnoreOnTick;\nvar getInterval = AxisBuilder.getInterval;\nvar axisBuilderAttrs = ['axisLine', 'axisTickLabel', 'axisName'];\nvar selfBuilderAttrs = ['splitArea', 'splitLine']; // function getAlignWithLabel(model, axisModel) {\n//     var alignWithLabel = model.get('alignWithLabel');\n//     if (alignWithLabel === 'auto') {\n//         alignWithLabel = axisModel.get('axisTick.alignWithLabel');\n//     }\n//     return alignWithLabel;\n// }\n\nvar CartesianAxisView = AxisView.extend({\n  type: 'cartesianAxis',\n  axisPointerClass: 'CartesianAxisPointer',\n\n  /**\n   * @override\n   */\n  render: function (axisModel, ecModel, api, payload) {\n    this.group.removeAll();\n    var oldAxisGroup = this._axisGroup;\n    this._axisGroup = new graphic.Group();\n    this.group.add(this._axisGroup);\n\n    if (!axisModel.get('show')) {\n      return;\n    }\n\n    var gridModel = axisModel.getCoordSysModel();\n    var layout = cartesianAxisHelper.layout(gridModel, axisModel);\n    var axisBuilder = new AxisBuilder(axisModel, layout);\n    zrUtil.each(axisBuilderAttrs, axisBuilder.add, axisBuilder);\n\n    this._axisGroup.add(axisBuilder.getGroup());\n\n    zrUtil.each(selfBuilderAttrs, function (name) {\n      if (axisModel.get(name + '.show')) {\n        this['_' + name](axisModel, gridModel, layout.labelInterval);\n      }\n    }, this);\n    graphic.groupTransition(oldAxisGroup, this._axisGroup, axisModel);\n    CartesianAxisView.superCall(this, 'render', axisModel, ecModel, api, payload);\n  },\n\n  /**\n   * @param {module:echarts/coord/cartesian/AxisModel} axisModel\n   * @param {module:echarts/coord/cartesian/GridModel} gridModel\n   * @param {number|Function} labelInterval\n   * @private\n   */\n  _splitLine: function (axisModel, gridModel, labelInterval) {\n    var axis = axisModel.axis;\n\n    if (axis.scale.isBlank()) {\n      return;\n    }\n\n    var splitLineModel = axisModel.getModel('splitLine');\n    var lineStyleModel = splitLineModel.getModel('lineStyle');\n    var lineColors = lineStyleModel.get('color');\n    var lineInterval = getInterval(splitLineModel, labelInterval);\n    lineColors = zrUtil.isArray(lineColors) ? lineColors : [lineColors];\n    var gridRect = gridModel.coordinateSystem.getRect();\n    var isHorizontal = axis.isHorizontal();\n    var lineCount = 0;\n    var ticksCoords = axis.getTicksCoords();\n    var ticks = axis.scale.getTicks();\n    var showMinLabel = axisModel.get('axisLabel.showMinLabel');\n    var showMaxLabel = axisModel.get('axisLabel.showMaxLabel');\n    var p1 = [];\n    var p2 = []; // Simple optimization\n    // Batching the lines if color are the same\n\n    var lineStyle = lineStyleModel.getLineStyle();\n\n    for (var i = 0; i < ticksCoords.length; i++) {\n      if (ifIgnoreOnTick(axis, i, lineInterval, ticksCoords.length, showMinLabel, showMaxLabel)) {\n        continue;\n      }\n\n      var tickCoord = axis.toGlobalCoord(ticksCoords[i]);\n\n      if (isHorizontal) {\n        p1[0] = tickCoord;\n        p1[1] = gridRect.y;\n        p2[0] = tickCoord;\n        p2[1] = gridRect.y + gridRect.height;\n      } else {\n        p1[0] = gridRect.x;\n        p1[1] = tickCoord;\n        p2[0] = gridRect.x + gridRect.width;\n        p2[1] = tickCoord;\n      }\n\n      var colorIndex = lineCount++ % lineColors.length;\n\n      this._axisGroup.add(new graphic.Line(graphic.subPixelOptimizeLine({\n        anid: 'line_' + ticks[i],\n        shape: {\n          x1: p1[0],\n          y1: p1[1],\n          x2: p2[0],\n          y2: p2[1]\n        },\n        style: zrUtil.defaults({\n          stroke: lineColors[colorIndex]\n        }, lineStyle),\n        silent: true\n      })));\n    }\n  },\n\n  /**\n   * @param {module:echarts/coord/cartesian/AxisModel} axisModel\n   * @param {module:echarts/coord/cartesian/GridModel} gridModel\n   * @param {number|Function} labelInterval\n   * @private\n   */\n  _splitArea: function (axisModel, gridModel, labelInterval) {\n    var axis = axisModel.axis;\n\n    if (axis.scale.isBlank()) {\n      return;\n    }\n\n    var splitAreaModel = axisModel.getModel('splitArea');\n    var areaStyleModel = splitAreaModel.getModel('areaStyle');\n    var areaColors = areaStyleModel.get('color');\n    var gridRect = gridModel.coordinateSystem.getRect();\n    var ticksCoords = axis.getTicksCoords();\n    var ticks = axis.scale.getTicks();\n    var prevX = axis.toGlobalCoord(ticksCoords[0]);\n    var prevY = axis.toGlobalCoord(ticksCoords[0]);\n    var count = 0;\n    var areaInterval = getInterval(splitAreaModel, labelInterval);\n    var areaStyle = areaStyleModel.getAreaStyle();\n    areaColors = zrUtil.isArray(areaColors) ? areaColors : [areaColors];\n    var showMinLabel = axisModel.get('axisLabel.showMinLabel');\n    var showMaxLabel = axisModel.get('axisLabel.showMaxLabel');\n\n    for (var i = 1; i < ticksCoords.length; i++) {\n      if (ifIgnoreOnTick(axis, i, areaInterval, ticksCoords.length, showMinLabel, showMaxLabel)) {\n        continue;\n      }\n\n      var tickCoord = axis.toGlobalCoord(ticksCoords[i]);\n      var x;\n      var y;\n      var width;\n      var height;\n\n      if (axis.isHorizontal()) {\n        x = prevX;\n        y = gridRect.y;\n        width = tickCoord - x;\n        height = gridRect.height;\n      } else {\n        x = gridRect.x;\n        y = prevY;\n        width = gridRect.width;\n        height = tickCoord - y;\n      }\n\n      var colorIndex = count++ % areaColors.length;\n\n      this._axisGroup.add(new graphic.Rect({\n        anid: 'area_' + ticks[i],\n        shape: {\n          x: x,\n          y: y,\n          width: width,\n          height: height\n        },\n        style: zrUtil.defaults({\n          fill: areaColors[colorIndex]\n        }, areaStyle),\n        silent: true\n      }));\n\n      prevX = x + width;\n      prevY = y + height;\n    }\n  }\n});\nCartesianAxisView.extend({\n  type: 'xAxis'\n});\nCartesianAxisView.extend({\n  type: 'yAxis'\n});"]},"metadata":{},"sourceType":"script"}