{"ast":null,"code":"var BoundingRect = require(\"../core/BoundingRect\");\n\nvar imageHelper = require(\"../graphic/helper/image\");\n\nvar _util = require(\"../core/util\");\n\nvar getContext = _util.getContext;\nvar extend = _util.extend;\nvar retrieve2 = _util.retrieve2;\nvar retrieve3 = _util.retrieve3;\nvar textWidthCache = {};\nvar textWidthCacheCounter = 0;\nvar TEXT_CACHE_MAX = 5000;\nvar STYLE_REG = /\\{([a-zA-Z0-9_]+)\\|([^}]*)\\}/g;\nvar DEFAULT_FONT = '12px sans-serif'; // Avoid assign to an exported variable, for transforming to cjs.\n\nvar methods = {};\n\nfunction $override(name, fn) {\n  methods[name] = fn;\n}\n/**\n * @public\n * @param {string} text\n * @param {string} font\n * @return {number} width\n */\n\n\nfunction getWidth(text, font) {\n  font = font || DEFAULT_FONT;\n  var key = text + ':' + font;\n\n  if (textWidthCache[key]) {\n    return textWidthCache[key];\n  }\n\n  var textLines = (text + '').split('\\n');\n  var width = 0;\n\n  for (var i = 0, l = textLines.length; i < l; i++) {\n    // textContain.measureText may be overrided in SVG or VML\n    width = Math.max(measureText(textLines[i], font).width, width);\n  }\n\n  if (textWidthCacheCounter > TEXT_CACHE_MAX) {\n    textWidthCacheCounter = 0;\n    textWidthCache = {};\n  }\n\n  textWidthCacheCounter++;\n  textWidthCache[key] = width;\n  return width;\n}\n/**\n * @public\n * @param {string} text\n * @param {string} font\n * @param {string} [textAlign='left']\n * @param {string} [textVerticalAlign='top']\n * @param {Array.<number>} [textPadding]\n * @param {Object} [rich]\n * @param {Object} [truncate]\n * @return {Object} {x, y, width, height, lineHeight}\n */\n\n\nfunction getBoundingRect(text, font, textAlign, textVerticalAlign, textPadding, rich, truncate) {\n  return rich ? getRichTextRect(text, font, textAlign, textVerticalAlign, textPadding, rich, truncate) : getPlainTextRect(text, font, textAlign, textVerticalAlign, textPadding, truncate);\n}\n\nfunction getPlainTextRect(text, font, textAlign, textVerticalAlign, textPadding, truncate) {\n  var contentBlock = parsePlainText(text, font, textPadding, truncate);\n  var outerWidth = getWidth(text, font);\n\n  if (textPadding) {\n    outerWidth += textPadding[1] + textPadding[3];\n  }\n\n  var outerHeight = contentBlock.outerHeight;\n  var x = adjustTextX(0, outerWidth, textAlign);\n  var y = adjustTextY(0, outerHeight, textVerticalAlign);\n  var rect = new BoundingRect(x, y, outerWidth, outerHeight);\n  rect.lineHeight = contentBlock.lineHeight;\n  return rect;\n}\n\nfunction getRichTextRect(text, font, textAlign, textVerticalAlign, textPadding, rich, truncate) {\n  var contentBlock = parseRichText(text, {\n    rich: rich,\n    truncate: truncate,\n    font: font,\n    textAlign: textAlign,\n    textPadding: textPadding\n  });\n  var outerWidth = contentBlock.outerWidth;\n  var outerHeight = contentBlock.outerHeight;\n  var x = adjustTextX(0, outerWidth, textAlign);\n  var y = adjustTextY(0, outerHeight, textVerticalAlign);\n  return new BoundingRect(x, y, outerWidth, outerHeight);\n}\n/**\n * @public\n * @param {number} x\n * @param {number} width\n * @param {string} [textAlign='left']\n * @return {number} Adjusted x.\n */\n\n\nfunction adjustTextX(x, width, textAlign) {\n  // FIXME Right to left language\n  if (textAlign === 'right') {\n    x -= width;\n  } else if (textAlign === 'center') {\n    x -= width / 2;\n  }\n\n  return x;\n}\n/**\n * @public\n * @param {number} y\n * @param {number} height\n * @param {string} [textVerticalAlign='top']\n * @return {number} Adjusted y.\n */\n\n\nfunction adjustTextY(y, height, textVerticalAlign) {\n  if (textVerticalAlign === 'middle') {\n    y -= height / 2;\n  } else if (textVerticalAlign === 'bottom') {\n    y -= height;\n  }\n\n  return y;\n}\n/**\n * @public\n * @param {stirng} textPosition\n * @param {Object} rect {x, y, width, height}\n * @param {number} distance\n * @return {Object} {x, y, textAlign, textVerticalAlign}\n */\n\n\nfunction adjustTextPositionOnRect(textPosition, rect, distance) {\n  var x = rect.x;\n  var y = rect.y;\n  var height = rect.height;\n  var width = rect.width;\n  var halfHeight = height / 2;\n  var textAlign = 'left';\n  var textVerticalAlign = 'top';\n\n  switch (textPosition) {\n    case 'left':\n      x -= distance;\n      y += halfHeight;\n      textAlign = 'right';\n      textVerticalAlign = 'middle';\n      break;\n\n    case 'right':\n      x += distance + width;\n      y += halfHeight;\n      textVerticalAlign = 'middle';\n      break;\n\n    case 'top':\n      x += width / 2;\n      y -= distance;\n      textAlign = 'center';\n      textVerticalAlign = 'bottom';\n      break;\n\n    case 'bottom':\n      x += width / 2;\n      y += height + distance;\n      textAlign = 'center';\n      break;\n\n    case 'inside':\n      x += width / 2;\n      y += halfHeight;\n      textAlign = 'center';\n      textVerticalAlign = 'middle';\n      break;\n\n    case 'insideLeft':\n      x += distance;\n      y += halfHeight;\n      textVerticalAlign = 'middle';\n      break;\n\n    case 'insideRight':\n      x += width - distance;\n      y += halfHeight;\n      textAlign = 'right';\n      textVerticalAlign = 'middle';\n      break;\n\n    case 'insideTop':\n      x += width / 2;\n      y += distance;\n      textAlign = 'center';\n      break;\n\n    case 'insideBottom':\n      x += width / 2;\n      y += height - distance;\n      textAlign = 'center';\n      textVerticalAlign = 'bottom';\n      break;\n\n    case 'insideTopLeft':\n      x += distance;\n      y += distance;\n      break;\n\n    case 'insideTopRight':\n      x += width - distance;\n      y += distance;\n      textAlign = 'right';\n      break;\n\n    case 'insideBottomLeft':\n      x += distance;\n      y += height - distance;\n      textVerticalAlign = 'bottom';\n      break;\n\n    case 'insideBottomRight':\n      x += width - distance;\n      y += height - distance;\n      textAlign = 'right';\n      textVerticalAlign = 'bottom';\n      break;\n  }\n\n  return {\n    x: x,\n    y: y,\n    textAlign: textAlign,\n    textVerticalAlign: textVerticalAlign\n  };\n}\n/**\n * Show ellipsis if overflow.\n *\n * @public\n * @param  {string} text\n * @param  {string} containerWidth\n * @param  {string} font\n * @param  {number} [ellipsis='...']\n * @param  {Object} [options]\n * @param  {number} [options.maxIterations=3]\n * @param  {number} [options.minChar=0] If truncate result are less\n *                  then minChar, ellipsis will not show, which is\n *                  better for user hint in some cases.\n * @param  {number} [options.placeholder=''] When all truncated, use the placeholder.\n * @return {string}\n */\n\n\nfunction truncateText(text, containerWidth, font, ellipsis, options) {\n  if (!containerWidth) {\n    return '';\n  }\n\n  var textLines = (text + '').split('\\n');\n  options = prepareTruncateOptions(containerWidth, font, ellipsis, options); // FIXME\n  // It is not appropriate that every line has '...' when truncate multiple lines.\n\n  for (var i = 0, len = textLines.length; i < len; i++) {\n    textLines[i] = truncateSingleLine(textLines[i], options);\n  }\n\n  return textLines.join('\\n');\n}\n\nfunction prepareTruncateOptions(containerWidth, font, ellipsis, options) {\n  options = extend({}, options);\n  options.font = font;\n  var ellipsis = retrieve2(ellipsis, '...');\n  options.maxIterations = retrieve2(options.maxIterations, 2);\n  var minChar = options.minChar = retrieve2(options.minChar, 0); // FIXME\n  // Other languages?\n\n  options.cnCharWidth = getWidth('国', font); // FIXME\n  // Consider proportional font?\n\n  var ascCharWidth = options.ascCharWidth = getWidth('a', font);\n  options.placeholder = retrieve2(options.placeholder, ''); // Example 1: minChar: 3, text: 'asdfzxcv', truncate result: 'asdf', but not: 'a...'.\n  // Example 2: minChar: 3, text: '维度', truncate result: '维', but not: '...'.\n\n  var contentWidth = containerWidth = Math.max(0, containerWidth - 1); // Reserve some gap.\n\n  for (var i = 0; i < minChar && contentWidth >= ascCharWidth; i++) {\n    contentWidth -= ascCharWidth;\n  }\n\n  var ellipsisWidth = getWidth(ellipsis);\n\n  if (ellipsisWidth > contentWidth) {\n    ellipsis = '';\n    ellipsisWidth = 0;\n  }\n\n  contentWidth = containerWidth - ellipsisWidth;\n  options.ellipsis = ellipsis;\n  options.ellipsisWidth = ellipsisWidth;\n  options.contentWidth = contentWidth;\n  options.containerWidth = containerWidth;\n  return options;\n}\n\nfunction truncateSingleLine(textLine, options) {\n  var containerWidth = options.containerWidth;\n  var font = options.font;\n  var contentWidth = options.contentWidth;\n\n  if (!containerWidth) {\n    return '';\n  }\n\n  var lineWidth = getWidth(textLine, font);\n\n  if (lineWidth <= containerWidth) {\n    return textLine;\n  }\n\n  for (var j = 0;; j++) {\n    if (lineWidth <= contentWidth || j >= options.maxIterations) {\n      textLine += options.ellipsis;\n      break;\n    }\n\n    var subLength = j === 0 ? estimateLength(textLine, contentWidth, options.ascCharWidth, options.cnCharWidth) : lineWidth > 0 ? Math.floor(textLine.length * contentWidth / lineWidth) : 0;\n    textLine = textLine.substr(0, subLength);\n    lineWidth = getWidth(textLine, font);\n  }\n\n  if (textLine === '') {\n    textLine = options.placeholder;\n  }\n\n  return textLine;\n}\n\nfunction estimateLength(text, contentWidth, ascCharWidth, cnCharWidth) {\n  var width = 0;\n  var i = 0;\n\n  for (var len = text.length; i < len && width < contentWidth; i++) {\n    var charCode = text.charCodeAt(i);\n    width += 0 <= charCode && charCode <= 127 ? ascCharWidth : cnCharWidth;\n  }\n\n  return i;\n}\n/**\n * @public\n * @param {string} font\n * @return {number} line height\n */\n\n\nfunction getLineHeight(font) {\n  // FIXME A rough approach.\n  return getWidth('国', font);\n}\n/**\n * @public\n * @param {string} text\n * @param {string} font\n * @return {Object} width\n */\n\n\nfunction measureText(text, font) {\n  return methods.measureText(text, font);\n} // Avoid assign to an exported variable, for transforming to cjs.\n\n\nmethods.measureText = function (text, font) {\n  var ctx = getContext();\n  ctx.font = font || DEFAULT_FONT;\n  return ctx.measureText(text);\n};\n/**\n * @public\n * @param {string} text\n * @param {string} font\n * @param {Object} [truncate]\n * @return {Object} block: {lineHeight, lines, height, outerHeight}\n *  Notice: for performance, do not calculate outerWidth util needed.\n */\n\n\nfunction parsePlainText(text, font, padding, truncate) {\n  text != null && (text += '');\n  var lineHeight = getLineHeight(font);\n  var lines = text ? text.split('\\n') : [];\n  var height = lines.length * lineHeight;\n  var outerHeight = height;\n\n  if (padding) {\n    outerHeight += padding[0] + padding[2];\n  }\n\n  if (text && truncate) {\n    var truncOuterHeight = truncate.outerHeight;\n    var truncOuterWidth = truncate.outerWidth;\n\n    if (truncOuterHeight != null && outerHeight > truncOuterHeight) {\n      text = '';\n      lines = [];\n    } else if (truncOuterWidth != null) {\n      var options = prepareTruncateOptions(truncOuterWidth - (padding ? padding[1] + padding[3] : 0), font, truncate.ellipsis, {\n        minChar: truncate.minChar,\n        placeholder: truncate.placeholder\n      }); // FIXME\n      // It is not appropriate that every line has '...' when truncate multiple lines.\n\n      for (var i = 0, len = lines.length; i < len; i++) {\n        lines[i] = truncateSingleLine(lines[i], options);\n      }\n    }\n  }\n\n  return {\n    lines: lines,\n    height: height,\n    outerHeight: outerHeight,\n    lineHeight: lineHeight\n  };\n}\n/**\n * For example: 'some text {a|some text}other text{b|some text}xxx{c|}xxx'\n * Also consider 'bbbb{a|xxx\\nzzz}xxxx\\naaaa'.\n *\n * @public\n * @param {string} text\n * @param {Object} style\n * @return {Object} block\n * {\n *      width,\n *      height,\n *      lines: [{\n *          lineHeight,\n *          width,\n *          tokens: [[{\n *              styleName,\n *              text,\n *              width,      // include textPadding\n *              height,     // include textPadding\n *              textWidth, // pure text width\n *              textHeight, // pure text height\n *              lineHeihgt,\n *              font,\n *              textAlign,\n *              textVerticalAlign\n *          }], [...], ...]\n *      }, ...]\n * }\n * If styleName is undefined, it is plain text.\n */\n\n\nfunction parseRichText(text, style) {\n  var contentBlock = {\n    lines: [],\n    width: 0,\n    height: 0\n  };\n  text != null && (text += '');\n\n  if (!text) {\n    return contentBlock;\n  }\n\n  var lastIndex = STYLE_REG.lastIndex = 0;\n  var result;\n\n  while ((result = STYLE_REG.exec(text)) != null) {\n    var matchedIndex = result.index;\n\n    if (matchedIndex > lastIndex) {\n      pushTokens(contentBlock, text.substring(lastIndex, matchedIndex));\n    }\n\n    pushTokens(contentBlock, result[2], result[1]);\n    lastIndex = STYLE_REG.lastIndex;\n  }\n\n  if (lastIndex < text.length) {\n    pushTokens(contentBlock, text.substring(lastIndex, text.length));\n  }\n\n  var lines = contentBlock.lines;\n  var contentHeight = 0;\n  var contentWidth = 0; // For `textWidth: 100%`\n\n  var pendingList = [];\n  var stlPadding = style.textPadding;\n  var truncate = style.truncate;\n  var truncateWidth = truncate && truncate.outerWidth;\n  var truncateHeight = truncate && truncate.outerHeight;\n\n  if (stlPadding) {\n    truncateWidth != null && (truncateWidth -= stlPadding[1] + stlPadding[3]);\n    truncateHeight != null && (truncateHeight -= stlPadding[0] + stlPadding[2]);\n  } // Calculate layout info of tokens.\n\n\n  for (var i = 0; i < lines.length; i++) {\n    var line = lines[i];\n    var lineHeight = 0;\n    var lineWidth = 0;\n\n    for (var j = 0; j < line.tokens.length; j++) {\n      var token = line.tokens[j];\n      var tokenStyle = token.styleName && style.rich[token.styleName] || {}; // textPadding should not inherit from style.\n\n      var textPadding = token.textPadding = tokenStyle.textPadding; // textFont has been asigned to font by `normalizeStyle`.\n\n      var font = token.font = tokenStyle.font || style.font; // textHeight can be used when textVerticalAlign is specified in token.\n\n      var tokenHeight = token.textHeight = retrieve2( // textHeight should not be inherited, consider it can be specified\n      // as box height of the block.\n      tokenStyle.textHeight, getLineHeight(font));\n      textPadding && (tokenHeight += textPadding[0] + textPadding[2]);\n      token.height = tokenHeight;\n      token.lineHeight = retrieve3(tokenStyle.textLineHeight, style.textLineHeight, tokenHeight);\n      token.textAlign = tokenStyle && tokenStyle.textAlign || style.textAlign;\n      token.textVerticalAlign = tokenStyle && tokenStyle.textVerticalAlign || 'middle';\n\n      if (truncateHeight != null && contentHeight + token.lineHeight > truncateHeight) {\n        return {\n          lines: [],\n          width: 0,\n          height: 0\n        };\n      }\n\n      token.textWidth = getWidth(token.text, font);\n      var tokenWidth = tokenStyle.textWidth;\n      var tokenWidthNotSpecified = tokenWidth == null || tokenWidth === 'auto'; // Percent width, can be `100%`, can be used in drawing separate\n      // line when box width is needed to be auto.\n\n      if (typeof tokenWidth === 'string' && tokenWidth.charAt(tokenWidth.length - 1) === '%') {\n        token.percentWidth = tokenWidth;\n        pendingList.push(token);\n        tokenWidth = 0; // Do not truncate in this case, because there is no user case\n        // and it is too complicated.\n      } else {\n        if (tokenWidthNotSpecified) {\n          tokenWidth = token.textWidth; // FIXME: If image is not loaded and textWidth is not specified, calling\n          // `getBoundingRect()` will not get correct result.\n\n          var textBackgroundColor = tokenStyle.textBackgroundColor;\n          var bgImg = textBackgroundColor && textBackgroundColor.image; // Use cases:\n          // (1) If image is not loaded, it will be loaded at render phase and call\n          // `dirty()` and `textBackgroundColor.image` will be replaced with the loaded\n          // image, and then the right size will be calculated here at the next tick.\n          // See `graphic/helper/text.js`.\n          // (2) If image loaded, and `textBackgroundColor.image` is image src string,\n          // use `imageHelper.findExistImage` to find cached image.\n          // `imageHelper.findExistImage` will always be called here before\n          // `imageHelper.createOrUpdateImage` in `graphic/helper/text.js#renderRichText`\n          // which ensures that image will not be rendered before correct size calcualted.\n\n          if (bgImg) {\n            bgImg = imageHelper.findExistImage(bgImg);\n\n            if (imageHelper.isImageReady(bgImg)) {\n              tokenWidth = Math.max(tokenWidth, bgImg.width * tokenHeight / bgImg.height);\n            }\n          }\n        }\n\n        var paddingW = textPadding ? textPadding[1] + textPadding[3] : 0;\n        tokenWidth += paddingW;\n        var remianTruncWidth = truncateWidth != null ? truncateWidth - lineWidth : null;\n\n        if (remianTruncWidth != null && remianTruncWidth < tokenWidth) {\n          if (!tokenWidthNotSpecified || remianTruncWidth < paddingW) {\n            token.text = '';\n            token.textWidth = tokenWidth = 0;\n          } else {\n            token.text = truncateText(token.text, remianTruncWidth - paddingW, font, truncate.ellipsis, {\n              minChar: truncate.minChar\n            });\n            token.textWidth = getWidth(token.text, font);\n            tokenWidth = token.textWidth + paddingW;\n          }\n        }\n      }\n\n      lineWidth += token.width = tokenWidth;\n      tokenStyle && (lineHeight = Math.max(lineHeight, token.lineHeight));\n    }\n\n    line.width = lineWidth;\n    line.lineHeight = lineHeight;\n    contentHeight += lineHeight;\n    contentWidth = Math.max(contentWidth, lineWidth);\n  }\n\n  contentBlock.outerWidth = contentBlock.width = retrieve2(style.textWidth, contentWidth);\n  contentBlock.outerHeight = contentBlock.height = retrieve2(style.textHeight, contentHeight);\n\n  if (stlPadding) {\n    contentBlock.outerWidth += stlPadding[1] + stlPadding[3];\n    contentBlock.outerHeight += stlPadding[0] + stlPadding[2];\n  }\n\n  for (var i = 0; i < pendingList.length; i++) {\n    var token = pendingList[i];\n    var percentWidth = token.percentWidth; // Should not base on outerWidth, because token can not be placed out of padding.\n\n    token.width = parseInt(percentWidth, 10) / 100 * contentWidth;\n  }\n\n  return contentBlock;\n}\n\nfunction pushTokens(block, str, styleName) {\n  var isEmptyStr = str === '';\n  var strs = str.split('\\n');\n  var lines = block.lines;\n\n  for (var i = 0; i < strs.length; i++) {\n    var text = strs[i];\n    var token = {\n      styleName: styleName,\n      text: text,\n      isLineHolder: !text && !isEmptyStr\n    }; // The first token should be appended to the last line.\n\n    if (!i) {\n      var tokens = (lines[lines.length - 1] || (lines[0] = {\n        tokens: []\n      })).tokens; // Consider cases:\n      // (1) ''.split('\\n') => ['', '\\n', ''], the '' at the first item\n      // (which is a placeholder) should be replaced by new token.\n      // (2) A image backage, where token likes {a|}.\n      // (3) A redundant '' will affect textAlign in line.\n      // (4) tokens with the same tplName should not be merged, because\n      // they should be displayed in different box (with border and padding).\n\n      var tokensLen = tokens.length;\n      tokensLen === 1 && tokens[0].isLineHolder ? tokens[0] = token : // Consider text is '', only insert when it is the \"lineHolder\" or\n      // \"emptyStr\". Otherwise a redundant '' will affect textAlign in line.\n      (text || !tokensLen || isEmptyStr) && tokens.push(token);\n    } // Other tokens always start a new line.\n    else {\n        // If there is '', insert it as a placeholder.\n        lines.push({\n          tokens: [token]\n        });\n      }\n  }\n}\n\nfunction makeFont(style) {\n  // FIXME in node-canvas fontWeight is before fontStyle\n  // Use `fontSize` `fontFamily` to check whether font properties are defined.\n  return (style.fontSize || style.fontFamily) && [style.fontStyle, style.fontWeight, (style.fontSize || 12) + 'px', // If font properties are defined, `fontFamily` should not be ignored.\n  style.fontFamily || 'sans-serif'].join(' ') || style.textFont || style.font;\n}\n\nexports.DEFAULT_FONT = DEFAULT_FONT;\nexports.$override = $override;\nexports.getWidth = getWidth;\nexports.getBoundingRect = getBoundingRect;\nexports.adjustTextX = adjustTextX;\nexports.adjustTextY = adjustTextY;\nexports.adjustTextPositionOnRect = adjustTextPositionOnRect;\nexports.truncateText = truncateText;\nexports.getLineHeight = getLineHeight;\nexports.measureText = measureText;\nexports.parsePlainText = parsePlainText;\nexports.parseRichText = parseRichText;\nexports.makeFont = makeFont;","map":{"version":3,"sources":["/home/martin/Escritorio/Taller de Integracion/Tarea3-TallerDeIntegracion/node_modules/react-echarts/node_modules/zrender/lib/contain/text.js"],"names":["BoundingRect","require","imageHelper","_util","getContext","extend","retrieve2","retrieve3","textWidthCache","textWidthCacheCounter","TEXT_CACHE_MAX","STYLE_REG","DEFAULT_FONT","methods","$override","name","fn","getWidth","text","font","key","textLines","split","width","i","l","length","Math","max","measureText","getBoundingRect","textAlign","textVerticalAlign","textPadding","rich","truncate","getRichTextRect","getPlainTextRect","contentBlock","parsePlainText","outerWidth","outerHeight","x","adjustTextX","y","adjustTextY","rect","lineHeight","parseRichText","height","adjustTextPositionOnRect","textPosition","distance","halfHeight","truncateText","containerWidth","ellipsis","options","prepareTruncateOptions","len","truncateSingleLine","join","maxIterations","minChar","cnCharWidth","ascCharWidth","placeholder","contentWidth","ellipsisWidth","textLine","lineWidth","j","subLength","estimateLength","floor","substr","charCode","charCodeAt","getLineHeight","ctx","padding","lines","truncOuterHeight","truncOuterWidth","style","lastIndex","result","exec","matchedIndex","index","pushTokens","substring","contentHeight","pendingList","stlPadding","truncateWidth","truncateHeight","line","tokens","token","tokenStyle","styleName","tokenHeight","textHeight","textLineHeight","textWidth","tokenWidth","tokenWidthNotSpecified","charAt","percentWidth","push","textBackgroundColor","bgImg","image","findExistImage","isImageReady","paddingW","remianTruncWidth","parseInt","block","str","isEmptyStr","strs","isLineHolder","tokensLen","makeFont","fontSize","fontFamily","fontStyle","fontWeight","textFont","exports"],"mappings":"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","sourcesContent":["var BoundingRect = require(\"../core/BoundingRect\");\n\nvar imageHelper = require(\"../graphic/helper/image\");\n\nvar _util = require(\"../core/util\");\n\nvar getContext = _util.getContext;\nvar extend = _util.extend;\nvar retrieve2 = _util.retrieve2;\nvar retrieve3 = _util.retrieve3;\nvar textWidthCache = {};\nvar textWidthCacheCounter = 0;\nvar TEXT_CACHE_MAX = 5000;\nvar STYLE_REG = /\\{([a-zA-Z0-9_]+)\\|([^}]*)\\}/g;\nvar DEFAULT_FONT = '12px sans-serif'; // Avoid assign to an exported variable, for transforming to cjs.\n\nvar methods = {};\n\nfunction $override(name, fn) {\n  methods[name] = fn;\n}\n/**\n * @public\n * @param {string} text\n * @param {string} font\n * @return {number} width\n */\n\n\nfunction getWidth(text, font) {\n  font = font || DEFAULT_FONT;\n  var key = text + ':' + font;\n\n  if (textWidthCache[key]) {\n    return textWidthCache[key];\n  }\n\n  var textLines = (text + '').split('\\n');\n  var width = 0;\n\n  for (var i = 0, l = textLines.length; i < l; i++) {\n    // textContain.measureText may be overrided in SVG or VML\n    width = Math.max(measureText(textLines[i], font).width, width);\n  }\n\n  if (textWidthCacheCounter > TEXT_CACHE_MAX) {\n    textWidthCacheCounter = 0;\n    textWidthCache = {};\n  }\n\n  textWidthCacheCounter++;\n  textWidthCache[key] = width;\n  return width;\n}\n/**\n * @public\n * @param {string} text\n * @param {string} font\n * @param {string} [textAlign='left']\n * @param {string} [textVerticalAlign='top']\n * @param {Array.<number>} [textPadding]\n * @param {Object} [rich]\n * @param {Object} [truncate]\n * @return {Object} {x, y, width, height, lineHeight}\n */\n\n\nfunction getBoundingRect(text, font, textAlign, textVerticalAlign, textPadding, rich, truncate) {\n  return rich ? getRichTextRect(text, font, textAlign, textVerticalAlign, textPadding, rich, truncate) : getPlainTextRect(text, font, textAlign, textVerticalAlign, textPadding, truncate);\n}\n\nfunction getPlainTextRect(text, font, textAlign, textVerticalAlign, textPadding, truncate) {\n  var contentBlock = parsePlainText(text, font, textPadding, truncate);\n  var outerWidth = getWidth(text, font);\n\n  if (textPadding) {\n    outerWidth += textPadding[1] + textPadding[3];\n  }\n\n  var outerHeight = contentBlock.outerHeight;\n  var x = adjustTextX(0, outerWidth, textAlign);\n  var y = adjustTextY(0, outerHeight, textVerticalAlign);\n  var rect = new BoundingRect(x, y, outerWidth, outerHeight);\n  rect.lineHeight = contentBlock.lineHeight;\n  return rect;\n}\n\nfunction getRichTextRect(text, font, textAlign, textVerticalAlign, textPadding, rich, truncate) {\n  var contentBlock = parseRichText(text, {\n    rich: rich,\n    truncate: truncate,\n    font: font,\n    textAlign: textAlign,\n    textPadding: textPadding\n  });\n  var outerWidth = contentBlock.outerWidth;\n  var outerHeight = contentBlock.outerHeight;\n  var x = adjustTextX(0, outerWidth, textAlign);\n  var y = adjustTextY(0, outerHeight, textVerticalAlign);\n  return new BoundingRect(x, y, outerWidth, outerHeight);\n}\n/**\n * @public\n * @param {number} x\n * @param {number} width\n * @param {string} [textAlign='left']\n * @return {number} Adjusted x.\n */\n\n\nfunction adjustTextX(x, width, textAlign) {\n  // FIXME Right to left language\n  if (textAlign === 'right') {\n    x -= width;\n  } else if (textAlign === 'center') {\n    x -= width / 2;\n  }\n\n  return x;\n}\n/**\n * @public\n * @param {number} y\n * @param {number} height\n * @param {string} [textVerticalAlign='top']\n * @return {number} Adjusted y.\n */\n\n\nfunction adjustTextY(y, height, textVerticalAlign) {\n  if (textVerticalAlign === 'middle') {\n    y -= height / 2;\n  } else if (textVerticalAlign === 'bottom') {\n    y -= height;\n  }\n\n  return y;\n}\n/**\n * @public\n * @param {stirng} textPosition\n * @param {Object} rect {x, y, width, height}\n * @param {number} distance\n * @return {Object} {x, y, textAlign, textVerticalAlign}\n */\n\n\nfunction adjustTextPositionOnRect(textPosition, rect, distance) {\n  var x = rect.x;\n  var y = rect.y;\n  var height = rect.height;\n  var width = rect.width;\n  var halfHeight = height / 2;\n  var textAlign = 'left';\n  var textVerticalAlign = 'top';\n\n  switch (textPosition) {\n    case 'left':\n      x -= distance;\n      y += halfHeight;\n      textAlign = 'right';\n      textVerticalAlign = 'middle';\n      break;\n\n    case 'right':\n      x += distance + width;\n      y += halfHeight;\n      textVerticalAlign = 'middle';\n      break;\n\n    case 'top':\n      x += width / 2;\n      y -= distance;\n      textAlign = 'center';\n      textVerticalAlign = 'bottom';\n      break;\n\n    case 'bottom':\n      x += width / 2;\n      y += height + distance;\n      textAlign = 'center';\n      break;\n\n    case 'inside':\n      x += width / 2;\n      y += halfHeight;\n      textAlign = 'center';\n      textVerticalAlign = 'middle';\n      break;\n\n    case 'insideLeft':\n      x += distance;\n      y += halfHeight;\n      textVerticalAlign = 'middle';\n      break;\n\n    case 'insideRight':\n      x += width - distance;\n      y += halfHeight;\n      textAlign = 'right';\n      textVerticalAlign = 'middle';\n      break;\n\n    case 'insideTop':\n      x += width / 2;\n      y += distance;\n      textAlign = 'center';\n      break;\n\n    case 'insideBottom':\n      x += width / 2;\n      y += height - distance;\n      textAlign = 'center';\n      textVerticalAlign = 'bottom';\n      break;\n\n    case 'insideTopLeft':\n      x += distance;\n      y += distance;\n      break;\n\n    case 'insideTopRight':\n      x += width - distance;\n      y += distance;\n      textAlign = 'right';\n      break;\n\n    case 'insideBottomLeft':\n      x += distance;\n      y += height - distance;\n      textVerticalAlign = 'bottom';\n      break;\n\n    case 'insideBottomRight':\n      x += width - distance;\n      y += height - distance;\n      textAlign = 'right';\n      textVerticalAlign = 'bottom';\n      break;\n  }\n\n  return {\n    x: x,\n    y: y,\n    textAlign: textAlign,\n    textVerticalAlign: textVerticalAlign\n  };\n}\n/**\n * Show ellipsis if overflow.\n *\n * @public\n * @param  {string} text\n * @param  {string} containerWidth\n * @param  {string} font\n * @param  {number} [ellipsis='...']\n * @param  {Object} [options]\n * @param  {number} [options.maxIterations=3]\n * @param  {number} [options.minChar=0] If truncate result are less\n *                  then minChar, ellipsis will not show, which is\n *                  better for user hint in some cases.\n * @param  {number} [options.placeholder=''] When all truncated, use the placeholder.\n * @return {string}\n */\n\n\nfunction truncateText(text, containerWidth, font, ellipsis, options) {\n  if (!containerWidth) {\n    return '';\n  }\n\n  var textLines = (text + '').split('\\n');\n  options = prepareTruncateOptions(containerWidth, font, ellipsis, options); // FIXME\n  // It is not appropriate that every line has '...' when truncate multiple lines.\n\n  for (var i = 0, len = textLines.length; i < len; i++) {\n    textLines[i] = truncateSingleLine(textLines[i], options);\n  }\n\n  return textLines.join('\\n');\n}\n\nfunction prepareTruncateOptions(containerWidth, font, ellipsis, options) {\n  options = extend({}, options);\n  options.font = font;\n  var ellipsis = retrieve2(ellipsis, '...');\n  options.maxIterations = retrieve2(options.maxIterations, 2);\n  var minChar = options.minChar = retrieve2(options.minChar, 0); // FIXME\n  // Other languages?\n\n  options.cnCharWidth = getWidth('国', font); // FIXME\n  // Consider proportional font?\n\n  var ascCharWidth = options.ascCharWidth = getWidth('a', font);\n  options.placeholder = retrieve2(options.placeholder, ''); // Example 1: minChar: 3, text: 'asdfzxcv', truncate result: 'asdf', but not: 'a...'.\n  // Example 2: minChar: 3, text: '维度', truncate result: '维', but not: '...'.\n\n  var contentWidth = containerWidth = Math.max(0, containerWidth - 1); // Reserve some gap.\n\n  for (var i = 0; i < minChar && contentWidth >= ascCharWidth; i++) {\n    contentWidth -= ascCharWidth;\n  }\n\n  var ellipsisWidth = getWidth(ellipsis);\n\n  if (ellipsisWidth > contentWidth) {\n    ellipsis = '';\n    ellipsisWidth = 0;\n  }\n\n  contentWidth = containerWidth - ellipsisWidth;\n  options.ellipsis = ellipsis;\n  options.ellipsisWidth = ellipsisWidth;\n  options.contentWidth = contentWidth;\n  options.containerWidth = containerWidth;\n  return options;\n}\n\nfunction truncateSingleLine(textLine, options) {\n  var containerWidth = options.containerWidth;\n  var font = options.font;\n  var contentWidth = options.contentWidth;\n\n  if (!containerWidth) {\n    return '';\n  }\n\n  var lineWidth = getWidth(textLine, font);\n\n  if (lineWidth <= containerWidth) {\n    return textLine;\n  }\n\n  for (var j = 0;; j++) {\n    if (lineWidth <= contentWidth || j >= options.maxIterations) {\n      textLine += options.ellipsis;\n      break;\n    }\n\n    var subLength = j === 0 ? estimateLength(textLine, contentWidth, options.ascCharWidth, options.cnCharWidth) : lineWidth > 0 ? Math.floor(textLine.length * contentWidth / lineWidth) : 0;\n    textLine = textLine.substr(0, subLength);\n    lineWidth = getWidth(textLine, font);\n  }\n\n  if (textLine === '') {\n    textLine = options.placeholder;\n  }\n\n  return textLine;\n}\n\nfunction estimateLength(text, contentWidth, ascCharWidth, cnCharWidth) {\n  var width = 0;\n  var i = 0;\n\n  for (var len = text.length; i < len && width < contentWidth; i++) {\n    var charCode = text.charCodeAt(i);\n    width += 0 <= charCode && charCode <= 127 ? ascCharWidth : cnCharWidth;\n  }\n\n  return i;\n}\n/**\n * @public\n * @param {string} font\n * @return {number} line height\n */\n\n\nfunction getLineHeight(font) {\n  // FIXME A rough approach.\n  return getWidth('国', font);\n}\n/**\n * @public\n * @param {string} text\n * @param {string} font\n * @return {Object} width\n */\n\n\nfunction measureText(text, font) {\n  return methods.measureText(text, font);\n} // Avoid assign to an exported variable, for transforming to cjs.\n\n\nmethods.measureText = function (text, font) {\n  var ctx = getContext();\n  ctx.font = font || DEFAULT_FONT;\n  return ctx.measureText(text);\n};\n/**\n * @public\n * @param {string} text\n * @param {string} font\n * @param {Object} [truncate]\n * @return {Object} block: {lineHeight, lines, height, outerHeight}\n *  Notice: for performance, do not calculate outerWidth util needed.\n */\n\n\nfunction parsePlainText(text, font, padding, truncate) {\n  text != null && (text += '');\n  var lineHeight = getLineHeight(font);\n  var lines = text ? text.split('\\n') : [];\n  var height = lines.length * lineHeight;\n  var outerHeight = height;\n\n  if (padding) {\n    outerHeight += padding[0] + padding[2];\n  }\n\n  if (text && truncate) {\n    var truncOuterHeight = truncate.outerHeight;\n    var truncOuterWidth = truncate.outerWidth;\n\n    if (truncOuterHeight != null && outerHeight > truncOuterHeight) {\n      text = '';\n      lines = [];\n    } else if (truncOuterWidth != null) {\n      var options = prepareTruncateOptions(truncOuterWidth - (padding ? padding[1] + padding[3] : 0), font, truncate.ellipsis, {\n        minChar: truncate.minChar,\n        placeholder: truncate.placeholder\n      }); // FIXME\n      // It is not appropriate that every line has '...' when truncate multiple lines.\n\n      for (var i = 0, len = lines.length; i < len; i++) {\n        lines[i] = truncateSingleLine(lines[i], options);\n      }\n    }\n  }\n\n  return {\n    lines: lines,\n    height: height,\n    outerHeight: outerHeight,\n    lineHeight: lineHeight\n  };\n}\n/**\n * For example: 'some text {a|some text}other text{b|some text}xxx{c|}xxx'\n * Also consider 'bbbb{a|xxx\\nzzz}xxxx\\naaaa'.\n *\n * @public\n * @param {string} text\n * @param {Object} style\n * @return {Object} block\n * {\n *      width,\n *      height,\n *      lines: [{\n *          lineHeight,\n *          width,\n *          tokens: [[{\n *              styleName,\n *              text,\n *              width,      // include textPadding\n *              height,     // include textPadding\n *              textWidth, // pure text width\n *              textHeight, // pure text height\n *              lineHeihgt,\n *              font,\n *              textAlign,\n *              textVerticalAlign\n *          }], [...], ...]\n *      }, ...]\n * }\n * If styleName is undefined, it is plain text.\n */\n\n\nfunction parseRichText(text, style) {\n  var contentBlock = {\n    lines: [],\n    width: 0,\n    height: 0\n  };\n  text != null && (text += '');\n\n  if (!text) {\n    return contentBlock;\n  }\n\n  var lastIndex = STYLE_REG.lastIndex = 0;\n  var result;\n\n  while ((result = STYLE_REG.exec(text)) != null) {\n    var matchedIndex = result.index;\n\n    if (matchedIndex > lastIndex) {\n      pushTokens(contentBlock, text.substring(lastIndex, matchedIndex));\n    }\n\n    pushTokens(contentBlock, result[2], result[1]);\n    lastIndex = STYLE_REG.lastIndex;\n  }\n\n  if (lastIndex < text.length) {\n    pushTokens(contentBlock, text.substring(lastIndex, text.length));\n  }\n\n  var lines = contentBlock.lines;\n  var contentHeight = 0;\n  var contentWidth = 0; // For `textWidth: 100%`\n\n  var pendingList = [];\n  var stlPadding = style.textPadding;\n  var truncate = style.truncate;\n  var truncateWidth = truncate && truncate.outerWidth;\n  var truncateHeight = truncate && truncate.outerHeight;\n\n  if (stlPadding) {\n    truncateWidth != null && (truncateWidth -= stlPadding[1] + stlPadding[3]);\n    truncateHeight != null && (truncateHeight -= stlPadding[0] + stlPadding[2]);\n  } // Calculate layout info of tokens.\n\n\n  for (var i = 0; i < lines.length; i++) {\n    var line = lines[i];\n    var lineHeight = 0;\n    var lineWidth = 0;\n\n    for (var j = 0; j < line.tokens.length; j++) {\n      var token = line.tokens[j];\n      var tokenStyle = token.styleName && style.rich[token.styleName] || {}; // textPadding should not inherit from style.\n\n      var textPadding = token.textPadding = tokenStyle.textPadding; // textFont has been asigned to font by `normalizeStyle`.\n\n      var font = token.font = tokenStyle.font || style.font; // textHeight can be used when textVerticalAlign is specified in token.\n\n      var tokenHeight = token.textHeight = retrieve2( // textHeight should not be inherited, consider it can be specified\n      // as box height of the block.\n      tokenStyle.textHeight, getLineHeight(font));\n      textPadding && (tokenHeight += textPadding[0] + textPadding[2]);\n      token.height = tokenHeight;\n      token.lineHeight = retrieve3(tokenStyle.textLineHeight, style.textLineHeight, tokenHeight);\n      token.textAlign = tokenStyle && tokenStyle.textAlign || style.textAlign;\n      token.textVerticalAlign = tokenStyle && tokenStyle.textVerticalAlign || 'middle';\n\n      if (truncateHeight != null && contentHeight + token.lineHeight > truncateHeight) {\n        return {\n          lines: [],\n          width: 0,\n          height: 0\n        };\n      }\n\n      token.textWidth = getWidth(token.text, font);\n      var tokenWidth = tokenStyle.textWidth;\n      var tokenWidthNotSpecified = tokenWidth == null || tokenWidth === 'auto'; // Percent width, can be `100%`, can be used in drawing separate\n      // line when box width is needed to be auto.\n\n      if (typeof tokenWidth === 'string' && tokenWidth.charAt(tokenWidth.length - 1) === '%') {\n        token.percentWidth = tokenWidth;\n        pendingList.push(token);\n        tokenWidth = 0; // Do not truncate in this case, because there is no user case\n        // and it is too complicated.\n      } else {\n        if (tokenWidthNotSpecified) {\n          tokenWidth = token.textWidth; // FIXME: If image is not loaded and textWidth is not specified, calling\n          // `getBoundingRect()` will not get correct result.\n\n          var textBackgroundColor = tokenStyle.textBackgroundColor;\n          var bgImg = textBackgroundColor && textBackgroundColor.image; // Use cases:\n          // (1) If image is not loaded, it will be loaded at render phase and call\n          // `dirty()` and `textBackgroundColor.image` will be replaced with the loaded\n          // image, and then the right size will be calculated here at the next tick.\n          // See `graphic/helper/text.js`.\n          // (2) If image loaded, and `textBackgroundColor.image` is image src string,\n          // use `imageHelper.findExistImage` to find cached image.\n          // `imageHelper.findExistImage` will always be called here before\n          // `imageHelper.createOrUpdateImage` in `graphic/helper/text.js#renderRichText`\n          // which ensures that image will not be rendered before correct size calcualted.\n\n          if (bgImg) {\n            bgImg = imageHelper.findExistImage(bgImg);\n\n            if (imageHelper.isImageReady(bgImg)) {\n              tokenWidth = Math.max(tokenWidth, bgImg.width * tokenHeight / bgImg.height);\n            }\n          }\n        }\n\n        var paddingW = textPadding ? textPadding[1] + textPadding[3] : 0;\n        tokenWidth += paddingW;\n        var remianTruncWidth = truncateWidth != null ? truncateWidth - lineWidth : null;\n\n        if (remianTruncWidth != null && remianTruncWidth < tokenWidth) {\n          if (!tokenWidthNotSpecified || remianTruncWidth < paddingW) {\n            token.text = '';\n            token.textWidth = tokenWidth = 0;\n          } else {\n            token.text = truncateText(token.text, remianTruncWidth - paddingW, font, truncate.ellipsis, {\n              minChar: truncate.minChar\n            });\n            token.textWidth = getWidth(token.text, font);\n            tokenWidth = token.textWidth + paddingW;\n          }\n        }\n      }\n\n      lineWidth += token.width = tokenWidth;\n      tokenStyle && (lineHeight = Math.max(lineHeight, token.lineHeight));\n    }\n\n    line.width = lineWidth;\n    line.lineHeight = lineHeight;\n    contentHeight += lineHeight;\n    contentWidth = Math.max(contentWidth, lineWidth);\n  }\n\n  contentBlock.outerWidth = contentBlock.width = retrieve2(style.textWidth, contentWidth);\n  contentBlock.outerHeight = contentBlock.height = retrieve2(style.textHeight, contentHeight);\n\n  if (stlPadding) {\n    contentBlock.outerWidth += stlPadding[1] + stlPadding[3];\n    contentBlock.outerHeight += stlPadding[0] + stlPadding[2];\n  }\n\n  for (var i = 0; i < pendingList.length; i++) {\n    var token = pendingList[i];\n    var percentWidth = token.percentWidth; // Should not base on outerWidth, because token can not be placed out of padding.\n\n    token.width = parseInt(percentWidth, 10) / 100 * contentWidth;\n  }\n\n  return contentBlock;\n}\n\nfunction pushTokens(block, str, styleName) {\n  var isEmptyStr = str === '';\n  var strs = str.split('\\n');\n  var lines = block.lines;\n\n  for (var i = 0; i < strs.length; i++) {\n    var text = strs[i];\n    var token = {\n      styleName: styleName,\n      text: text,\n      isLineHolder: !text && !isEmptyStr\n    }; // The first token should be appended to the last line.\n\n    if (!i) {\n      var tokens = (lines[lines.length - 1] || (lines[0] = {\n        tokens: []\n      })).tokens; // Consider cases:\n      // (1) ''.split('\\n') => ['', '\\n', ''], the '' at the first item\n      // (which is a placeholder) should be replaced by new token.\n      // (2) A image backage, where token likes {a|}.\n      // (3) A redundant '' will affect textAlign in line.\n      // (4) tokens with the same tplName should not be merged, because\n      // they should be displayed in different box (with border and padding).\n\n      var tokensLen = tokens.length;\n      tokensLen === 1 && tokens[0].isLineHolder ? tokens[0] = token : // Consider text is '', only insert when it is the \"lineHolder\" or\n      // \"emptyStr\". Otherwise a redundant '' will affect textAlign in line.\n      (text || !tokensLen || isEmptyStr) && tokens.push(token);\n    } // Other tokens always start a new line.\n    else {\n        // If there is '', insert it as a placeholder.\n        lines.push({\n          tokens: [token]\n        });\n      }\n  }\n}\n\nfunction makeFont(style) {\n  // FIXME in node-canvas fontWeight is before fontStyle\n  // Use `fontSize` `fontFamily` to check whether font properties are defined.\n  return (style.fontSize || style.fontFamily) && [style.fontStyle, style.fontWeight, (style.fontSize || 12) + 'px', // If font properties are defined, `fontFamily` should not be ignored.\n  style.fontFamily || 'sans-serif'].join(' ') || style.textFont || style.font;\n}\n\nexports.DEFAULT_FONT = DEFAULT_FONT;\nexports.$override = $override;\nexports.getWidth = getWidth;\nexports.getBoundingRect = getBoundingRect;\nexports.adjustTextX = adjustTextX;\nexports.adjustTextY = adjustTextY;\nexports.adjustTextPositionOnRect = adjustTextPositionOnRect;\nexports.truncateText = truncateText;\nexports.getLineHeight = getLineHeight;\nexports.measureText = measureText;\nexports.parsePlainText = parsePlainText;\nexports.parseRichText = parseRichText;\nexports.makeFont = makeFont;"]},"metadata":{},"sourceType":"script"}