{"ast":null,"code":"var _config = require(\"../../config\");\n\nvar __DEV__ = _config.__DEV__;\n\nvar zrUtil = require(\"zrender/lib/core/util\");\n\nvar List = require(\"../../data/List\");\n\nvar completeDimensions = require(\"../../data/helper/completeDimensions\");\n\nvar _model = require(\"../../util/model\");\n\nvar getDataItemValue = _model.getDataItemValue;\nvar converDataValue = _model.converDataValue;\nvar isDataItemOption = _model.isDataItemOption;\n\nvar CoordinateSystem = require(\"../../CoordinateSystem\");\n\nfunction firstDataNotNull(data) {\n  var i = 0;\n\n  while (i < data.length && data[i] == null) {\n    i++;\n  }\n\n  return data[i];\n}\n\nfunction ifNeedCompleteOrdinalData(data) {\n  var sampleItem = firstDataNotNull(data);\n  return sampleItem != null && !zrUtil.isArray(getDataItemValue(sampleItem));\n}\n/**\n * Helper function to create a list from option data\n */\n\n\nfunction createListFromArray(data, seriesModel, ecModel) {\n  // If data is undefined\n  data = data || [];\n  var coordSysName = seriesModel.get('coordinateSystem');\n  var creator = creators[coordSysName];\n  var registeredCoordSys = CoordinateSystem.get(coordSysName);\n  var completeDimOpt = {\n    encodeDef: seriesModel.get('encode'),\n    dimsDef: seriesModel.get('dimensions')\n  }; // FIXME\n\n  var axesInfo = creator && creator(data, seriesModel, ecModel, completeDimOpt);\n  var dimensions = axesInfo && axesInfo.dimensions;\n\n  if (!dimensions) {\n    // Get dimensions from registered coordinate system\n    dimensions = registeredCoordSys && (registeredCoordSys.getDimensionsInfo ? registeredCoordSys.getDimensionsInfo() : registeredCoordSys.dimensions.slice()) || ['x', 'y'];\n    dimensions = completeDimensions(dimensions, data, completeDimOpt);\n  }\n\n  var categoryIndex = axesInfo ? axesInfo.categoryIndex : -1;\n  var list = new List(dimensions, seriesModel);\n  var nameList = createNameList(axesInfo, data);\n  var categories = {};\n  var dimValueGetter = categoryIndex >= 0 && ifNeedCompleteOrdinalData(data) ? function (itemOpt, dimName, dataIndex, dimIndex) {\n    // If any dataItem is like { value: 10 }\n    if (isDataItemOption(itemOpt)) {\n      list.hasItemOption = true;\n    } // Use dataIndex as ordinal value in categoryAxis\n\n\n    return dimIndex === categoryIndex ? dataIndex : converDataValue(getDataItemValue(itemOpt), dimensions[dimIndex]);\n  } : function (itemOpt, dimName, dataIndex, dimIndex) {\n    var value = getDataItemValue(itemOpt);\n    var val = converDataValue(value && value[dimIndex], dimensions[dimIndex]); // If any dataItem is like { value: 10 }\n\n    if (isDataItemOption(itemOpt)) {\n      list.hasItemOption = true;\n    }\n\n    var categoryAxesModels = axesInfo && axesInfo.categoryAxesModels;\n\n    if (categoryAxesModels && categoryAxesModels[dimName]) {\n      // If given value is a category string\n      if (typeof val === 'string') {\n        // Lazy get categories\n        categories[dimName] = categories[dimName] || categoryAxesModels[dimName].getCategories();\n        val = zrUtil.indexOf(categories[dimName], val);\n\n        if (val < 0 && !isNaN(val)) {\n          // In case some one write '1', '2' istead of 1, 2\n          val = +val;\n        }\n      }\n    }\n\n    return val;\n  };\n  list.hasItemOption = false;\n  list.initData(data, nameList, dimValueGetter);\n  return list;\n}\n\nfunction isStackable(axisType) {\n  return axisType !== 'category' && axisType !== 'time';\n}\n\nfunction getDimTypeByAxis(axisType) {\n  return axisType === 'category' ? 'ordinal' : axisType === 'time' ? 'time' : 'float';\n}\n/**\n * Creaters for each coord system.\n */\n\n\nvar creators = {\n  cartesian2d: function (data, seriesModel, ecModel, completeDimOpt) {\n    var axesModels = zrUtil.map(['xAxis', 'yAxis'], function (name) {\n      return ecModel.queryComponents({\n        mainType: name,\n        index: seriesModel.get(name + 'Index'),\n        id: seriesModel.get(name + 'Id')\n      })[0];\n    });\n    var xAxisModel = axesModels[0];\n    var yAxisModel = axesModels[1];\n    var xAxisType = xAxisModel.get('type');\n    var yAxisType = yAxisModel.get('type');\n    var dimensions = [{\n      name: 'x',\n      type: getDimTypeByAxis(xAxisType),\n      stackable: isStackable(xAxisType)\n    }, {\n      name: 'y',\n      // If two category axes\n      type: getDimTypeByAxis(yAxisType),\n      stackable: isStackable(yAxisType)\n    }];\n    var isXAxisCateogry = xAxisType === 'category';\n    var isYAxisCategory = yAxisType === 'category';\n    dimensions = completeDimensions(dimensions, data, completeDimOpt);\n    var categoryAxesModels = {};\n\n    if (isXAxisCateogry) {\n      categoryAxesModels.x = xAxisModel;\n    }\n\n    if (isYAxisCategory) {\n      categoryAxesModels.y = yAxisModel;\n    }\n\n    return {\n      dimensions: dimensions,\n      categoryIndex: isXAxisCateogry ? 0 : isYAxisCategory ? 1 : -1,\n      categoryAxesModels: categoryAxesModels\n    };\n  },\n  singleAxis: function (data, seriesModel, ecModel, completeDimOpt) {\n    var singleAxisModel = ecModel.queryComponents({\n      mainType: 'singleAxis',\n      index: seriesModel.get('singleAxisIndex'),\n      id: seriesModel.get('singleAxisId')\n    })[0];\n    var singleAxisType = singleAxisModel.get('type');\n    var isCategory = singleAxisType === 'category';\n    var dimensions = [{\n      name: 'single',\n      type: getDimTypeByAxis(singleAxisType),\n      stackable: isStackable(singleAxisType)\n    }];\n    dimensions = completeDimensions(dimensions, data, completeDimOpt);\n    var categoryAxesModels = {};\n\n    if (isCategory) {\n      categoryAxesModels.single = singleAxisModel;\n    }\n\n    return {\n      dimensions: dimensions,\n      categoryIndex: isCategory ? 0 : -1,\n      categoryAxesModels: categoryAxesModels\n    };\n  },\n  polar: function (data, seriesModel, ecModel, completeDimOpt) {\n    var polarModel = ecModel.queryComponents({\n      mainType: 'polar',\n      index: seriesModel.get('polarIndex'),\n      id: seriesModel.get('polarId')\n    })[0];\n    var angleAxisModel = polarModel.findAxisModel('angleAxis');\n    var radiusAxisModel = polarModel.findAxisModel('radiusAxis');\n    var radiusAxisType = radiusAxisModel.get('type');\n    var angleAxisType = angleAxisModel.get('type');\n    var dimensions = [{\n      name: 'radius',\n      type: getDimTypeByAxis(radiusAxisType),\n      stackable: isStackable(radiusAxisType)\n    }, {\n      name: 'angle',\n      type: getDimTypeByAxis(angleAxisType),\n      stackable: isStackable(angleAxisType)\n    }];\n    var isAngleAxisCateogry = angleAxisType === 'category';\n    var isRadiusAxisCateogry = radiusAxisType === 'category';\n    dimensions = completeDimensions(dimensions, data, completeDimOpt);\n    var categoryAxesModels = {};\n\n    if (isRadiusAxisCateogry) {\n      categoryAxesModels.radius = radiusAxisModel;\n    }\n\n    if (isAngleAxisCateogry) {\n      categoryAxesModels.angle = angleAxisModel;\n    }\n\n    return {\n      dimensions: dimensions,\n      categoryIndex: isAngleAxisCateogry ? 1 : isRadiusAxisCateogry ? 0 : -1,\n      categoryAxesModels: categoryAxesModels\n    };\n  },\n  geo: function (data, seriesModel, ecModel, completeDimOpt) {\n    // TODO Region\n    // 多个散点图系列在同一个地区的时候\n    return {\n      dimensions: completeDimensions([{\n        name: 'lng'\n      }, {\n        name: 'lat'\n      }], data, completeDimOpt)\n    };\n  }\n};\n\nfunction createNameList(result, data) {\n  var nameList = [];\n  var categoryDim = result && result.dimensions[result.categoryIndex];\n  var categoryAxisModel;\n\n  if (categoryDim) {\n    categoryAxisModel = result.categoryAxesModels[categoryDim.name];\n  }\n\n  if (categoryAxisModel) {\n    // FIXME Two category axis\n    var categories = categoryAxisModel.getCategories();\n\n    if (categories) {\n      var dataLen = data.length; // Ordered data is given explicitly like\n      // [[3, 0.2], [1, 0.3], [2, 0.15]]\n      // or given scatter data,\n      // pick the category\n\n      if (zrUtil.isArray(data[0]) && data[0].length > 1) {\n        nameList = [];\n\n        for (var i = 0; i < dataLen; i++) {\n          nameList[i] = categories[data[i][result.categoryIndex || 0]];\n        }\n      } else {\n        nameList = categories.slice(0);\n      }\n    }\n  }\n\n  return nameList;\n}\n\nvar _default = createListFromArray;\nmodule.exports = _default;","map":{"version":3,"sources":["/home/martin/Escritorio/Taller de Integracion/Tarea3-TallerDeIntegracion/node_modules/react-echarts/node_modules/echarts/lib/chart/helper/createListFromArray.js"],"names":["_config","require","__DEV__","zrUtil","List","completeDimensions","_model","getDataItemValue","converDataValue","isDataItemOption","CoordinateSystem","firstDataNotNull","data","i","length","ifNeedCompleteOrdinalData","sampleItem","isArray","createListFromArray","seriesModel","ecModel","coordSysName","get","creator","creators","registeredCoordSys","completeDimOpt","encodeDef","dimsDef","axesInfo","dimensions","getDimensionsInfo","slice","categoryIndex","list","nameList","createNameList","categories","dimValueGetter","itemOpt","dimName","dataIndex","dimIndex","hasItemOption","value","val","categoryAxesModels","getCategories","indexOf","isNaN","initData","isStackable","axisType","getDimTypeByAxis","cartesian2d","axesModels","map","name","queryComponents","mainType","index","id","xAxisModel","yAxisModel","xAxisType","yAxisType","type","stackable","isXAxisCateogry","isYAxisCategory","x","y","singleAxis","singleAxisModel","singleAxisType","isCategory","single","polar","polarModel","angleAxisModel","findAxisModel","radiusAxisModel","radiusAxisType","angleAxisType","isAngleAxisCateogry","isRadiusAxisCateogry","radius","angle","geo","result","categoryDim","categoryAxisModel","dataLen","_default","module","exports"],"mappings":"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","sourcesContent":["var _config = require(\"../../config\");\n\nvar __DEV__ = _config.__DEV__;\n\nvar zrUtil = require(\"zrender/lib/core/util\");\n\nvar List = require(\"../../data/List\");\n\nvar completeDimensions = require(\"../../data/helper/completeDimensions\");\n\nvar _model = require(\"../../util/model\");\n\nvar getDataItemValue = _model.getDataItemValue;\nvar converDataValue = _model.converDataValue;\nvar isDataItemOption = _model.isDataItemOption;\n\nvar CoordinateSystem = require(\"../../CoordinateSystem\");\n\nfunction firstDataNotNull(data) {\n  var i = 0;\n\n  while (i < data.length && data[i] == null) {\n    i++;\n  }\n\n  return data[i];\n}\n\nfunction ifNeedCompleteOrdinalData(data) {\n  var sampleItem = firstDataNotNull(data);\n  return sampleItem != null && !zrUtil.isArray(getDataItemValue(sampleItem));\n}\n/**\n * Helper function to create a list from option data\n */\n\n\nfunction createListFromArray(data, seriesModel, ecModel) {\n  // If data is undefined\n  data = data || [];\n  var coordSysName = seriesModel.get('coordinateSystem');\n  var creator = creators[coordSysName];\n  var registeredCoordSys = CoordinateSystem.get(coordSysName);\n  var completeDimOpt = {\n    encodeDef: seriesModel.get('encode'),\n    dimsDef: seriesModel.get('dimensions')\n  }; // FIXME\n\n  var axesInfo = creator && creator(data, seriesModel, ecModel, completeDimOpt);\n  var dimensions = axesInfo && axesInfo.dimensions;\n\n  if (!dimensions) {\n    // Get dimensions from registered coordinate system\n    dimensions = registeredCoordSys && (registeredCoordSys.getDimensionsInfo ? registeredCoordSys.getDimensionsInfo() : registeredCoordSys.dimensions.slice()) || ['x', 'y'];\n    dimensions = completeDimensions(dimensions, data, completeDimOpt);\n  }\n\n  var categoryIndex = axesInfo ? axesInfo.categoryIndex : -1;\n  var list = new List(dimensions, seriesModel);\n  var nameList = createNameList(axesInfo, data);\n  var categories = {};\n  var dimValueGetter = categoryIndex >= 0 && ifNeedCompleteOrdinalData(data) ? function (itemOpt, dimName, dataIndex, dimIndex) {\n    // If any dataItem is like { value: 10 }\n    if (isDataItemOption(itemOpt)) {\n      list.hasItemOption = true;\n    } // Use dataIndex as ordinal value in categoryAxis\n\n\n    return dimIndex === categoryIndex ? dataIndex : converDataValue(getDataItemValue(itemOpt), dimensions[dimIndex]);\n  } : function (itemOpt, dimName, dataIndex, dimIndex) {\n    var value = getDataItemValue(itemOpt);\n    var val = converDataValue(value && value[dimIndex], dimensions[dimIndex]); // If any dataItem is like { value: 10 }\n\n    if (isDataItemOption(itemOpt)) {\n      list.hasItemOption = true;\n    }\n\n    var categoryAxesModels = axesInfo && axesInfo.categoryAxesModels;\n\n    if (categoryAxesModels && categoryAxesModels[dimName]) {\n      // If given value is a category string\n      if (typeof val === 'string') {\n        // Lazy get categories\n        categories[dimName] = categories[dimName] || categoryAxesModels[dimName].getCategories();\n        val = zrUtil.indexOf(categories[dimName], val);\n\n        if (val < 0 && !isNaN(val)) {\n          // In case some one write '1', '2' istead of 1, 2\n          val = +val;\n        }\n      }\n    }\n\n    return val;\n  };\n  list.hasItemOption = false;\n  list.initData(data, nameList, dimValueGetter);\n  return list;\n}\n\nfunction isStackable(axisType) {\n  return axisType !== 'category' && axisType !== 'time';\n}\n\nfunction getDimTypeByAxis(axisType) {\n  return axisType === 'category' ? 'ordinal' : axisType === 'time' ? 'time' : 'float';\n}\n/**\n * Creaters for each coord system.\n */\n\n\nvar creators = {\n  cartesian2d: function (data, seriesModel, ecModel, completeDimOpt) {\n    var axesModels = zrUtil.map(['xAxis', 'yAxis'], function (name) {\n      return ecModel.queryComponents({\n        mainType: name,\n        index: seriesModel.get(name + 'Index'),\n        id: seriesModel.get(name + 'Id')\n      })[0];\n    });\n    var xAxisModel = axesModels[0];\n    var yAxisModel = axesModels[1];\n    var xAxisType = xAxisModel.get('type');\n    var yAxisType = yAxisModel.get('type');\n    var dimensions = [{\n      name: 'x',\n      type: getDimTypeByAxis(xAxisType),\n      stackable: isStackable(xAxisType)\n    }, {\n      name: 'y',\n      // If two category axes\n      type: getDimTypeByAxis(yAxisType),\n      stackable: isStackable(yAxisType)\n    }];\n    var isXAxisCateogry = xAxisType === 'category';\n    var isYAxisCategory = yAxisType === 'category';\n    dimensions = completeDimensions(dimensions, data, completeDimOpt);\n    var categoryAxesModels = {};\n\n    if (isXAxisCateogry) {\n      categoryAxesModels.x = xAxisModel;\n    }\n\n    if (isYAxisCategory) {\n      categoryAxesModels.y = yAxisModel;\n    }\n\n    return {\n      dimensions: dimensions,\n      categoryIndex: isXAxisCateogry ? 0 : isYAxisCategory ? 1 : -1,\n      categoryAxesModels: categoryAxesModels\n    };\n  },\n  singleAxis: function (data, seriesModel, ecModel, completeDimOpt) {\n    var singleAxisModel = ecModel.queryComponents({\n      mainType: 'singleAxis',\n      index: seriesModel.get('singleAxisIndex'),\n      id: seriesModel.get('singleAxisId')\n    })[0];\n    var singleAxisType = singleAxisModel.get('type');\n    var isCategory = singleAxisType === 'category';\n    var dimensions = [{\n      name: 'single',\n      type: getDimTypeByAxis(singleAxisType),\n      stackable: isStackable(singleAxisType)\n    }];\n    dimensions = completeDimensions(dimensions, data, completeDimOpt);\n    var categoryAxesModels = {};\n\n    if (isCategory) {\n      categoryAxesModels.single = singleAxisModel;\n    }\n\n    return {\n      dimensions: dimensions,\n      categoryIndex: isCategory ? 0 : -1,\n      categoryAxesModels: categoryAxesModels\n    };\n  },\n  polar: function (data, seriesModel, ecModel, completeDimOpt) {\n    var polarModel = ecModel.queryComponents({\n      mainType: 'polar',\n      index: seriesModel.get('polarIndex'),\n      id: seriesModel.get('polarId')\n    })[0];\n    var angleAxisModel = polarModel.findAxisModel('angleAxis');\n    var radiusAxisModel = polarModel.findAxisModel('radiusAxis');\n    var radiusAxisType = radiusAxisModel.get('type');\n    var angleAxisType = angleAxisModel.get('type');\n    var dimensions = [{\n      name: 'radius',\n      type: getDimTypeByAxis(radiusAxisType),\n      stackable: isStackable(radiusAxisType)\n    }, {\n      name: 'angle',\n      type: getDimTypeByAxis(angleAxisType),\n      stackable: isStackable(angleAxisType)\n    }];\n    var isAngleAxisCateogry = angleAxisType === 'category';\n    var isRadiusAxisCateogry = radiusAxisType === 'category';\n    dimensions = completeDimensions(dimensions, data, completeDimOpt);\n    var categoryAxesModels = {};\n\n    if (isRadiusAxisCateogry) {\n      categoryAxesModels.radius = radiusAxisModel;\n    }\n\n    if (isAngleAxisCateogry) {\n      categoryAxesModels.angle = angleAxisModel;\n    }\n\n    return {\n      dimensions: dimensions,\n      categoryIndex: isAngleAxisCateogry ? 1 : isRadiusAxisCateogry ? 0 : -1,\n      categoryAxesModels: categoryAxesModels\n    };\n  },\n  geo: function (data, seriesModel, ecModel, completeDimOpt) {\n    // TODO Region\n    // 多个散点图系列在同一个地区的时候\n    return {\n      dimensions: completeDimensions([{\n        name: 'lng'\n      }, {\n        name: 'lat'\n      }], data, completeDimOpt)\n    };\n  }\n};\n\nfunction createNameList(result, data) {\n  var nameList = [];\n  var categoryDim = result && result.dimensions[result.categoryIndex];\n  var categoryAxisModel;\n\n  if (categoryDim) {\n    categoryAxisModel = result.categoryAxesModels[categoryDim.name];\n  }\n\n  if (categoryAxisModel) {\n    // FIXME Two category axis\n    var categories = categoryAxisModel.getCategories();\n\n    if (categories) {\n      var dataLen = data.length; // Ordered data is given explicitly like\n      // [[3, 0.2], [1, 0.3], [2, 0.15]]\n      // or given scatter data,\n      // pick the category\n\n      if (zrUtil.isArray(data[0]) && data[0].length > 1) {\n        nameList = [];\n\n        for (var i = 0; i < dataLen; i++) {\n          nameList[i] = categories[data[i][result.categoryIndex || 0]];\n        }\n      } else {\n        nameList = categories.slice(0);\n      }\n    }\n  }\n\n  return nameList;\n}\n\nvar _default = createListFromArray;\nmodule.exports = _default;"]},"metadata":{},"sourceType":"script"}