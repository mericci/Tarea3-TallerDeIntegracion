{"ast":null,"code":"/**\n * Calculate slider move result.\n * Usage:\n * (1) If both handle0 and handle1 are needed to be moved, set minSpan the same as\n * maxSpan and the same as `Math.abs(handleEnd[1] - handleEnds[0])`.\n * (2) If handle0 is forbidden to cross handle1, set minSpan as `0`.\n *\n * @param {number} delta Move length.\n * @param {Array.<number>} handleEnds handleEnds[0] can be bigger then handleEnds[1].\n *              handleEnds will be modified in this method.\n * @param {Array.<number>} extent handleEnds is restricted by extent.\n *              extent[0] should less or equals than extent[1].\n * @param {number|string} handleIndex Can be 'all', means that both move the two handleEnds,\n *              where the input minSpan and maxSpan will not work.\n * @param {number} [minSpan] The range of dataZoom can not be smaller than that.\n *              If not set, handle0 and cross handle1. If set as a non-negative\n *              number (including `0`), handles will push each other when reaching\n *              the minSpan.\n * @param {number} [maxSpan] The range of dataZoom can not be larger than that.\n * @return {Array.<number>} The input handleEnds.\n */\nfunction _default(delta, handleEnds, extent, handleIndex, minSpan, maxSpan) {\n  // Normalize firstly.\n  handleEnds[0] = restrict(handleEnds[0], extent);\n  handleEnds[1] = restrict(handleEnds[1], extent);\n  delta = delta || 0;\n  var extentSpan = extent[1] - extent[0]; // Notice maxSpan and minSpan can be null/undefined.\n\n  if (minSpan != null) {\n    minSpan = restrict(minSpan, [0, extentSpan]);\n  }\n\n  if (maxSpan != null) {\n    maxSpan = Math.max(maxSpan, minSpan != null ? minSpan : 0);\n  }\n\n  if (handleIndex === 'all') {\n    minSpan = maxSpan = Math.abs(handleEnds[1] - handleEnds[0]);\n    handleIndex = 0;\n  }\n\n  var originalDistSign = getSpanSign(handleEnds, handleIndex);\n  handleEnds[handleIndex] += delta; // Restrict in extent.\n\n  var extentMinSpan = minSpan || 0;\n  var realExtent = extent.slice();\n  originalDistSign.sign < 0 ? realExtent[0] += extentMinSpan : realExtent[1] -= extentMinSpan;\n  handleEnds[handleIndex] = restrict(handleEnds[handleIndex], realExtent); // Expand span.\n\n  var currDistSign = getSpanSign(handleEnds, handleIndex);\n\n  if (minSpan != null && (currDistSign.sign !== originalDistSign.sign || currDistSign.span < minSpan)) {\n    // If minSpan exists, 'cross' is forbinden.\n    handleEnds[1 - handleIndex] = handleEnds[handleIndex] + originalDistSign.sign * minSpan;\n  } // Shrink span.\n\n\n  var currDistSign = getSpanSign(handleEnds, handleIndex);\n\n  if (maxSpan != null && currDistSign.span > maxSpan) {\n    handleEnds[1 - handleIndex] = handleEnds[handleIndex] + currDistSign.sign * maxSpan;\n  }\n\n  return handleEnds;\n}\n\nfunction getSpanSign(handleEnds, handleIndex) {\n  var dist = handleEnds[handleIndex] - handleEnds[1 - handleIndex]; // If `handleEnds[0] === handleEnds[1]`, always believe that handleEnd[0]\n  // is at left of handleEnds[1] for non-cross case.\n\n  return {\n    span: Math.abs(dist),\n    sign: dist > 0 ? -1 : dist < 0 ? 1 : handleIndex ? -1 : 1\n  };\n}\n\nfunction restrict(value, extend) {\n  return Math.min(extend[1], Math.max(extend[0], value));\n}\n\nmodule.exports = _default;","map":{"version":3,"sources":["/home/martin/Escritorio/Taller de Integracion/Tarea3-TallerDeIntegracion/node_modules/react-echarts/node_modules/echarts/lib/component/helper/sliderMove.js"],"names":["_default","delta","handleEnds","extent","handleIndex","minSpan","maxSpan","restrict","extentSpan","Math","max","abs","originalDistSign","getSpanSign","extentMinSpan","realExtent","slice","sign","currDistSign","span","dist","value","extend","min","module","exports"],"mappings":"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","sourcesContent":["/**\n * Calculate slider move result.\n * Usage:\n * (1) If both handle0 and handle1 are needed to be moved, set minSpan the same as\n * maxSpan and the same as `Math.abs(handleEnd[1] - handleEnds[0])`.\n * (2) If handle0 is forbidden to cross handle1, set minSpan as `0`.\n *\n * @param {number} delta Move length.\n * @param {Array.<number>} handleEnds handleEnds[0] can be bigger then handleEnds[1].\n *              handleEnds will be modified in this method.\n * @param {Array.<number>} extent handleEnds is restricted by extent.\n *              extent[0] should less or equals than extent[1].\n * @param {number|string} handleIndex Can be 'all', means that both move the two handleEnds,\n *              where the input minSpan and maxSpan will not work.\n * @param {number} [minSpan] The range of dataZoom can not be smaller than that.\n *              If not set, handle0 and cross handle1. If set as a non-negative\n *              number (including `0`), handles will push each other when reaching\n *              the minSpan.\n * @param {number} [maxSpan] The range of dataZoom can not be larger than that.\n * @return {Array.<number>} The input handleEnds.\n */\nfunction _default(delta, handleEnds, extent, handleIndex, minSpan, maxSpan) {\n  // Normalize firstly.\n  handleEnds[0] = restrict(handleEnds[0], extent);\n  handleEnds[1] = restrict(handleEnds[1], extent);\n  delta = delta || 0;\n  var extentSpan = extent[1] - extent[0]; // Notice maxSpan and minSpan can be null/undefined.\n\n  if (minSpan != null) {\n    minSpan = restrict(minSpan, [0, extentSpan]);\n  }\n\n  if (maxSpan != null) {\n    maxSpan = Math.max(maxSpan, minSpan != null ? minSpan : 0);\n  }\n\n  if (handleIndex === 'all') {\n    minSpan = maxSpan = Math.abs(handleEnds[1] - handleEnds[0]);\n    handleIndex = 0;\n  }\n\n  var originalDistSign = getSpanSign(handleEnds, handleIndex);\n  handleEnds[handleIndex] += delta; // Restrict in extent.\n\n  var extentMinSpan = minSpan || 0;\n  var realExtent = extent.slice();\n  originalDistSign.sign < 0 ? realExtent[0] += extentMinSpan : realExtent[1] -= extentMinSpan;\n  handleEnds[handleIndex] = restrict(handleEnds[handleIndex], realExtent); // Expand span.\n\n  var currDistSign = getSpanSign(handleEnds, handleIndex);\n\n  if (minSpan != null && (currDistSign.sign !== originalDistSign.sign || currDistSign.span < minSpan)) {\n    // If minSpan exists, 'cross' is forbinden.\n    handleEnds[1 - handleIndex] = handleEnds[handleIndex] + originalDistSign.sign * minSpan;\n  } // Shrink span.\n\n\n  var currDistSign = getSpanSign(handleEnds, handleIndex);\n\n  if (maxSpan != null && currDistSign.span > maxSpan) {\n    handleEnds[1 - handleIndex] = handleEnds[handleIndex] + currDistSign.sign * maxSpan;\n  }\n\n  return handleEnds;\n}\n\nfunction getSpanSign(handleEnds, handleIndex) {\n  var dist = handleEnds[handleIndex] - handleEnds[1 - handleIndex]; // If `handleEnds[0] === handleEnds[1]`, always believe that handleEnd[0]\n  // is at left of handleEnds[1] for non-cross case.\n\n  return {\n    span: Math.abs(dist),\n    sign: dist > 0 ? -1 : dist < 0 ? 1 : handleIndex ? -1 : 1\n  };\n}\n\nfunction restrict(value, extend) {\n  return Math.min(extend[1], Math.max(extend[0], value));\n}\n\nmodule.exports = _default;"]},"metadata":{},"sourceType":"script"}