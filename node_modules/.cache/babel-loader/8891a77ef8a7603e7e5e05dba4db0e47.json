{"ast":null,"code":"var zrUtil = require(\"zrender/lib/core/util\");\n\nfunction retrieveTargetInfo(payload, seriesModel) {\n  if (payload && (payload.type === 'treemapZoomToNode' || payload.type === 'treemapRootToNode')) {\n    var root = seriesModel.getData().tree.root;\n    var targetNode = payload.targetNode;\n\n    if (targetNode && root.contains(targetNode)) {\n      return {\n        node: targetNode\n      };\n    }\n\n    var targetNodeId = payload.targetNodeId;\n\n    if (targetNodeId != null && (targetNode = root.getNodeById(targetNodeId))) {\n      return {\n        node: targetNode\n      };\n    }\n  }\n} // Not includes the given node at the last item.\n\n\nfunction getPathToRoot(node) {\n  var path = [];\n\n  while (node) {\n    node = node.parentNode;\n    node && path.push(node);\n  }\n\n  return path.reverse();\n}\n\nfunction aboveViewRoot(viewRoot, node) {\n  var viewPath = getPathToRoot(viewRoot);\n  return zrUtil.indexOf(viewPath, node) >= 0;\n} // From root to the input node (the input node will be included).\n\n\nfunction wrapTreePathInfo(node, seriesModel) {\n  var treePathInfo = [];\n\n  while (node) {\n    var nodeDataIndex = node.dataIndex;\n    treePathInfo.push({\n      name: node.name,\n      dataIndex: nodeDataIndex,\n      value: seriesModel.getRawValue(nodeDataIndex)\n    });\n    node = node.parentNode;\n  }\n\n  treePathInfo.reverse();\n  return treePathInfo;\n}\n\nexports.retrieveTargetInfo = retrieveTargetInfo;\nexports.getPathToRoot = getPathToRoot;\nexports.aboveViewRoot = aboveViewRoot;\nexports.wrapTreePathInfo = wrapTreePathInfo;","map":{"version":3,"sources":["/home/martin/Escritorio/Taller de Integracion/Tarea3-TallerDeIntegracion/node_modules/react-echarts/node_modules/echarts/lib/chart/treemap/helper.js"],"names":["zrUtil","require","retrieveTargetInfo","payload","seriesModel","type","root","getData","tree","targetNode","contains","node","targetNodeId","getNodeById","getPathToRoot","path","parentNode","push","reverse","aboveViewRoot","viewRoot","viewPath","indexOf","wrapTreePathInfo","treePathInfo","nodeDataIndex","dataIndex","name","value","getRawValue","exports"],"mappings":"AAAA,IAAIA,MAAM,GAAGC,OAAO,CAAC,uBAAD,CAApB;;AAEA,SAASC,kBAAT,CAA4BC,OAA5B,EAAqCC,WAArC,EAAkD;AAChD,MAAID,OAAO,KAAKA,OAAO,CAACE,IAAR,KAAiB,mBAAjB,IAAwCF,OAAO,CAACE,IAAR,KAAiB,mBAA9D,CAAX,EAA+F;AAC7F,QAAIC,IAAI,GAAGF,WAAW,CAACG,OAAZ,GAAsBC,IAAtB,CAA2BF,IAAtC;AACA,QAAIG,UAAU,GAAGN,OAAO,CAACM,UAAzB;;AAEA,QAAIA,UAAU,IAAIH,IAAI,CAACI,QAAL,CAAcD,UAAd,CAAlB,EAA6C;AAC3C,aAAO;AACLE,QAAAA,IAAI,EAAEF;AADD,OAAP;AAGD;;AAED,QAAIG,YAAY,GAAGT,OAAO,CAACS,YAA3B;;AAEA,QAAIA,YAAY,IAAI,IAAhB,KAAyBH,UAAU,GAAGH,IAAI,CAACO,WAAL,CAAiBD,YAAjB,CAAtC,CAAJ,EAA2E;AACzE,aAAO;AACLD,QAAAA,IAAI,EAAEF;AADD,OAAP;AAGD;AACF;AACF,C,CAAC;;;AAGF,SAASK,aAAT,CAAuBH,IAAvB,EAA6B;AAC3B,MAAII,IAAI,GAAG,EAAX;;AAEA,SAAOJ,IAAP,EAAa;AACXA,IAAAA,IAAI,GAAGA,IAAI,CAACK,UAAZ;AACAL,IAAAA,IAAI,IAAII,IAAI,CAACE,IAAL,CAAUN,IAAV,CAAR;AACD;;AAED,SAAOI,IAAI,CAACG,OAAL,EAAP;AACD;;AAED,SAASC,aAAT,CAAuBC,QAAvB,EAAiCT,IAAjC,EAAuC;AACrC,MAAIU,QAAQ,GAAGP,aAAa,CAACM,QAAD,CAA5B;AACA,SAAOpB,MAAM,CAACsB,OAAP,CAAeD,QAAf,EAAyBV,IAAzB,KAAkC,CAAzC;AACD,C,CAAC;;;AAGF,SAASY,gBAAT,CAA0BZ,IAA1B,EAAgCP,WAAhC,EAA6C;AAC3C,MAAIoB,YAAY,GAAG,EAAnB;;AAEA,SAAOb,IAAP,EAAa;AACX,QAAIc,aAAa,GAAGd,IAAI,CAACe,SAAzB;AACAF,IAAAA,YAAY,CAACP,IAAb,CAAkB;AAChBU,MAAAA,IAAI,EAAEhB,IAAI,CAACgB,IADK;AAEhBD,MAAAA,SAAS,EAAED,aAFK;AAGhBG,MAAAA,KAAK,EAAExB,WAAW,CAACyB,WAAZ,CAAwBJ,aAAxB;AAHS,KAAlB;AAKAd,IAAAA,IAAI,GAAGA,IAAI,CAACK,UAAZ;AACD;;AAEDQ,EAAAA,YAAY,CAACN,OAAb;AACA,SAAOM,YAAP;AACD;;AAEDM,OAAO,CAAC5B,kBAAR,GAA6BA,kBAA7B;AACA4B,OAAO,CAAChB,aAAR,GAAwBA,aAAxB;AACAgB,OAAO,CAACX,aAAR,GAAwBA,aAAxB;AACAW,OAAO,CAACP,gBAAR,GAA2BA,gBAA3B","sourcesContent":["var zrUtil = require(\"zrender/lib/core/util\");\n\nfunction retrieveTargetInfo(payload, seriesModel) {\n  if (payload && (payload.type === 'treemapZoomToNode' || payload.type === 'treemapRootToNode')) {\n    var root = seriesModel.getData().tree.root;\n    var targetNode = payload.targetNode;\n\n    if (targetNode && root.contains(targetNode)) {\n      return {\n        node: targetNode\n      };\n    }\n\n    var targetNodeId = payload.targetNodeId;\n\n    if (targetNodeId != null && (targetNode = root.getNodeById(targetNodeId))) {\n      return {\n        node: targetNode\n      };\n    }\n  }\n} // Not includes the given node at the last item.\n\n\nfunction getPathToRoot(node) {\n  var path = [];\n\n  while (node) {\n    node = node.parentNode;\n    node && path.push(node);\n  }\n\n  return path.reverse();\n}\n\nfunction aboveViewRoot(viewRoot, node) {\n  var viewPath = getPathToRoot(viewRoot);\n  return zrUtil.indexOf(viewPath, node) >= 0;\n} // From root to the input node (the input node will be included).\n\n\nfunction wrapTreePathInfo(node, seriesModel) {\n  var treePathInfo = [];\n\n  while (node) {\n    var nodeDataIndex = node.dataIndex;\n    treePathInfo.push({\n      name: node.name,\n      dataIndex: nodeDataIndex,\n      value: seriesModel.getRawValue(nodeDataIndex)\n    });\n    node = node.parentNode;\n  }\n\n  treePathInfo.reverse();\n  return treePathInfo;\n}\n\nexports.retrieveTargetInfo = retrieveTargetInfo;\nexports.getPathToRoot = getPathToRoot;\nexports.aboveViewRoot = aboveViewRoot;\nexports.wrapTreePathInfo = wrapTreePathInfo;"]},"metadata":{},"sourceType":"script"}