{"ast":null,"code":"var Animator = require(\"../animation/Animator\");\n\nvar log = require(\"../core/log\");\n\nvar _util = require(\"../core/util\");\n\nvar isString = _util.isString;\nvar isFunction = _util.isFunction;\nvar isObject = _util.isObject;\nvar isArrayLike = _util.isArrayLike;\nvar indexOf = _util.indexOf;\n/**\n * @alias modue:zrender/mixin/Animatable\n * @constructor\n */\n\nvar Animatable = function () {\n  /**\n   * @type {Array.<module:zrender/animation/Animator>}\n   * @readOnly\n   */\n  this.animators = [];\n};\n\nAnimatable.prototype = {\n  constructor: Animatable,\n\n  /**\n   * 动画\n   *\n   * @param {string} path The path to fetch value from object, like 'a.b.c'.\n   * @param {boolean} [loop] Whether to loop animation.\n   * @return {module:zrender/animation/Animator}\n   * @example:\n   *     el.animate('style', false)\n   *         .when(1000, {x: 10} )\n   *         .done(function(){ // Animation done })\n   *         .start()\n   */\n  animate: function (path, loop) {\n    var target;\n    var animatingShape = false;\n    var el = this;\n    var zr = this.__zr;\n\n    if (path) {\n      var pathSplitted = path.split('.');\n      var prop = el; // If animating shape\n\n      animatingShape = pathSplitted[0] === 'shape';\n\n      for (var i = 0, l = pathSplitted.length; i < l; i++) {\n        if (!prop) {\n          continue;\n        }\n\n        prop = prop[pathSplitted[i]];\n      }\n\n      if (prop) {\n        target = prop;\n      }\n    } else {\n      target = el;\n    }\n\n    if (!target) {\n      log('Property \"' + path + '\" is not existed in element ' + el.id);\n      return;\n    }\n\n    var animators = el.animators;\n    var animator = new Animator(target, loop);\n    animator.during(function (target) {\n      el.dirty(animatingShape);\n    }).done(function () {\n      // FIXME Animator will not be removed if use `Animator#stop` to stop animation\n      animators.splice(indexOf(animators, animator), 1);\n    });\n    animators.push(animator); // If animate after added to the zrender\n\n    if (zr) {\n      zr.animation.addAnimator(animator);\n    }\n\n    return animator;\n  },\n\n  /**\n   * 停止动画\n   * @param {boolean} forwardToLast If move to last frame before stop\n   */\n  stopAnimation: function (forwardToLast) {\n    var animators = this.animators;\n    var len = animators.length;\n\n    for (var i = 0; i < len; i++) {\n      animators[i].stop(forwardToLast);\n    }\n\n    animators.length = 0;\n    return this;\n  },\n\n  /**\n   * Caution: this method will stop previous animation.\n   * So do not use this method to one element twice before\n   * animation starts, unless you know what you are doing.\n   * @param {Object} target\n   * @param {number} [time=500] Time in ms\n   * @param {string} [easing='linear']\n   * @param {number} [delay=0]\n   * @param {Function} [callback]\n   * @param {Function} [forceAnimate] Prevent stop animation and callback\n   *        immediently when target values are the same as current values.\n   *\n   * @example\n   *  // Animate position\n   *  el.animateTo({\n   *      position: [10, 10]\n   *  }, function () { // done })\n   *\n   *  // Animate shape, style and position in 100ms, delayed 100ms, with cubicOut easing\n   *  el.animateTo({\n   *      shape: {\n   *          width: 500\n   *      },\n   *      style: {\n   *          fill: 'red'\n   *      }\n   *      position: [10, 10]\n   *  }, 100, 100, 'cubicOut', function () { // done })\n   */\n  // TODO Return animation key\n  animateTo: function (target, time, delay, easing, callback, forceAnimate) {\n    // animateTo(target, time, easing, callback);\n    if (isString(delay)) {\n      callback = easing;\n      easing = delay;\n      delay = 0;\n    } // animateTo(target, time, delay, callback);\n    else if (isFunction(easing)) {\n        callback = easing;\n        easing = 'linear';\n        delay = 0;\n      } // animateTo(target, time, callback);\n      else if (isFunction(delay)) {\n          callback = delay;\n          delay = 0;\n        } // animateTo(target, callback)\n        else if (isFunction(time)) {\n            callback = time;\n            time = 500;\n          } // animateTo(target)\n          else if (!time) {\n              time = 500;\n            } // Stop all previous animations\n\n\n    this.stopAnimation();\n\n    this._animateToShallow('', this, target, time, delay); // Animators may be removed immediately after start\n    // if there is nothing to animate\n\n\n    var animators = this.animators.slice();\n    var count = animators.length;\n\n    function done() {\n      count--;\n\n      if (!count) {\n        callback && callback();\n      }\n    } // No animators. This should be checked before animators[i].start(),\n    // because 'done' may be executed immediately if no need to animate.\n\n\n    if (!count) {\n      callback && callback();\n    } // Start after all animators created\n    // Incase any animator is done immediately when all animation properties are not changed\n\n\n    for (var i = 0; i < animators.length; i++) {\n      animators[i].done(done).start(easing, forceAnimate);\n    }\n  },\n\n  /**\n   * @private\n   * @param {string} path=''\n   * @param {Object} source=this\n   * @param {Object} target\n   * @param {number} [time=500]\n   * @param {number} [delay=0]\n   *\n   * @example\n   *  // Animate position\n   *  el._animateToShallow({\n   *      position: [10, 10]\n   *  })\n   *\n   *  // Animate shape, style and position in 100ms, delayed 100ms\n   *  el._animateToShallow({\n   *      shape: {\n   *          width: 500\n   *      },\n   *      style: {\n   *          fill: 'red'\n   *      }\n   *      position: [10, 10]\n   *  }, 100, 100)\n   */\n  _animateToShallow: function (path, source, target, time, delay) {\n    var objShallow = {};\n    var propertyCount = 0;\n\n    for (var name in target) {\n      if (!target.hasOwnProperty(name)) {\n        continue;\n      }\n\n      if (source[name] != null) {\n        if (isObject(target[name]) && !isArrayLike(target[name])) {\n          this._animateToShallow(path ? path + '.' + name : name, source[name], target[name], time, delay);\n        } else {\n          objShallow[name] = target[name];\n          propertyCount++;\n        }\n      } else if (target[name] != null) {\n        // Attr directly if not has property\n        // FIXME, if some property not needed for element ?\n        if (!path) {\n          this.attr(name, target[name]);\n        } else {\n          // Shape or style\n          var props = {};\n          props[path] = {};\n          props[path][name] = target[name];\n          this.attr(props);\n        }\n      }\n    }\n\n    if (propertyCount > 0) {\n      this.animate(path, false).when(time == null ? 500 : time, objShallow).delay(delay || 0);\n    }\n\n    return this;\n  }\n};\nvar _default = Animatable;\nmodule.exports = _default;","map":{"version":3,"sources":["/home/martin/Escritorio/Taller de Integracion/Tarea3-TallerDeIntegracion/node_modules/react-echarts/node_modules/zrender/lib/mixin/Animatable.js"],"names":["Animator","require","log","_util","isString","isFunction","isObject","isArrayLike","indexOf","Animatable","animators","prototype","constructor","animate","path","loop","target","animatingShape","el","zr","__zr","pathSplitted","split","prop","i","l","length","id","animator","during","dirty","done","splice","push","animation","addAnimator","stopAnimation","forwardToLast","len","stop","animateTo","time","delay","easing","callback","forceAnimate","_animateToShallow","slice","count","start","source","objShallow","propertyCount","name","hasOwnProperty","attr","props","when","_default","module","exports"],"mappings":"AAAA,IAAIA,QAAQ,GAAGC,OAAO,CAAC,uBAAD,CAAtB;;AAEA,IAAIC,GAAG,GAAGD,OAAO,CAAC,aAAD,CAAjB;;AAEA,IAAIE,KAAK,GAAGF,OAAO,CAAC,cAAD,CAAnB;;AAEA,IAAIG,QAAQ,GAAGD,KAAK,CAACC,QAArB;AACA,IAAIC,UAAU,GAAGF,KAAK,CAACE,UAAvB;AACA,IAAIC,QAAQ,GAAGH,KAAK,CAACG,QAArB;AACA,IAAIC,WAAW,GAAGJ,KAAK,CAACI,WAAxB;AACA,IAAIC,OAAO,GAAGL,KAAK,CAACK,OAApB;AAEA;;;;;AAIA,IAAIC,UAAU,GAAG,YAAY;AAC3B;;;;AAIA,OAAKC,SAAL,GAAiB,EAAjB;AACD,CAND;;AAQAD,UAAU,CAACE,SAAX,GAAuB;AACrBC,EAAAA,WAAW,EAAEH,UADQ;;AAGrB;;;;;;;;;;;;AAYAI,EAAAA,OAAO,EAAE,UAAUC,IAAV,EAAgBC,IAAhB,EAAsB;AAC7B,QAAIC,MAAJ;AACA,QAAIC,cAAc,GAAG,KAArB;AACA,QAAIC,EAAE,GAAG,IAAT;AACA,QAAIC,EAAE,GAAG,KAAKC,IAAd;;AAEA,QAAIN,IAAJ,EAAU;AACR,UAAIO,YAAY,GAAGP,IAAI,CAACQ,KAAL,CAAW,GAAX,CAAnB;AACA,UAAIC,IAAI,GAAGL,EAAX,CAFQ,CAEO;;AAEfD,MAAAA,cAAc,GAAGI,YAAY,CAAC,CAAD,CAAZ,KAAoB,OAArC;;AAEA,WAAK,IAAIG,CAAC,GAAG,CAAR,EAAWC,CAAC,GAAGJ,YAAY,CAACK,MAAjC,EAAyCF,CAAC,GAAGC,CAA7C,EAAgDD,CAAC,EAAjD,EAAqD;AACnD,YAAI,CAACD,IAAL,EAAW;AACT;AACD;;AAEDA,QAAAA,IAAI,GAAGA,IAAI,CAACF,YAAY,CAACG,CAAD,CAAb,CAAX;AACD;;AAED,UAAID,IAAJ,EAAU;AACRP,QAAAA,MAAM,GAAGO,IAAT;AACD;AACF,KAjBD,MAiBO;AACLP,MAAAA,MAAM,GAAGE,EAAT;AACD;;AAED,QAAI,CAACF,MAAL,EAAa;AACXd,MAAAA,GAAG,CAAC,eAAeY,IAAf,GAAsB,8BAAtB,GAAuDI,EAAE,CAACS,EAA3D,CAAH;AACA;AACD;;AAED,QAAIjB,SAAS,GAAGQ,EAAE,CAACR,SAAnB;AACA,QAAIkB,QAAQ,GAAG,IAAI5B,QAAJ,CAAagB,MAAb,EAAqBD,IAArB,CAAf;AACAa,IAAAA,QAAQ,CAACC,MAAT,CAAgB,UAAUb,MAAV,EAAkB;AAChCE,MAAAA,EAAE,CAACY,KAAH,CAASb,cAAT;AACD,KAFD,EAEGc,IAFH,CAEQ,YAAY;AAClB;AACArB,MAAAA,SAAS,CAACsB,MAAV,CAAiBxB,OAAO,CAACE,SAAD,EAAYkB,QAAZ,CAAxB,EAA+C,CAA/C;AACD,KALD;AAMAlB,IAAAA,SAAS,CAACuB,IAAV,CAAeL,QAAf,EAxC6B,CAwCH;;AAE1B,QAAIT,EAAJ,EAAQ;AACNA,MAAAA,EAAE,CAACe,SAAH,CAAaC,WAAb,CAAyBP,QAAzB;AACD;;AAED,WAAOA,QAAP;AACD,GA9DoB;;AAgErB;;;;AAIAQ,EAAAA,aAAa,EAAE,UAAUC,aAAV,EAAyB;AACtC,QAAI3B,SAAS,GAAG,KAAKA,SAArB;AACA,QAAI4B,GAAG,GAAG5B,SAAS,CAACgB,MAApB;;AAEA,SAAK,IAAIF,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGc,GAApB,EAAyBd,CAAC,EAA1B,EAA8B;AAC5Bd,MAAAA,SAAS,CAACc,CAAD,CAAT,CAAae,IAAb,CAAkBF,aAAlB;AACD;;AAED3B,IAAAA,SAAS,CAACgB,MAAV,GAAmB,CAAnB;AACA,WAAO,IAAP;AACD,GA9EoB;;AAgFrB;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AA6BA;AACAc,EAAAA,SAAS,EAAE,UAAUxB,MAAV,EAAkByB,IAAlB,EAAwBC,KAAxB,EAA+BC,MAA/B,EAAuCC,QAAvC,EAAiDC,YAAjD,EAA+D;AACxE;AACA,QAAIzC,QAAQ,CAACsC,KAAD,CAAZ,EAAqB;AACnBE,MAAAA,QAAQ,GAAGD,MAAX;AACAA,MAAAA,MAAM,GAAGD,KAAT;AACAA,MAAAA,KAAK,GAAG,CAAR;AACD,KAJD,CAIE;AAJF,SAKK,IAAIrC,UAAU,CAACsC,MAAD,CAAd,EAAwB;AACzBC,QAAAA,QAAQ,GAAGD,MAAX;AACAA,QAAAA,MAAM,GAAG,QAAT;AACAD,QAAAA,KAAK,GAAG,CAAR;AACD,OAJE,CAID;AAJC,WAKE,IAAIrC,UAAU,CAACqC,KAAD,CAAd,EAAuB;AACxBE,UAAAA,QAAQ,GAAGF,KAAX;AACAA,UAAAA,KAAK,GAAG,CAAR;AACD,SAHE,CAGD;AAHC,aAIE,IAAIrC,UAAU,CAACoC,IAAD,CAAd,EAAsB;AACvBG,YAAAA,QAAQ,GAAGH,IAAX;AACAA,YAAAA,IAAI,GAAG,GAAP;AACD,WAHE,CAGD;AAHC,eAIE,IAAI,CAACA,IAAL,EAAW;AACZA,cAAAA,IAAI,GAAG,GAAP;AACD,aAtB+D,CAsB9D;;;AAGV,SAAKL,aAAL;;AAEA,SAAKU,iBAAL,CAAuB,EAAvB,EAA2B,IAA3B,EAAiC9B,MAAjC,EAAyCyB,IAAzC,EAA+CC,KAA/C,EA3BwE,CA2BjB;AACvD;;;AAGA,QAAIhC,SAAS,GAAG,KAAKA,SAAL,CAAeqC,KAAf,EAAhB;AACA,QAAIC,KAAK,GAAGtC,SAAS,CAACgB,MAAtB;;AAEA,aAASK,IAAT,GAAgB;AACdiB,MAAAA,KAAK;;AAEL,UAAI,CAACA,KAAL,EAAY;AACVJ,QAAAA,QAAQ,IAAIA,QAAQ,EAApB;AACD;AACF,KAxCuE,CAwCtE;AACF;;;AAGA,QAAI,CAACI,KAAL,EAAY;AACVJ,MAAAA,QAAQ,IAAIA,QAAQ,EAApB;AACD,KA9CuE,CA8CtE;AACF;;;AAGA,SAAK,IAAIpB,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGd,SAAS,CAACgB,MAA9B,EAAsCF,CAAC,EAAvC,EAA2C;AACzCd,MAAAA,SAAS,CAACc,CAAD,CAAT,CAAaO,IAAb,CAAkBA,IAAlB,EAAwBkB,KAAxB,CAA8BN,MAA9B,EAAsCE,YAAtC;AACD;AACF,GAnKoB;;AAqKrB;;;;;;;;;;;;;;;;;;;;;;;;;AAyBAC,EAAAA,iBAAiB,EAAE,UAAUhC,IAAV,EAAgBoC,MAAhB,EAAwBlC,MAAxB,EAAgCyB,IAAhC,EAAsCC,KAAtC,EAA6C;AAC9D,QAAIS,UAAU,GAAG,EAAjB;AACA,QAAIC,aAAa,GAAG,CAApB;;AAEA,SAAK,IAAIC,IAAT,IAAiBrC,MAAjB,EAAyB;AACvB,UAAI,CAACA,MAAM,CAACsC,cAAP,CAAsBD,IAAtB,CAAL,EAAkC;AAChC;AACD;;AAED,UAAIH,MAAM,CAACG,IAAD,CAAN,IAAgB,IAApB,EAA0B;AACxB,YAAI/C,QAAQ,CAACU,MAAM,CAACqC,IAAD,CAAP,CAAR,IAA0B,CAAC9C,WAAW,CAACS,MAAM,CAACqC,IAAD,CAAP,CAA1C,EAA0D;AACxD,eAAKP,iBAAL,CAAuBhC,IAAI,GAAGA,IAAI,GAAG,GAAP,GAAauC,IAAhB,GAAuBA,IAAlD,EAAwDH,MAAM,CAACG,IAAD,CAA9D,EAAsErC,MAAM,CAACqC,IAAD,CAA5E,EAAoFZ,IAApF,EAA0FC,KAA1F;AACD,SAFD,MAEO;AACLS,UAAAA,UAAU,CAACE,IAAD,CAAV,GAAmBrC,MAAM,CAACqC,IAAD,CAAzB;AACAD,UAAAA,aAAa;AACd;AACF,OAPD,MAOO,IAAIpC,MAAM,CAACqC,IAAD,CAAN,IAAgB,IAApB,EAA0B;AAC/B;AACA;AACA,YAAI,CAACvC,IAAL,EAAW;AACT,eAAKyC,IAAL,CAAUF,IAAV,EAAgBrC,MAAM,CAACqC,IAAD,CAAtB;AACD,SAFD,MAEO;AACL;AACA,cAAIG,KAAK,GAAG,EAAZ;AACAA,UAAAA,KAAK,CAAC1C,IAAD,CAAL,GAAc,EAAd;AACA0C,UAAAA,KAAK,CAAC1C,IAAD,CAAL,CAAYuC,IAAZ,IAAoBrC,MAAM,CAACqC,IAAD,CAA1B;AACA,eAAKE,IAAL,CAAUC,KAAV;AACD;AACF;AACF;;AAED,QAAIJ,aAAa,GAAG,CAApB,EAAuB;AACrB,WAAKvC,OAAL,CAAaC,IAAb,EAAmB,KAAnB,EAA0B2C,IAA1B,CAA+BhB,IAAI,IAAI,IAAR,GAAe,GAAf,GAAqBA,IAApD,EAA0DU,UAA1D,EAAsET,KAAtE,CAA4EA,KAAK,IAAI,CAArF;AACD;;AAED,WAAO,IAAP;AACD;AAlOoB,CAAvB;AAoOA,IAAIgB,QAAQ,GAAGjD,UAAf;AACAkD,MAAM,CAACC,OAAP,GAAiBF,QAAjB","sourcesContent":["var Animator = require(\"../animation/Animator\");\n\nvar log = require(\"../core/log\");\n\nvar _util = require(\"../core/util\");\n\nvar isString = _util.isString;\nvar isFunction = _util.isFunction;\nvar isObject = _util.isObject;\nvar isArrayLike = _util.isArrayLike;\nvar indexOf = _util.indexOf;\n\n/**\n * @alias modue:zrender/mixin/Animatable\n * @constructor\n */\nvar Animatable = function () {\n  /**\n   * @type {Array.<module:zrender/animation/Animator>}\n   * @readOnly\n   */\n  this.animators = [];\n};\n\nAnimatable.prototype = {\n  constructor: Animatable,\n\n  /**\n   * 动画\n   *\n   * @param {string} path The path to fetch value from object, like 'a.b.c'.\n   * @param {boolean} [loop] Whether to loop animation.\n   * @return {module:zrender/animation/Animator}\n   * @example:\n   *     el.animate('style', false)\n   *         .when(1000, {x: 10} )\n   *         .done(function(){ // Animation done })\n   *         .start()\n   */\n  animate: function (path, loop) {\n    var target;\n    var animatingShape = false;\n    var el = this;\n    var zr = this.__zr;\n\n    if (path) {\n      var pathSplitted = path.split('.');\n      var prop = el; // If animating shape\n\n      animatingShape = pathSplitted[0] === 'shape';\n\n      for (var i = 0, l = pathSplitted.length; i < l; i++) {\n        if (!prop) {\n          continue;\n        }\n\n        prop = prop[pathSplitted[i]];\n      }\n\n      if (prop) {\n        target = prop;\n      }\n    } else {\n      target = el;\n    }\n\n    if (!target) {\n      log('Property \"' + path + '\" is not existed in element ' + el.id);\n      return;\n    }\n\n    var animators = el.animators;\n    var animator = new Animator(target, loop);\n    animator.during(function (target) {\n      el.dirty(animatingShape);\n    }).done(function () {\n      // FIXME Animator will not be removed if use `Animator#stop` to stop animation\n      animators.splice(indexOf(animators, animator), 1);\n    });\n    animators.push(animator); // If animate after added to the zrender\n\n    if (zr) {\n      zr.animation.addAnimator(animator);\n    }\n\n    return animator;\n  },\n\n  /**\n   * 停止动画\n   * @param {boolean} forwardToLast If move to last frame before stop\n   */\n  stopAnimation: function (forwardToLast) {\n    var animators = this.animators;\n    var len = animators.length;\n\n    for (var i = 0; i < len; i++) {\n      animators[i].stop(forwardToLast);\n    }\n\n    animators.length = 0;\n    return this;\n  },\n\n  /**\n   * Caution: this method will stop previous animation.\n   * So do not use this method to one element twice before\n   * animation starts, unless you know what you are doing.\n   * @param {Object} target\n   * @param {number} [time=500] Time in ms\n   * @param {string} [easing='linear']\n   * @param {number} [delay=0]\n   * @param {Function} [callback]\n   * @param {Function} [forceAnimate] Prevent stop animation and callback\n   *        immediently when target values are the same as current values.\n   *\n   * @example\n   *  // Animate position\n   *  el.animateTo({\n   *      position: [10, 10]\n   *  }, function () { // done })\n   *\n   *  // Animate shape, style and position in 100ms, delayed 100ms, with cubicOut easing\n   *  el.animateTo({\n   *      shape: {\n   *          width: 500\n   *      },\n   *      style: {\n   *          fill: 'red'\n   *      }\n   *      position: [10, 10]\n   *  }, 100, 100, 'cubicOut', function () { // done })\n   */\n  // TODO Return animation key\n  animateTo: function (target, time, delay, easing, callback, forceAnimate) {\n    // animateTo(target, time, easing, callback);\n    if (isString(delay)) {\n      callback = easing;\n      easing = delay;\n      delay = 0;\n    } // animateTo(target, time, delay, callback);\n    else if (isFunction(easing)) {\n        callback = easing;\n        easing = 'linear';\n        delay = 0;\n      } // animateTo(target, time, callback);\n      else if (isFunction(delay)) {\n          callback = delay;\n          delay = 0;\n        } // animateTo(target, callback)\n        else if (isFunction(time)) {\n            callback = time;\n            time = 500;\n          } // animateTo(target)\n          else if (!time) {\n              time = 500;\n            } // Stop all previous animations\n\n\n    this.stopAnimation();\n\n    this._animateToShallow('', this, target, time, delay); // Animators may be removed immediately after start\n    // if there is nothing to animate\n\n\n    var animators = this.animators.slice();\n    var count = animators.length;\n\n    function done() {\n      count--;\n\n      if (!count) {\n        callback && callback();\n      }\n    } // No animators. This should be checked before animators[i].start(),\n    // because 'done' may be executed immediately if no need to animate.\n\n\n    if (!count) {\n      callback && callback();\n    } // Start after all animators created\n    // Incase any animator is done immediately when all animation properties are not changed\n\n\n    for (var i = 0; i < animators.length; i++) {\n      animators[i].done(done).start(easing, forceAnimate);\n    }\n  },\n\n  /**\n   * @private\n   * @param {string} path=''\n   * @param {Object} source=this\n   * @param {Object} target\n   * @param {number} [time=500]\n   * @param {number} [delay=0]\n   *\n   * @example\n   *  // Animate position\n   *  el._animateToShallow({\n   *      position: [10, 10]\n   *  })\n   *\n   *  // Animate shape, style and position in 100ms, delayed 100ms\n   *  el._animateToShallow({\n   *      shape: {\n   *          width: 500\n   *      },\n   *      style: {\n   *          fill: 'red'\n   *      }\n   *      position: [10, 10]\n   *  }, 100, 100)\n   */\n  _animateToShallow: function (path, source, target, time, delay) {\n    var objShallow = {};\n    var propertyCount = 0;\n\n    for (var name in target) {\n      if (!target.hasOwnProperty(name)) {\n        continue;\n      }\n\n      if (source[name] != null) {\n        if (isObject(target[name]) && !isArrayLike(target[name])) {\n          this._animateToShallow(path ? path + '.' + name : name, source[name], target[name], time, delay);\n        } else {\n          objShallow[name] = target[name];\n          propertyCount++;\n        }\n      } else if (target[name] != null) {\n        // Attr directly if not has property\n        // FIXME, if some property not needed for element ?\n        if (!path) {\n          this.attr(name, target[name]);\n        } else {\n          // Shape or style\n          var props = {};\n          props[path] = {};\n          props[path][name] = target[name];\n          this.attr(props);\n        }\n      }\n    }\n\n    if (propertyCount > 0) {\n      this.animate(path, false).when(time == null ? 500 : time, objShallow).delay(delay || 0);\n    }\n\n    return this;\n  }\n};\nvar _default = Animatable;\nmodule.exports = _default;"]},"metadata":{},"sourceType":"script"}