{"ast":null,"code":"var completeDimensions = require(\"../../data/helper/completeDimensions\");\n\nvar SeriesModel = require(\"../../model/Series\");\n\nvar List = require(\"../../data/List\");\n\nvar zrUtil = require(\"zrender/lib/core/util\");\n\nvar _format = require(\"../../util/format\");\n\nvar encodeHTML = _format.encodeHTML;\n\nvar nest = require(\"../../util/array/nest\");\n/**\n * @file  Define the themeRiver view's series model\n * @author Deqing Li(annong035@gmail.com)\n */\n\n\nvar DATA_NAME_INDEX = 2;\nvar ThemeRiverSeries = SeriesModel.extend({\n  type: 'series.themeRiver',\n  dependencies: ['singleAxis'],\n\n  /**\n   * @readOnly\n   * @type {module:zrender/core/util#HashMap}\n   */\n  nameMap: null,\n\n  /**\n   * @override\n   */\n  init: function (option) {\n    ThemeRiverSeries.superApply(this, 'init', arguments); // Put this function here is for the sake of consistency of code style.\n    // Enable legend selection for each data item\n    // Use a function instead of direct access because data reference may changed\n\n    this.legendDataProvider = function () {\n      return this.getRawData();\n    };\n  },\n\n  /**\n   * If there is no value of a certain point in the time for some event,set it value to 0.\n   *\n   * @param {Array} data  initial data in the option\n   * @return {Array}\n   */\n  fixData: function (data) {\n    var rawDataLength = data.length; // grouped data by name\n\n    var dataByName = nest().key(function (dataItem) {\n      return dataItem[2];\n    }).entries(data); // data group in each layer\n\n    var layData = zrUtil.map(dataByName, function (d) {\n      return {\n        name: d.key,\n        dataList: d.values\n      };\n    });\n    var layerNum = layData.length;\n    var largestLayer = -1;\n    var index = -1;\n\n    for (var i = 0; i < layerNum; ++i) {\n      var len = layData[i].dataList.length;\n\n      if (len > largestLayer) {\n        largestLayer = len;\n        index = i;\n      }\n    }\n\n    for (var k = 0; k < layerNum; ++k) {\n      if (k === index) {\n        continue;\n      }\n\n      var name = layData[k].name;\n\n      for (var j = 0; j < largestLayer; ++j) {\n        var timeValue = layData[index].dataList[j][0];\n        var length = layData[k].dataList.length;\n        var keyIndex = -1;\n\n        for (var l = 0; l < length; ++l) {\n          var value = layData[k].dataList[l][0];\n\n          if (value === timeValue) {\n            keyIndex = l;\n            break;\n          }\n        }\n\n        if (keyIndex === -1) {\n          data[rawDataLength] = [];\n          data[rawDataLength][0] = timeValue;\n          data[rawDataLength][1] = 0;\n          data[rawDataLength][2] = name;\n          rawDataLength++;\n        }\n      }\n    }\n\n    return data;\n  },\n\n  /**\n   * @override\n   * @param  {Object} option  the initial option that user gived\n   * @param  {module:echarts/model/Model} ecModel  the model object for themeRiver option\n   * @return {module:echarts/data/List}\n   */\n  getInitialData: function (option, ecModel) {\n    var dimensions = [];\n    var singleAxisModel = ecModel.queryComponents({\n      mainType: 'singleAxis',\n      index: this.get('singleAxisIndex'),\n      id: this.get('singleAxisId')\n    })[0];\n    var axisType = singleAxisModel.get('type');\n    dimensions = [{\n      name: 'time',\n      // FIXME common?\n      type: axisType === 'category' ? 'ordinal' : axisType === 'time' ? 'time' : 'float'\n    }, {\n      name: 'value',\n      type: 'float'\n    }, {\n      name: 'name',\n      type: 'ordinal'\n    }]; // filter the data item with the value of label is undefined\n\n    var filterData = zrUtil.filter(option.data, function (dataItem) {\n      return dataItem[2] !== undefined;\n    });\n    var data = this.fixData(filterData || []);\n    var nameList = [];\n    var nameMap = this.nameMap = zrUtil.createHashMap();\n    var count = 0;\n\n    for (var i = 0; i < data.length; ++i) {\n      nameList.push(data[i][DATA_NAME_INDEX]);\n\n      if (!nameMap.get(data[i][DATA_NAME_INDEX])) {\n        nameMap.set(data[i][DATA_NAME_INDEX], count);\n        count++;\n      }\n    }\n\n    dimensions = completeDimensions(dimensions, data);\n    var list = new List(dimensions, this);\n    list.initData(data, nameList);\n    return list;\n  },\n\n  /**\n   * Used by single coordinate\n   *\n   * @param {string} axisDim  the dimension for single coordinate\n   * @return {Array.<string> } specified dimensions on the axis.\n   */\n  coordDimToDataDim: function (axisDim) {\n    return ['time'];\n  },\n\n  /**\n   * The raw data is divided into multiple layers and each layer\n   *     has same name.\n   *\n   * @return {Array.<Array.<number>>}\n   */\n  getLayerSeries: function () {\n    var data = this.getData();\n    var lenCount = data.count();\n    var indexArr = [];\n\n    for (var i = 0; i < lenCount; ++i) {\n      indexArr[i] = i;\n    } // data group by name\n\n\n    var dataByName = nest().key(function (index) {\n      return data.get('name', index);\n    }).entries(indexArr);\n    var layerSeries = zrUtil.map(dataByName, function (d) {\n      return {\n        name: d.key,\n        indices: d.values\n      };\n    });\n\n    for (var j = 0; j < layerSeries.length; ++j) {\n      layerSeries[j].indices.sort(comparer);\n    }\n\n    function comparer(index1, index2) {\n      return data.get('time', index1) - data.get('time', index2);\n    }\n\n    return layerSeries;\n  },\n\n  /**\n   * Get data indices for show tooltip content\n   *\n   * @param {Array.<string>|string} dim  single coordinate dimension\n   * @param {number} value axis value\n   * @param {module:echarts/coord/single/SingleAxis} baseAxis  single Axis used\n   *     the themeRiver.\n   * @return {Object} {dataIndices, nestestValue}\n   */\n  getAxisTooltipData: function (dim, value, baseAxis) {\n    if (!zrUtil.isArray(dim)) {\n      dim = dim ? [dim] : [];\n    }\n\n    var data = this.getData();\n    var layerSeries = this.getLayerSeries();\n    var indices = [];\n    var layerNum = layerSeries.length;\n    var nestestValue;\n\n    for (var i = 0; i < layerNum; ++i) {\n      var minDist = Number.MAX_VALUE;\n      var nearestIdx = -1;\n      var pointNum = layerSeries[i].indices.length;\n\n      for (var j = 0; j < pointNum; ++j) {\n        var theValue = data.get(dim[0], layerSeries[i].indices[j]);\n        var dist = Math.abs(theValue - value);\n\n        if (dist <= minDist) {\n          nestestValue = theValue;\n          minDist = dist;\n          nearestIdx = layerSeries[i].indices[j];\n        }\n      }\n\n      indices.push(nearestIdx);\n    }\n\n    return {\n      dataIndices: indices,\n      nestestValue: nestestValue\n    };\n  },\n\n  /**\n   * @override\n   * @param {number} dataIndex  index of data\n   */\n  formatTooltip: function (dataIndex) {\n    var data = this.getData();\n    var htmlName = data.get('name', dataIndex);\n    var htmlValue = data.get('value', dataIndex);\n\n    if (isNaN(htmlValue) || htmlValue == null) {\n      htmlValue = '-';\n    }\n\n    return encodeHTML(htmlName + ' : ' + htmlValue);\n  },\n  defaultOption: {\n    zlevel: 0,\n    z: 2,\n    coordinateSystem: 'singleAxis',\n    // gap in axis's orthogonal orientation\n    boundaryGap: ['10%', '10%'],\n    // legendHoverLink: true,\n    singleAxisIndex: 0,\n    animationEasing: 'linear',\n    label: {\n      normal: {\n        margin: 4,\n        textAlign: 'right',\n        show: true,\n        position: 'left',\n        color: '#000',\n        fontSize: 11\n      },\n      emphasis: {\n        show: true\n      }\n    }\n  }\n});\nvar _default = ThemeRiverSeries;\nmodule.exports = _default;","map":{"version":3,"sources":["/home/martin/Escritorio/Taller de Integracion/Tarea3-TallerDeIntegracion/node_modules/react-echarts/node_modules/echarts/lib/chart/themeRiver/ThemeRiverSeries.js"],"names":["completeDimensions","require","SeriesModel","List","zrUtil","_format","encodeHTML","nest","DATA_NAME_INDEX","ThemeRiverSeries","extend","type","dependencies","nameMap","init","option","superApply","arguments","legendDataProvider","getRawData","fixData","data","rawDataLength","length","dataByName","key","dataItem","entries","layData","map","d","name","dataList","values","layerNum","largestLayer","index","i","len","k","j","timeValue","keyIndex","l","value","getInitialData","ecModel","dimensions","singleAxisModel","queryComponents","mainType","get","id","axisType","filterData","filter","undefined","nameList","createHashMap","count","push","set","list","initData","coordDimToDataDim","axisDim","getLayerSeries","getData","lenCount","indexArr","layerSeries","indices","sort","comparer","index1","index2","getAxisTooltipData","dim","baseAxis","isArray","nestestValue","minDist","Number","MAX_VALUE","nearestIdx","pointNum","theValue","dist","Math","abs","dataIndices","formatTooltip","dataIndex","htmlName","htmlValue","isNaN","defaultOption","zlevel","z","coordinateSystem","boundaryGap","singleAxisIndex","animationEasing","label","normal","margin","textAlign","show","position","color","fontSize","emphasis","_default","module","exports"],"mappings":"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","sourcesContent":["var completeDimensions = require(\"../../data/helper/completeDimensions\");\n\nvar SeriesModel = require(\"../../model/Series\");\n\nvar List = require(\"../../data/List\");\n\nvar zrUtil = require(\"zrender/lib/core/util\");\n\nvar _format = require(\"../../util/format\");\n\nvar encodeHTML = _format.encodeHTML;\n\nvar nest = require(\"../../util/array/nest\");\n\n/**\n * @file  Define the themeRiver view's series model\n * @author Deqing Li(annong035@gmail.com)\n */\nvar DATA_NAME_INDEX = 2;\nvar ThemeRiverSeries = SeriesModel.extend({\n  type: 'series.themeRiver',\n  dependencies: ['singleAxis'],\n\n  /**\n   * @readOnly\n   * @type {module:zrender/core/util#HashMap}\n   */\n  nameMap: null,\n\n  /**\n   * @override\n   */\n  init: function (option) {\n    ThemeRiverSeries.superApply(this, 'init', arguments); // Put this function here is for the sake of consistency of code style.\n    // Enable legend selection for each data item\n    // Use a function instead of direct access because data reference may changed\n\n    this.legendDataProvider = function () {\n      return this.getRawData();\n    };\n  },\n\n  /**\n   * If there is no value of a certain point in the time for some event,set it value to 0.\n   *\n   * @param {Array} data  initial data in the option\n   * @return {Array}\n   */\n  fixData: function (data) {\n    var rawDataLength = data.length; // grouped data by name\n\n    var dataByName = nest().key(function (dataItem) {\n      return dataItem[2];\n    }).entries(data); // data group in each layer\n\n    var layData = zrUtil.map(dataByName, function (d) {\n      return {\n        name: d.key,\n        dataList: d.values\n      };\n    });\n    var layerNum = layData.length;\n    var largestLayer = -1;\n    var index = -1;\n\n    for (var i = 0; i < layerNum; ++i) {\n      var len = layData[i].dataList.length;\n\n      if (len > largestLayer) {\n        largestLayer = len;\n        index = i;\n      }\n    }\n\n    for (var k = 0; k < layerNum; ++k) {\n      if (k === index) {\n        continue;\n      }\n\n      var name = layData[k].name;\n\n      for (var j = 0; j < largestLayer; ++j) {\n        var timeValue = layData[index].dataList[j][0];\n        var length = layData[k].dataList.length;\n        var keyIndex = -1;\n\n        for (var l = 0; l < length; ++l) {\n          var value = layData[k].dataList[l][0];\n\n          if (value === timeValue) {\n            keyIndex = l;\n            break;\n          }\n        }\n\n        if (keyIndex === -1) {\n          data[rawDataLength] = [];\n          data[rawDataLength][0] = timeValue;\n          data[rawDataLength][1] = 0;\n          data[rawDataLength][2] = name;\n          rawDataLength++;\n        }\n      }\n    }\n\n    return data;\n  },\n\n  /**\n   * @override\n   * @param  {Object} option  the initial option that user gived\n   * @param  {module:echarts/model/Model} ecModel  the model object for themeRiver option\n   * @return {module:echarts/data/List}\n   */\n  getInitialData: function (option, ecModel) {\n    var dimensions = [];\n    var singleAxisModel = ecModel.queryComponents({\n      mainType: 'singleAxis',\n      index: this.get('singleAxisIndex'),\n      id: this.get('singleAxisId')\n    })[0];\n    var axisType = singleAxisModel.get('type');\n    dimensions = [{\n      name: 'time',\n      // FIXME common?\n      type: axisType === 'category' ? 'ordinal' : axisType === 'time' ? 'time' : 'float'\n    }, {\n      name: 'value',\n      type: 'float'\n    }, {\n      name: 'name',\n      type: 'ordinal'\n    }]; // filter the data item with the value of label is undefined\n\n    var filterData = zrUtil.filter(option.data, function (dataItem) {\n      return dataItem[2] !== undefined;\n    });\n    var data = this.fixData(filterData || []);\n    var nameList = [];\n    var nameMap = this.nameMap = zrUtil.createHashMap();\n    var count = 0;\n\n    for (var i = 0; i < data.length; ++i) {\n      nameList.push(data[i][DATA_NAME_INDEX]);\n\n      if (!nameMap.get(data[i][DATA_NAME_INDEX])) {\n        nameMap.set(data[i][DATA_NAME_INDEX], count);\n        count++;\n      }\n    }\n\n    dimensions = completeDimensions(dimensions, data);\n    var list = new List(dimensions, this);\n    list.initData(data, nameList);\n    return list;\n  },\n\n  /**\n   * Used by single coordinate\n   *\n   * @param {string} axisDim  the dimension for single coordinate\n   * @return {Array.<string> } specified dimensions on the axis.\n   */\n  coordDimToDataDim: function (axisDim) {\n    return ['time'];\n  },\n\n  /**\n   * The raw data is divided into multiple layers and each layer\n   *     has same name.\n   *\n   * @return {Array.<Array.<number>>}\n   */\n  getLayerSeries: function () {\n    var data = this.getData();\n    var lenCount = data.count();\n    var indexArr = [];\n\n    for (var i = 0; i < lenCount; ++i) {\n      indexArr[i] = i;\n    } // data group by name\n\n\n    var dataByName = nest().key(function (index) {\n      return data.get('name', index);\n    }).entries(indexArr);\n    var layerSeries = zrUtil.map(dataByName, function (d) {\n      return {\n        name: d.key,\n        indices: d.values\n      };\n    });\n\n    for (var j = 0; j < layerSeries.length; ++j) {\n      layerSeries[j].indices.sort(comparer);\n    }\n\n    function comparer(index1, index2) {\n      return data.get('time', index1) - data.get('time', index2);\n    }\n\n    return layerSeries;\n  },\n\n  /**\n   * Get data indices for show tooltip content\n   *\n   * @param {Array.<string>|string} dim  single coordinate dimension\n   * @param {number} value axis value\n   * @param {module:echarts/coord/single/SingleAxis} baseAxis  single Axis used\n   *     the themeRiver.\n   * @return {Object} {dataIndices, nestestValue}\n   */\n  getAxisTooltipData: function (dim, value, baseAxis) {\n    if (!zrUtil.isArray(dim)) {\n      dim = dim ? [dim] : [];\n    }\n\n    var data = this.getData();\n    var layerSeries = this.getLayerSeries();\n    var indices = [];\n    var layerNum = layerSeries.length;\n    var nestestValue;\n\n    for (var i = 0; i < layerNum; ++i) {\n      var minDist = Number.MAX_VALUE;\n      var nearestIdx = -1;\n      var pointNum = layerSeries[i].indices.length;\n\n      for (var j = 0; j < pointNum; ++j) {\n        var theValue = data.get(dim[0], layerSeries[i].indices[j]);\n        var dist = Math.abs(theValue - value);\n\n        if (dist <= minDist) {\n          nestestValue = theValue;\n          minDist = dist;\n          nearestIdx = layerSeries[i].indices[j];\n        }\n      }\n\n      indices.push(nearestIdx);\n    }\n\n    return {\n      dataIndices: indices,\n      nestestValue: nestestValue\n    };\n  },\n\n  /**\n   * @override\n   * @param {number} dataIndex  index of data\n   */\n  formatTooltip: function (dataIndex) {\n    var data = this.getData();\n    var htmlName = data.get('name', dataIndex);\n    var htmlValue = data.get('value', dataIndex);\n\n    if (isNaN(htmlValue) || htmlValue == null) {\n      htmlValue = '-';\n    }\n\n    return encodeHTML(htmlName + ' : ' + htmlValue);\n  },\n  defaultOption: {\n    zlevel: 0,\n    z: 2,\n    coordinateSystem: 'singleAxis',\n    // gap in axis's orthogonal orientation\n    boundaryGap: ['10%', '10%'],\n    // legendHoverLink: true,\n    singleAxisIndex: 0,\n    animationEasing: 'linear',\n    label: {\n      normal: {\n        margin: 4,\n        textAlign: 'right',\n        show: true,\n        position: 'left',\n        color: '#000',\n        fontSize: 11\n      },\n      emphasis: {\n        show: true\n      }\n    }\n  }\n});\nvar _default = ThemeRiverSeries;\nmodule.exports = _default;"]},"metadata":{},"sourceType":"script"}