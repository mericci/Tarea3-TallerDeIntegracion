{"ast":null,"code":"var numberUtil = require(\"../util/number\");\n/**\n * For testable.\n */\n\n\nvar roundNumber = numberUtil.round;\n/**\n * @param {Array.<number>} extent Both extent[0] and extent[1] should be valid number.\n *                                Should be extent[0] < extent[1].\n * @param {number} splitNumber splitNumber should be >= 1.\n * @param {number} [minInterval]\n * @param {number} [maxInterval]\n * @return {Object} {interval, intervalPrecision, niceTickExtent}\n */\n\nfunction intervalScaleNiceTicks(extent, splitNumber, minInterval, maxInterval) {\n  var result = {};\n  var span = extent[1] - extent[0];\n  var interval = result.interval = numberUtil.nice(span / splitNumber, true);\n\n  if (minInterval != null && interval < minInterval) {\n    interval = result.interval = minInterval;\n  }\n\n  if (maxInterval != null && interval > maxInterval) {\n    interval = result.interval = maxInterval;\n  } // Tow more digital for tick.\n\n\n  var precision = result.intervalPrecision = getIntervalPrecision(interval); // Niced extent inside original extent\n\n  var niceTickExtent = result.niceTickExtent = [roundNumber(Math.ceil(extent[0] / interval) * interval, precision), roundNumber(Math.floor(extent[1] / interval) * interval, precision)];\n  fixExtent(niceTickExtent, extent);\n  return result;\n}\n/**\n * @param {number} interval\n * @return {number} interval precision\n */\n\n\nfunction getIntervalPrecision(interval) {\n  // Tow more digital for tick.\n  return numberUtil.getPrecisionSafe(interval) + 2;\n}\n\nfunction clamp(niceTickExtent, idx, extent) {\n  niceTickExtent[idx] = Math.max(Math.min(niceTickExtent[idx], extent[1]), extent[0]);\n} // In some cases (e.g., splitNumber is 1), niceTickExtent may be out of extent.\n\n\nfunction fixExtent(niceTickExtent, extent) {\n  !isFinite(niceTickExtent[0]) && (niceTickExtent[0] = extent[0]);\n  !isFinite(niceTickExtent[1]) && (niceTickExtent[1] = extent[1]);\n  clamp(niceTickExtent, 0, extent);\n  clamp(niceTickExtent, 1, extent);\n\n  if (niceTickExtent[0] > niceTickExtent[1]) {\n    niceTickExtent[0] = niceTickExtent[1];\n  }\n}\n\nfunction intervalScaleGetTicks(interval, extent, niceTickExtent, intervalPrecision) {\n  var ticks = []; // If interval is 0, return [];\n\n  if (!interval) {\n    return ticks;\n  } // Consider this case: using dataZoom toolbox, zoom and zoom.\n\n\n  var safeLimit = 10000;\n\n  if (extent[0] < niceTickExtent[0]) {\n    ticks.push(extent[0]);\n  }\n\n  var tick = niceTickExtent[0];\n\n  while (tick <= niceTickExtent[1]) {\n    ticks.push(tick); // Avoid rounding error\n\n    tick = roundNumber(tick + interval, intervalPrecision);\n\n    if (tick === ticks[ticks.length - 1]) {\n      // Consider out of safe float point, e.g.,\n      // -3711126.9907707 + 2e-10 === -3711126.9907707\n      break;\n    }\n\n    if (ticks.length > safeLimit) {\n      return [];\n    }\n  } // Consider this case: the last item of ticks is smaller\n  // than niceTickExtent[1] and niceTickExtent[1] === extent[1].\n\n\n  if (extent[1] > (ticks.length ? ticks[ticks.length - 1] : niceTickExtent[1])) {\n    ticks.push(extent[1]);\n  }\n\n  return ticks;\n}\n\nexports.intervalScaleNiceTicks = intervalScaleNiceTicks;\nexports.getIntervalPrecision = getIntervalPrecision;\nexports.fixExtent = fixExtent;\nexports.intervalScaleGetTicks = intervalScaleGetTicks;","map":{"version":3,"sources":["/home/martin/Escritorio/Taller de Integracion/Tarea3-TallerDeIntegracion/node_modules/react-echarts/node_modules/echarts/lib/scale/helper.js"],"names":["numberUtil","require","roundNumber","round","intervalScaleNiceTicks","extent","splitNumber","minInterval","maxInterval","result","span","interval","nice","precision","intervalPrecision","getIntervalPrecision","niceTickExtent","Math","ceil","floor","fixExtent","getPrecisionSafe","clamp","idx","max","min","isFinite","intervalScaleGetTicks","ticks","safeLimit","push","tick","length","exports"],"mappings":"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","sourcesContent":["var numberUtil = require(\"../util/number\");\n\n/**\n * For testable.\n */\nvar roundNumber = numberUtil.round;\n/**\n * @param {Array.<number>} extent Both extent[0] and extent[1] should be valid number.\n *                                Should be extent[0] < extent[1].\n * @param {number} splitNumber splitNumber should be >= 1.\n * @param {number} [minInterval]\n * @param {number} [maxInterval]\n * @return {Object} {interval, intervalPrecision, niceTickExtent}\n */\n\nfunction intervalScaleNiceTicks(extent, splitNumber, minInterval, maxInterval) {\n  var result = {};\n  var span = extent[1] - extent[0];\n  var interval = result.interval = numberUtil.nice(span / splitNumber, true);\n\n  if (minInterval != null && interval < minInterval) {\n    interval = result.interval = minInterval;\n  }\n\n  if (maxInterval != null && interval > maxInterval) {\n    interval = result.interval = maxInterval;\n  } // Tow more digital for tick.\n\n\n  var precision = result.intervalPrecision = getIntervalPrecision(interval); // Niced extent inside original extent\n\n  var niceTickExtent = result.niceTickExtent = [roundNumber(Math.ceil(extent[0] / interval) * interval, precision), roundNumber(Math.floor(extent[1] / interval) * interval, precision)];\n  fixExtent(niceTickExtent, extent);\n  return result;\n}\n/**\n * @param {number} interval\n * @return {number} interval precision\n */\n\n\nfunction getIntervalPrecision(interval) {\n  // Tow more digital for tick.\n  return numberUtil.getPrecisionSafe(interval) + 2;\n}\n\nfunction clamp(niceTickExtent, idx, extent) {\n  niceTickExtent[idx] = Math.max(Math.min(niceTickExtent[idx], extent[1]), extent[0]);\n} // In some cases (e.g., splitNumber is 1), niceTickExtent may be out of extent.\n\n\nfunction fixExtent(niceTickExtent, extent) {\n  !isFinite(niceTickExtent[0]) && (niceTickExtent[0] = extent[0]);\n  !isFinite(niceTickExtent[1]) && (niceTickExtent[1] = extent[1]);\n  clamp(niceTickExtent, 0, extent);\n  clamp(niceTickExtent, 1, extent);\n\n  if (niceTickExtent[0] > niceTickExtent[1]) {\n    niceTickExtent[0] = niceTickExtent[1];\n  }\n}\n\nfunction intervalScaleGetTicks(interval, extent, niceTickExtent, intervalPrecision) {\n  var ticks = []; // If interval is 0, return [];\n\n  if (!interval) {\n    return ticks;\n  } // Consider this case: using dataZoom toolbox, zoom and zoom.\n\n\n  var safeLimit = 10000;\n\n  if (extent[0] < niceTickExtent[0]) {\n    ticks.push(extent[0]);\n  }\n\n  var tick = niceTickExtent[0];\n\n  while (tick <= niceTickExtent[1]) {\n    ticks.push(tick); // Avoid rounding error\n\n    tick = roundNumber(tick + interval, intervalPrecision);\n\n    if (tick === ticks[ticks.length - 1]) {\n      // Consider out of safe float point, e.g.,\n      // -3711126.9907707 + 2e-10 === -3711126.9907707\n      break;\n    }\n\n    if (ticks.length > safeLimit) {\n      return [];\n    }\n  } // Consider this case: the last item of ticks is smaller\n  // than niceTickExtent[1] and niceTickExtent[1] === extent[1].\n\n\n  if (extent[1] > (ticks.length ? ticks[ticks.length - 1] : niceTickExtent[1])) {\n    ticks.push(extent[1]);\n  }\n\n  return ticks;\n}\n\nexports.intervalScaleNiceTicks = intervalScaleNiceTicks;\nexports.getIntervalPrecision = getIntervalPrecision;\nexports.fixExtent = fixExtent;\nexports.intervalScaleGetTicks = intervalScaleGetTicks;"]},"metadata":{},"sourceType":"script"}