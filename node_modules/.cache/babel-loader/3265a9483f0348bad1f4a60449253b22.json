{"ast":null,"code":"var layout = require(\"../../util/layout\");\n\nvar nest = require(\"../../util/array/nest\");\n\nvar zrUtil = require(\"zrender/lib/core/util\");\n/**\n * @file The layout algorithm of sankey view\n * @author  Deqing Li(annong035@gmail.com)\n */\n\n\nfunction _default(ecModel, api, payload) {\n  ecModel.eachSeriesByType('sankey', function (seriesModel) {\n    var nodeWidth = seriesModel.get('nodeWidth');\n    var nodeGap = seriesModel.get('nodeGap');\n    var layoutInfo = getViewRect(seriesModel, api);\n    seriesModel.layoutInfo = layoutInfo;\n    var width = layoutInfo.width;\n    var height = layoutInfo.height;\n    var graph = seriesModel.getGraph();\n    var nodes = graph.nodes;\n    var edges = graph.edges;\n    computeNodeValues(nodes);\n    var filteredNodes = zrUtil.filter(nodes, function (node) {\n      return node.getLayout().value === 0;\n    });\n    var iterations = filteredNodes.length !== 0 ? 0 : seriesModel.get('layoutIterations');\n    layoutSankey(nodes, edges, nodeWidth, nodeGap, width, height, iterations);\n  });\n}\n/**\n * Get the layout position of the whole view\n *\n * @param {module:echarts/model/Series} seriesModel  the model object of sankey series\n * @param {module:echarts/ExtensionAPI} api  provide the API list that the developer can call\n * @return {module:zrender/core/BoundingRect}  size of rect to draw the sankey view\n */\n\n\nfunction getViewRect(seriesModel, api) {\n  return layout.getLayoutRect(seriesModel.getBoxLayoutParams(), {\n    width: api.getWidth(),\n    height: api.getHeight()\n  });\n}\n\nfunction layoutSankey(nodes, edges, nodeWidth, nodeGap, width, height, iterations) {\n  computeNodeBreadths(nodes, nodeWidth, width);\n  computeNodeDepths(nodes, edges, height, nodeGap, iterations);\n  computeEdgeDepths(nodes);\n}\n/**\n * Compute the value of each node by summing the associated edge's value\n *\n * @param {module:echarts/data/Graph~Node} nodes  node of sankey view\n */\n\n\nfunction computeNodeValues(nodes) {\n  zrUtil.each(nodes, function (node) {\n    var value1 = sum(node.outEdges, getEdgeValue);\n    var value2 = sum(node.inEdges, getEdgeValue);\n    var value = Math.max(value1, value2);\n    node.setLayout({\n      value: value\n    }, true);\n  });\n}\n/**\n * Compute the x-position for each node\n *\n * @param {module:echarts/data/Graph~Node} nodes  node of sankey view\n * @param  {number} nodeWidth  the dx of the node\n * @param  {number} width  the whole width of the area to draw the view\n */\n\n\nfunction computeNodeBreadths(nodes, nodeWidth, width) {\n  var remainNodes = nodes;\n  var nextNode = null;\n  var x = 0;\n  var kx = 0;\n\n  while (remainNodes.length) {\n    nextNode = [];\n\n    for (var i = 0, len = remainNodes.length; i < len; i++) {\n      var node = remainNodes[i];\n      node.setLayout({\n        x: x\n      }, true);\n      node.setLayout({\n        dx: nodeWidth\n      }, true);\n\n      for (var j = 0, lenj = node.outEdges.length; j < lenj; j++) {\n        nextNode.push(node.outEdges[j].node2);\n      }\n    }\n\n    remainNodes = nextNode;\n    ++x;\n  }\n\n  moveSinksRight(nodes, x);\n  kx = (width - nodeWidth) / (x - 1);\n  scaleNodeBreadths(nodes, kx);\n}\n/**\n * All the node without outEgdes are assigned maximum x-position and\n *     be aligned in the last column.\n *\n * @param {module:echarts/data/Graph~Node} nodes  node of sankey view\n * @param {number} x  value (x-1) use to assign to node without outEdges\n *     as x-position\n */\n\n\nfunction moveSinksRight(nodes, x) {\n  zrUtil.each(nodes, function (node) {\n    if (!node.outEdges.length) {\n      node.setLayout({\n        x: x - 1\n      }, true);\n    }\n  });\n}\n/**\n * Scale node x-position to the width\n *\n * @param {module:echarts/data/Graph~Node} nodes  node of sankey view\n * @param {number} kx   multiple used to scale nodes\n */\n\n\nfunction scaleNodeBreadths(nodes, kx) {\n  zrUtil.each(nodes, function (node) {\n    var nodeX = node.getLayout().x * kx;\n    node.setLayout({\n      x: nodeX\n    }, true);\n  });\n}\n/**\n * Using Gauss-Seidel iterations method to compute the node depth(y-position)\n *\n * @param {module:echarts/data/Graph~Node} nodes  node of sankey view\n * @param {module:echarts/data/Graph~Edge} edges  edge of sankey view\n * @param {number} height  the whole height of the area to draw the view\n * @param {number} nodeGap  the vertical distance between two nodes\n *     in the same column.\n * @param {number} iterations  the number of iterations for the algorithm\n */\n\n\nfunction computeNodeDepths(nodes, edges, height, nodeGap, iterations) {\n  var nodesByBreadth = nest().key(function (d) {\n    return d.getLayout().x;\n  }).sortKeys(ascending).entries(nodes).map(function (d) {\n    return d.values;\n  });\n  initializeNodeDepth(nodes, nodesByBreadth, edges, height, nodeGap);\n  resolveCollisions(nodesByBreadth, nodeGap, height);\n\n  for (var alpha = 1; iterations > 0; iterations--) {\n    // 0.99 is a experience parameter, ensure that each iterations of\n    // changes as small as possible.\n    alpha *= 0.99;\n    relaxRightToLeft(nodesByBreadth, alpha);\n    resolveCollisions(nodesByBreadth, nodeGap, height);\n    relaxLeftToRight(nodesByBreadth, alpha);\n    resolveCollisions(nodesByBreadth, nodeGap, height);\n  }\n}\n/**\n * Compute the original y-position for each node\n *\n * @param {module:echarts/data/Graph~Node} nodes  node of sankey view\n * @param {Array.<Array.<module:echarts/data/Graph~Node>>} nodesByBreadth\n *     group by the array of all sankey nodes based on the nodes x-position.\n * @param {module:echarts/data/Graph~Edge} edges  edge of sankey view\n * @param {number} height  the whole height of the area to draw the view\n * @param {number} nodeGap  the vertical distance between two nodes\n */\n\n\nfunction initializeNodeDepth(nodes, nodesByBreadth, edges, height, nodeGap) {\n  var kyArray = [];\n  zrUtil.each(nodesByBreadth, function (nodes) {\n    var n = nodes.length;\n    var sum = 0;\n    zrUtil.each(nodes, function (node) {\n      sum += node.getLayout().value;\n    });\n    var ky = (height - (n - 1) * nodeGap) / sum;\n    kyArray.push(ky);\n  });\n  kyArray.sort(function (a, b) {\n    return a - b;\n  });\n  var ky0 = kyArray[0];\n  zrUtil.each(nodesByBreadth, function (nodes) {\n    zrUtil.each(nodes, function (node, i) {\n      node.setLayout({\n        y: i\n      }, true);\n      var nodeDy = node.getLayout().value * ky0;\n      node.setLayout({\n        dy: nodeDy\n      }, true);\n    });\n  });\n  zrUtil.each(edges, function (edge) {\n    var edgeDy = +edge.getValue() * ky0;\n    edge.setLayout({\n      dy: edgeDy\n    }, true);\n  });\n}\n/**\n * Resolve the collision of initialized depth (y-position)\n *\n * @param {Array.<Array.<module:echarts/data/Graph~Node>>} nodesByBreadth\n *     group by the array of all sankey nodes based on the nodes x-position.\n * @param {number} nodeGap  the vertical distance between two nodes\n * @param {number} height  the whole height of the area to draw the view\n */\n\n\nfunction resolveCollisions(nodesByBreadth, nodeGap, height) {\n  zrUtil.each(nodesByBreadth, function (nodes) {\n    var node;\n    var dy;\n    var y0 = 0;\n    var n = nodes.length;\n    var i;\n    nodes.sort(ascendingDepth);\n\n    for (i = 0; i < n; i++) {\n      node = nodes[i];\n      dy = y0 - node.getLayout().y;\n\n      if (dy > 0) {\n        var nodeY = node.getLayout().y + dy;\n        node.setLayout({\n          y: nodeY\n        }, true);\n      }\n\n      y0 = node.getLayout().y + node.getLayout().dy + nodeGap;\n    } // if the bottommost node goes outside the bounds, push it back up\n\n\n    dy = y0 - nodeGap - height;\n\n    if (dy > 0) {\n      var nodeY = node.getLayout().y - dy;\n      node.setLayout({\n        y: nodeY\n      }, true);\n      y0 = node.getLayout().y;\n\n      for (i = n - 2; i >= 0; --i) {\n        node = nodes[i];\n        dy = node.getLayout().y + node.getLayout().dy + nodeGap - y0;\n\n        if (dy > 0) {\n          nodeY = node.getLayout().y - dy;\n          node.setLayout({\n            y: nodeY\n          }, true);\n        }\n\n        y0 = node.getLayout().y;\n      }\n    }\n  });\n}\n/**\n * Change the y-position of the nodes, except most the right side nodes\n *\n * @param {Array.<Array.<module:echarts/data/Graph~Node>>} nodesByBreadth\n *     group by the array of all sankey nodes based on the node x-position.\n * @param {number} alpha  parameter used to adjust the nodes y-position\n */\n\n\nfunction relaxRightToLeft(nodesByBreadth, alpha) {\n  zrUtil.each(nodesByBreadth.slice().reverse(), function (nodes) {\n    zrUtil.each(nodes, function (node) {\n      if (node.outEdges.length) {\n        var y = sum(node.outEdges, weightedTarget) / sum(node.outEdges, getEdgeValue);\n        var nodeY = node.getLayout().y + (y - center(node)) * alpha;\n        node.setLayout({\n          y: nodeY\n        }, true);\n      }\n    });\n  });\n}\n\nfunction weightedTarget(edge) {\n  return center(edge.node2) * edge.getValue();\n}\n/**\n * Change the y-position of the nodes, except most the left side nodes\n *\n * @param {Array.<Array.<module:echarts/data/Graph~Node>>} nodesByBreadth\n *     group by the array of all sankey nodes based on the node x-position.\n * @param {number} alpha  parameter used to adjust the nodes y-position\n */\n\n\nfunction relaxLeftToRight(nodesByBreadth, alpha) {\n  zrUtil.each(nodesByBreadth, function (nodes) {\n    zrUtil.each(nodes, function (node) {\n      if (node.inEdges.length) {\n        var y = sum(node.inEdges, weightedSource) / sum(node.inEdges, getEdgeValue);\n        var nodeY = node.getLayout().y + (y - center(node)) * alpha;\n        node.setLayout({\n          y: nodeY\n        }, true);\n      }\n    });\n  });\n}\n\nfunction weightedSource(edge) {\n  return center(edge.node1) * edge.getValue();\n}\n/**\n * Compute the depth(y-position) of each edge\n *\n * @param {module:echarts/data/Graph~Node} nodes  node of sankey view\n */\n\n\nfunction computeEdgeDepths(nodes) {\n  zrUtil.each(nodes, function (node) {\n    node.outEdges.sort(ascendingTargetDepth);\n    node.inEdges.sort(ascendingSourceDepth);\n  });\n  zrUtil.each(nodes, function (node) {\n    var sy = 0;\n    var ty = 0;\n    zrUtil.each(node.outEdges, function (edge) {\n      edge.setLayout({\n        sy: sy\n      }, true);\n      sy += edge.getLayout().dy;\n    });\n    zrUtil.each(node.inEdges, function (edge) {\n      edge.setLayout({\n        ty: ty\n      }, true);\n      ty += edge.getLayout().dy;\n    });\n  });\n}\n\nfunction ascendingTargetDepth(a, b) {\n  return a.node2.getLayout().y - b.node2.getLayout().y;\n}\n\nfunction ascendingSourceDepth(a, b) {\n  return a.node1.getLayout().y - b.node1.getLayout().y;\n}\n\nfunction sum(array, f) {\n  var sum = 0;\n  var len = array.length;\n  var i = -1;\n\n  while (++i < len) {\n    var value = +f.call(array, array[i], i);\n\n    if (!isNaN(value)) {\n      sum += value;\n    }\n  }\n\n  return sum;\n}\n\nfunction center(node) {\n  return node.getLayout().y + node.getLayout().dy / 2;\n}\n\nfunction ascendingDepth(a, b) {\n  return a.getLayout().y - b.getLayout().y;\n}\n\nfunction ascending(a, b) {\n  return a < b ? -1 : a > b ? 1 : a === b ? 0 : NaN;\n}\n\nfunction getEdgeValue(edge) {\n  return edge.getValue();\n}\n\nmodule.exports = _default;","map":{"version":3,"sources":["/home/martin/Escritorio/Taller de Integracion/Tarea3-TallerDeIntegracion/node_modules/react-echarts/node_modules/echarts/lib/chart/sankey/sankeyLayout.js"],"names":["layout","require","nest","zrUtil","_default","ecModel","api","payload","eachSeriesByType","seriesModel","nodeWidth","get","nodeGap","layoutInfo","getViewRect","width","height","graph","getGraph","nodes","edges","computeNodeValues","filteredNodes","filter","node","getLayout","value","iterations","length","layoutSankey","getLayoutRect","getBoxLayoutParams","getWidth","getHeight","computeNodeBreadths","computeNodeDepths","computeEdgeDepths","each","value1","sum","outEdges","getEdgeValue","value2","inEdges","Math","max","setLayout","remainNodes","nextNode","x","kx","i","len","dx","j","lenj","push","node2","moveSinksRight","scaleNodeBreadths","nodeX","nodesByBreadth","key","d","sortKeys","ascending","entries","map","values","initializeNodeDepth","resolveCollisions","alpha","relaxRightToLeft","relaxLeftToRight","kyArray","n","ky","sort","a","b","ky0","y","nodeDy","dy","edge","edgeDy","getValue","y0","ascendingDepth","nodeY","slice","reverse","weightedTarget","center","weightedSource","node1","ascendingTargetDepth","ascendingSourceDepth","sy","ty","array","f","call","isNaN","NaN","module","exports"],"mappings":"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","sourcesContent":["var layout = require(\"../../util/layout\");\n\nvar nest = require(\"../../util/array/nest\");\n\nvar zrUtil = require(\"zrender/lib/core/util\");\n\n/**\n * @file The layout algorithm of sankey view\n * @author  Deqing Li(annong035@gmail.com)\n */\nfunction _default(ecModel, api, payload) {\n  ecModel.eachSeriesByType('sankey', function (seriesModel) {\n    var nodeWidth = seriesModel.get('nodeWidth');\n    var nodeGap = seriesModel.get('nodeGap');\n    var layoutInfo = getViewRect(seriesModel, api);\n    seriesModel.layoutInfo = layoutInfo;\n    var width = layoutInfo.width;\n    var height = layoutInfo.height;\n    var graph = seriesModel.getGraph();\n    var nodes = graph.nodes;\n    var edges = graph.edges;\n    computeNodeValues(nodes);\n    var filteredNodes = zrUtil.filter(nodes, function (node) {\n      return node.getLayout().value === 0;\n    });\n    var iterations = filteredNodes.length !== 0 ? 0 : seriesModel.get('layoutIterations');\n    layoutSankey(nodes, edges, nodeWidth, nodeGap, width, height, iterations);\n  });\n}\n/**\n * Get the layout position of the whole view\n *\n * @param {module:echarts/model/Series} seriesModel  the model object of sankey series\n * @param {module:echarts/ExtensionAPI} api  provide the API list that the developer can call\n * @return {module:zrender/core/BoundingRect}  size of rect to draw the sankey view\n */\n\n\nfunction getViewRect(seriesModel, api) {\n  return layout.getLayoutRect(seriesModel.getBoxLayoutParams(), {\n    width: api.getWidth(),\n    height: api.getHeight()\n  });\n}\n\nfunction layoutSankey(nodes, edges, nodeWidth, nodeGap, width, height, iterations) {\n  computeNodeBreadths(nodes, nodeWidth, width);\n  computeNodeDepths(nodes, edges, height, nodeGap, iterations);\n  computeEdgeDepths(nodes);\n}\n/**\n * Compute the value of each node by summing the associated edge's value\n *\n * @param {module:echarts/data/Graph~Node} nodes  node of sankey view\n */\n\n\nfunction computeNodeValues(nodes) {\n  zrUtil.each(nodes, function (node) {\n    var value1 = sum(node.outEdges, getEdgeValue);\n    var value2 = sum(node.inEdges, getEdgeValue);\n    var value = Math.max(value1, value2);\n    node.setLayout({\n      value: value\n    }, true);\n  });\n}\n/**\n * Compute the x-position for each node\n *\n * @param {module:echarts/data/Graph~Node} nodes  node of sankey view\n * @param  {number} nodeWidth  the dx of the node\n * @param  {number} width  the whole width of the area to draw the view\n */\n\n\nfunction computeNodeBreadths(nodes, nodeWidth, width) {\n  var remainNodes = nodes;\n  var nextNode = null;\n  var x = 0;\n  var kx = 0;\n\n  while (remainNodes.length) {\n    nextNode = [];\n\n    for (var i = 0, len = remainNodes.length; i < len; i++) {\n      var node = remainNodes[i];\n      node.setLayout({\n        x: x\n      }, true);\n      node.setLayout({\n        dx: nodeWidth\n      }, true);\n\n      for (var j = 0, lenj = node.outEdges.length; j < lenj; j++) {\n        nextNode.push(node.outEdges[j].node2);\n      }\n    }\n\n    remainNodes = nextNode;\n    ++x;\n  }\n\n  moveSinksRight(nodes, x);\n  kx = (width - nodeWidth) / (x - 1);\n  scaleNodeBreadths(nodes, kx);\n}\n/**\n * All the node without outEgdes are assigned maximum x-position and\n *     be aligned in the last column.\n *\n * @param {module:echarts/data/Graph~Node} nodes  node of sankey view\n * @param {number} x  value (x-1) use to assign to node without outEdges\n *     as x-position\n */\n\n\nfunction moveSinksRight(nodes, x) {\n  zrUtil.each(nodes, function (node) {\n    if (!node.outEdges.length) {\n      node.setLayout({\n        x: x - 1\n      }, true);\n    }\n  });\n}\n/**\n * Scale node x-position to the width\n *\n * @param {module:echarts/data/Graph~Node} nodes  node of sankey view\n * @param {number} kx   multiple used to scale nodes\n */\n\n\nfunction scaleNodeBreadths(nodes, kx) {\n  zrUtil.each(nodes, function (node) {\n    var nodeX = node.getLayout().x * kx;\n    node.setLayout({\n      x: nodeX\n    }, true);\n  });\n}\n/**\n * Using Gauss-Seidel iterations method to compute the node depth(y-position)\n *\n * @param {module:echarts/data/Graph~Node} nodes  node of sankey view\n * @param {module:echarts/data/Graph~Edge} edges  edge of sankey view\n * @param {number} height  the whole height of the area to draw the view\n * @param {number} nodeGap  the vertical distance between two nodes\n *     in the same column.\n * @param {number} iterations  the number of iterations for the algorithm\n */\n\n\nfunction computeNodeDepths(nodes, edges, height, nodeGap, iterations) {\n  var nodesByBreadth = nest().key(function (d) {\n    return d.getLayout().x;\n  }).sortKeys(ascending).entries(nodes).map(function (d) {\n    return d.values;\n  });\n  initializeNodeDepth(nodes, nodesByBreadth, edges, height, nodeGap);\n  resolveCollisions(nodesByBreadth, nodeGap, height);\n\n  for (var alpha = 1; iterations > 0; iterations--) {\n    // 0.99 is a experience parameter, ensure that each iterations of\n    // changes as small as possible.\n    alpha *= 0.99;\n    relaxRightToLeft(nodesByBreadth, alpha);\n    resolveCollisions(nodesByBreadth, nodeGap, height);\n    relaxLeftToRight(nodesByBreadth, alpha);\n    resolveCollisions(nodesByBreadth, nodeGap, height);\n  }\n}\n/**\n * Compute the original y-position for each node\n *\n * @param {module:echarts/data/Graph~Node} nodes  node of sankey view\n * @param {Array.<Array.<module:echarts/data/Graph~Node>>} nodesByBreadth\n *     group by the array of all sankey nodes based on the nodes x-position.\n * @param {module:echarts/data/Graph~Edge} edges  edge of sankey view\n * @param {number} height  the whole height of the area to draw the view\n * @param {number} nodeGap  the vertical distance between two nodes\n */\n\n\nfunction initializeNodeDepth(nodes, nodesByBreadth, edges, height, nodeGap) {\n  var kyArray = [];\n  zrUtil.each(nodesByBreadth, function (nodes) {\n    var n = nodes.length;\n    var sum = 0;\n    zrUtil.each(nodes, function (node) {\n      sum += node.getLayout().value;\n    });\n    var ky = (height - (n - 1) * nodeGap) / sum;\n    kyArray.push(ky);\n  });\n  kyArray.sort(function (a, b) {\n    return a - b;\n  });\n  var ky0 = kyArray[0];\n  zrUtil.each(nodesByBreadth, function (nodes) {\n    zrUtil.each(nodes, function (node, i) {\n      node.setLayout({\n        y: i\n      }, true);\n      var nodeDy = node.getLayout().value * ky0;\n      node.setLayout({\n        dy: nodeDy\n      }, true);\n    });\n  });\n  zrUtil.each(edges, function (edge) {\n    var edgeDy = +edge.getValue() * ky0;\n    edge.setLayout({\n      dy: edgeDy\n    }, true);\n  });\n}\n/**\n * Resolve the collision of initialized depth (y-position)\n *\n * @param {Array.<Array.<module:echarts/data/Graph~Node>>} nodesByBreadth\n *     group by the array of all sankey nodes based on the nodes x-position.\n * @param {number} nodeGap  the vertical distance between two nodes\n * @param {number} height  the whole height of the area to draw the view\n */\n\n\nfunction resolveCollisions(nodesByBreadth, nodeGap, height) {\n  zrUtil.each(nodesByBreadth, function (nodes) {\n    var node;\n    var dy;\n    var y0 = 0;\n    var n = nodes.length;\n    var i;\n    nodes.sort(ascendingDepth);\n\n    for (i = 0; i < n; i++) {\n      node = nodes[i];\n      dy = y0 - node.getLayout().y;\n\n      if (dy > 0) {\n        var nodeY = node.getLayout().y + dy;\n        node.setLayout({\n          y: nodeY\n        }, true);\n      }\n\n      y0 = node.getLayout().y + node.getLayout().dy + nodeGap;\n    } // if the bottommost node goes outside the bounds, push it back up\n\n\n    dy = y0 - nodeGap - height;\n\n    if (dy > 0) {\n      var nodeY = node.getLayout().y - dy;\n      node.setLayout({\n        y: nodeY\n      }, true);\n      y0 = node.getLayout().y;\n\n      for (i = n - 2; i >= 0; --i) {\n        node = nodes[i];\n        dy = node.getLayout().y + node.getLayout().dy + nodeGap - y0;\n\n        if (dy > 0) {\n          nodeY = node.getLayout().y - dy;\n          node.setLayout({\n            y: nodeY\n          }, true);\n        }\n\n        y0 = node.getLayout().y;\n      }\n    }\n  });\n}\n/**\n * Change the y-position of the nodes, except most the right side nodes\n *\n * @param {Array.<Array.<module:echarts/data/Graph~Node>>} nodesByBreadth\n *     group by the array of all sankey nodes based on the node x-position.\n * @param {number} alpha  parameter used to adjust the nodes y-position\n */\n\n\nfunction relaxRightToLeft(nodesByBreadth, alpha) {\n  zrUtil.each(nodesByBreadth.slice().reverse(), function (nodes) {\n    zrUtil.each(nodes, function (node) {\n      if (node.outEdges.length) {\n        var y = sum(node.outEdges, weightedTarget) / sum(node.outEdges, getEdgeValue);\n        var nodeY = node.getLayout().y + (y - center(node)) * alpha;\n        node.setLayout({\n          y: nodeY\n        }, true);\n      }\n    });\n  });\n}\n\nfunction weightedTarget(edge) {\n  return center(edge.node2) * edge.getValue();\n}\n/**\n * Change the y-position of the nodes, except most the left side nodes\n *\n * @param {Array.<Array.<module:echarts/data/Graph~Node>>} nodesByBreadth\n *     group by the array of all sankey nodes based on the node x-position.\n * @param {number} alpha  parameter used to adjust the nodes y-position\n */\n\n\nfunction relaxLeftToRight(nodesByBreadth, alpha) {\n  zrUtil.each(nodesByBreadth, function (nodes) {\n    zrUtil.each(nodes, function (node) {\n      if (node.inEdges.length) {\n        var y = sum(node.inEdges, weightedSource) / sum(node.inEdges, getEdgeValue);\n        var nodeY = node.getLayout().y + (y - center(node)) * alpha;\n        node.setLayout({\n          y: nodeY\n        }, true);\n      }\n    });\n  });\n}\n\nfunction weightedSource(edge) {\n  return center(edge.node1) * edge.getValue();\n}\n/**\n * Compute the depth(y-position) of each edge\n *\n * @param {module:echarts/data/Graph~Node} nodes  node of sankey view\n */\n\n\nfunction computeEdgeDepths(nodes) {\n  zrUtil.each(nodes, function (node) {\n    node.outEdges.sort(ascendingTargetDepth);\n    node.inEdges.sort(ascendingSourceDepth);\n  });\n  zrUtil.each(nodes, function (node) {\n    var sy = 0;\n    var ty = 0;\n    zrUtil.each(node.outEdges, function (edge) {\n      edge.setLayout({\n        sy: sy\n      }, true);\n      sy += edge.getLayout().dy;\n    });\n    zrUtil.each(node.inEdges, function (edge) {\n      edge.setLayout({\n        ty: ty\n      }, true);\n      ty += edge.getLayout().dy;\n    });\n  });\n}\n\nfunction ascendingTargetDepth(a, b) {\n  return a.node2.getLayout().y - b.node2.getLayout().y;\n}\n\nfunction ascendingSourceDepth(a, b) {\n  return a.node1.getLayout().y - b.node1.getLayout().y;\n}\n\nfunction sum(array, f) {\n  var sum = 0;\n  var len = array.length;\n  var i = -1;\n\n  while (++i < len) {\n    var value = +f.call(array, array[i], i);\n\n    if (!isNaN(value)) {\n      sum += value;\n    }\n  }\n\n  return sum;\n}\n\nfunction center(node) {\n  return node.getLayout().y + node.getLayout().dy / 2;\n}\n\nfunction ascendingDepth(a, b) {\n  return a.getLayout().y - b.getLayout().y;\n}\n\nfunction ascending(a, b) {\n  return a < b ? -1 : a > b ? 1 : a === b ? 0 : NaN;\n}\n\nfunction getEdgeValue(edge) {\n  return edge.getValue();\n}\n\nmodule.exports = _default;"]},"metadata":{},"sourceType":"script"}