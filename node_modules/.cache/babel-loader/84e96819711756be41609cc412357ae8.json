{"ast":null,"code":"var zrUtil = require(\"zrender/lib/core/util\");\n\nvar _model = require(\"../../util/model\");\n\nvar normalizeToArray = _model.normalizeToArray;\n/**\n * Complete dimensions by data (guess dimension).\n */\n\nvar each = zrUtil.each;\nvar isString = zrUtil.isString;\nvar defaults = zrUtil.defaults;\nvar OTHER_DIMS = {\n  tooltip: 1,\n  label: 1,\n  itemName: 1\n};\n/**\n * Complete the dimensions array, by user defined `dimension` and `encode`,\n * and guessing from the data structure.\n * If no 'value' dimension specified, the first no-named dimension will be\n * named as 'value'.\n *\n * @param {Array.<string>} sysDims Necessary dimensions, like ['x', 'y'], which\n *      provides not only dim template, but also default order.\n *      `name` of each item provides default coord name.\n *      [{dimsDef: []}, ...] can be specified to give names.\n * @param {Array} data Data list. [[1, 2, 3], [2, 3, 4]].\n * @param {Object} [opt]\n * @param {Array.<Object|string>} [opt.dimsDef] option.series.dimensions User defined dimensions\n *      For example: ['asdf', {name, type}, ...].\n * @param {Object} [opt.encodeDef] option.series.encode {x: 2, y: [3, 1], tooltip: [1, 2], label: 3}\n * @param {string} [opt.extraPrefix] Prefix of name when filling the left dimensions.\n * @param {string} [opt.extraFromZero] If specified, extra dim names will be:\n *                      extraPrefix + 0, extraPrefix + extraBaseIndex + 1 ...\n *                      If not specified, extra dim names will be:\n *                      extraPrefix, extraPrefix + 0, extraPrefix + 1 ...\n * @param {number} [opt.dimCount] If not specified, guess by the first data item.\n * @return {Array.<Object>} [{\n *      name: string mandatory,\n *      coordDim: string mandatory,\n *      coordDimIndex: number mandatory,\n *      type: string optional,\n *      tooltipName: string optional,\n *      otherDims: {\n *          tooltip: number optional,\n *          label: number optional\n *      },\n *      isExtraCoord: boolean true or undefined.\n *      other props ...\n * }]\n */\n\nfunction completeDimensions(sysDims, data, opt) {\n  data = data || [];\n  opt = opt || {};\n  sysDims = (sysDims || []).slice();\n  var dimsDef = (opt.dimsDef || []).slice();\n  var encodeDef = zrUtil.createHashMap(opt.encodeDef);\n  var dataDimNameMap = zrUtil.createHashMap();\n  var coordDimNameMap = zrUtil.createHashMap(); // var valueCandidate;\n\n  var result = [];\n  var dimCount = opt.dimCount;\n\n  if (dimCount == null) {\n    var value0 = retrieveValue(data[0]);\n    dimCount = Math.max(zrUtil.isArray(value0) && value0.length || 1, sysDims.length, dimsDef.length);\n    each(sysDims, function (sysDimItem) {\n      var sysDimItemDimsDef = sysDimItem.dimsDef;\n      sysDimItemDimsDef && (dimCount = Math.max(dimCount, sysDimItemDimsDef.length));\n    });\n  } // Apply user defined dims (`name` and `type`) and init result.\n\n\n  for (var i = 0; i < dimCount; i++) {\n    var dimDefItem = isString(dimsDef[i]) ? {\n      name: dimsDef[i]\n    } : dimsDef[i] || {};\n    var userDimName = dimDefItem.name;\n    var resultItem = result[i] = {\n      otherDims: {}\n    }; // Name will be applied later for avoiding duplication.\n\n    if (userDimName != null && dataDimNameMap.get(userDimName) == null) {\n      // Only if `series.dimensions` is defined in option, tooltipName\n      // will be set, and dimension will be diplayed vertically in\n      // tooltip by default.\n      resultItem.name = resultItem.tooltipName = userDimName;\n      dataDimNameMap.set(userDimName, i);\n    }\n\n    dimDefItem.type != null && (resultItem.type = dimDefItem.type);\n  } // Set `coordDim` and `coordDimIndex` by `encodeDef` and normalize `encodeDef`.\n\n\n  encodeDef.each(function (dataDims, coordDim) {\n    dataDims = encodeDef.set(coordDim, normalizeToArray(dataDims).slice());\n    each(dataDims, function (resultDimIdx, coordDimIndex) {\n      // The input resultDimIdx can be dim name or index.\n      isString(resultDimIdx) && (resultDimIdx = dataDimNameMap.get(resultDimIdx));\n\n      if (resultDimIdx != null && resultDimIdx < dimCount) {\n        dataDims[coordDimIndex] = resultDimIdx;\n        applyDim(result[resultDimIdx], coordDim, coordDimIndex);\n      }\n    });\n  }); // Apply templetes and default order from `sysDims`.\n\n  var availDimIdx = 0;\n  each(sysDims, function (sysDimItem, sysDimIndex) {\n    var coordDim;\n    var sysDimItem;\n    var sysDimItemDimsDef;\n    var sysDimItemOtherDims;\n\n    if (isString(sysDimItem)) {\n      coordDim = sysDimItem;\n      sysDimItem = {};\n    } else {\n      coordDim = sysDimItem.name;\n      sysDimItem = zrUtil.clone(sysDimItem); // `coordDimIndex` should not be set directly.\n\n      sysDimItemDimsDef = sysDimItem.dimsDef;\n      sysDimItemOtherDims = sysDimItem.otherDims;\n      sysDimItem.name = sysDimItem.coordDim = sysDimItem.coordDimIndex = sysDimItem.dimsDef = sysDimItem.otherDims = null;\n    }\n\n    var dataDims = normalizeToArray(encodeDef.get(coordDim)); // dimensions provides default dim sequences.\n\n    if (!dataDims.length) {\n      for (var i = 0; i < (sysDimItemDimsDef && sysDimItemDimsDef.length || 1); i++) {\n        while (availDimIdx < result.length && result[availDimIdx].coordDim != null) {\n          availDimIdx++;\n        }\n\n        availDimIdx < result.length && dataDims.push(availDimIdx++);\n      }\n    } // Apply templates.\n\n\n    each(dataDims, function (resultDimIdx, coordDimIndex) {\n      var resultItem = result[resultDimIdx];\n      applyDim(defaults(resultItem, sysDimItem), coordDim, coordDimIndex);\n\n      if (resultItem.name == null && sysDimItemDimsDef) {\n        resultItem.name = resultItem.tooltipName = sysDimItemDimsDef[coordDimIndex];\n      }\n\n      sysDimItemOtherDims && defaults(resultItem.otherDims, sysDimItemOtherDims);\n    });\n  }); // Make sure the first extra dim is 'value'.\n\n  var extra = opt.extraPrefix || 'value'; // Set dim `name` and other `coordDim` and other props.\n\n  for (var resultDimIdx = 0; resultDimIdx < dimCount; resultDimIdx++) {\n    var resultItem = result[resultDimIdx] = result[resultDimIdx] || {};\n    var coordDim = resultItem.coordDim;\n    coordDim == null && (resultItem.coordDim = genName(extra, coordDimNameMap, opt.extraFromZero), resultItem.coordDimIndex = 0, resultItem.isExtraCoord = true);\n    resultItem.name == null && (resultItem.name = genName(resultItem.coordDim, dataDimNameMap));\n    resultItem.type == null && guessOrdinal(data, resultDimIdx) && (resultItem.type = 'ordinal');\n  }\n\n  return result;\n\n  function applyDim(resultItem, coordDim, coordDimIndex) {\n    if (OTHER_DIMS[coordDim]) {\n      resultItem.otherDims[coordDim] = coordDimIndex;\n    } else {\n      resultItem.coordDim = coordDim;\n      resultItem.coordDimIndex = coordDimIndex;\n      coordDimNameMap.set(coordDim, true);\n    }\n  }\n\n  function genName(name, map, fromZero) {\n    if (fromZero || map.get(name) != null) {\n      var i = 0;\n\n      while (map.get(name + i) != null) {\n        i++;\n      }\n\n      name += i;\n    }\n\n    map.set(name, true);\n    return name;\n  }\n} // The rule should not be complex, otherwise user might not\n// be able to known where the data is wrong.\n\n\nvar guessOrdinal = completeDimensions.guessOrdinal = function (data, dimIndex) {\n  for (var i = 0, len = data.length; i < len; i++) {\n    var value = retrieveValue(data[i]);\n\n    if (!zrUtil.isArray(value)) {\n      return false;\n    }\n\n    var value = value[dimIndex]; // Consider usage convenience, '1', '2' will be treated as \"number\".\n    // `isFinit('')` get `true`.\n\n    if (value != null && isFinite(value) && value !== '') {\n      return false;\n    } else if (isString(value) && value !== '-') {\n      return true;\n    }\n  }\n\n  return false;\n};\n\nfunction retrieveValue(o) {\n  return zrUtil.isArray(o) ? o : zrUtil.isObject(o) ? o.value : o;\n}\n\nvar _default = completeDimensions;\nmodule.exports = _default;","map":{"version":3,"sources":["/home/martin/Escritorio/Taller de Integracion/Tarea3-TallerDeIntegracion/node_modules/react-echarts/node_modules/echarts/lib/data/helper/completeDimensions.js"],"names":["zrUtil","require","_model","normalizeToArray","each","isString","defaults","OTHER_DIMS","tooltip","label","itemName","completeDimensions","sysDims","data","opt","slice","dimsDef","encodeDef","createHashMap","dataDimNameMap","coordDimNameMap","result","dimCount","value0","retrieveValue","Math","max","isArray","length","sysDimItem","sysDimItemDimsDef","i","dimDefItem","name","userDimName","resultItem","otherDims","get","tooltipName","set","type","dataDims","coordDim","resultDimIdx","coordDimIndex","applyDim","availDimIdx","sysDimIndex","sysDimItemOtherDims","clone","push","extra","extraPrefix","genName","extraFromZero","isExtraCoord","guessOrdinal","map","fromZero","dimIndex","len","value","isFinite","o","isObject","_default","module","exports"],"mappings":"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","sourcesContent":["var zrUtil = require(\"zrender/lib/core/util\");\n\nvar _model = require(\"../../util/model\");\n\nvar normalizeToArray = _model.normalizeToArray;\n\n/**\n * Complete dimensions by data (guess dimension).\n */\nvar each = zrUtil.each;\nvar isString = zrUtil.isString;\nvar defaults = zrUtil.defaults;\nvar OTHER_DIMS = {\n  tooltip: 1,\n  label: 1,\n  itemName: 1\n};\n/**\n * Complete the dimensions array, by user defined `dimension` and `encode`,\n * and guessing from the data structure.\n * If no 'value' dimension specified, the first no-named dimension will be\n * named as 'value'.\n *\n * @param {Array.<string>} sysDims Necessary dimensions, like ['x', 'y'], which\n *      provides not only dim template, but also default order.\n *      `name` of each item provides default coord name.\n *      [{dimsDef: []}, ...] can be specified to give names.\n * @param {Array} data Data list. [[1, 2, 3], [2, 3, 4]].\n * @param {Object} [opt]\n * @param {Array.<Object|string>} [opt.dimsDef] option.series.dimensions User defined dimensions\n *      For example: ['asdf', {name, type}, ...].\n * @param {Object} [opt.encodeDef] option.series.encode {x: 2, y: [3, 1], tooltip: [1, 2], label: 3}\n * @param {string} [opt.extraPrefix] Prefix of name when filling the left dimensions.\n * @param {string} [opt.extraFromZero] If specified, extra dim names will be:\n *                      extraPrefix + 0, extraPrefix + extraBaseIndex + 1 ...\n *                      If not specified, extra dim names will be:\n *                      extraPrefix, extraPrefix + 0, extraPrefix + 1 ...\n * @param {number} [opt.dimCount] If not specified, guess by the first data item.\n * @return {Array.<Object>} [{\n *      name: string mandatory,\n *      coordDim: string mandatory,\n *      coordDimIndex: number mandatory,\n *      type: string optional,\n *      tooltipName: string optional,\n *      otherDims: {\n *          tooltip: number optional,\n *          label: number optional\n *      },\n *      isExtraCoord: boolean true or undefined.\n *      other props ...\n * }]\n */\n\nfunction completeDimensions(sysDims, data, opt) {\n  data = data || [];\n  opt = opt || {};\n  sysDims = (sysDims || []).slice();\n  var dimsDef = (opt.dimsDef || []).slice();\n  var encodeDef = zrUtil.createHashMap(opt.encodeDef);\n  var dataDimNameMap = zrUtil.createHashMap();\n  var coordDimNameMap = zrUtil.createHashMap(); // var valueCandidate;\n\n  var result = [];\n  var dimCount = opt.dimCount;\n\n  if (dimCount == null) {\n    var value0 = retrieveValue(data[0]);\n    dimCount = Math.max(zrUtil.isArray(value0) && value0.length || 1, sysDims.length, dimsDef.length);\n    each(sysDims, function (sysDimItem) {\n      var sysDimItemDimsDef = sysDimItem.dimsDef;\n      sysDimItemDimsDef && (dimCount = Math.max(dimCount, sysDimItemDimsDef.length));\n    });\n  } // Apply user defined dims (`name` and `type`) and init result.\n\n\n  for (var i = 0; i < dimCount; i++) {\n    var dimDefItem = isString(dimsDef[i]) ? {\n      name: dimsDef[i]\n    } : dimsDef[i] || {};\n    var userDimName = dimDefItem.name;\n    var resultItem = result[i] = {\n      otherDims: {}\n    }; // Name will be applied later for avoiding duplication.\n\n    if (userDimName != null && dataDimNameMap.get(userDimName) == null) {\n      // Only if `series.dimensions` is defined in option, tooltipName\n      // will be set, and dimension will be diplayed vertically in\n      // tooltip by default.\n      resultItem.name = resultItem.tooltipName = userDimName;\n      dataDimNameMap.set(userDimName, i);\n    }\n\n    dimDefItem.type != null && (resultItem.type = dimDefItem.type);\n  } // Set `coordDim` and `coordDimIndex` by `encodeDef` and normalize `encodeDef`.\n\n\n  encodeDef.each(function (dataDims, coordDim) {\n    dataDims = encodeDef.set(coordDim, normalizeToArray(dataDims).slice());\n    each(dataDims, function (resultDimIdx, coordDimIndex) {\n      // The input resultDimIdx can be dim name or index.\n      isString(resultDimIdx) && (resultDimIdx = dataDimNameMap.get(resultDimIdx));\n\n      if (resultDimIdx != null && resultDimIdx < dimCount) {\n        dataDims[coordDimIndex] = resultDimIdx;\n        applyDim(result[resultDimIdx], coordDim, coordDimIndex);\n      }\n    });\n  }); // Apply templetes and default order from `sysDims`.\n\n  var availDimIdx = 0;\n  each(sysDims, function (sysDimItem, sysDimIndex) {\n    var coordDim;\n    var sysDimItem;\n    var sysDimItemDimsDef;\n    var sysDimItemOtherDims;\n\n    if (isString(sysDimItem)) {\n      coordDim = sysDimItem;\n      sysDimItem = {};\n    } else {\n      coordDim = sysDimItem.name;\n      sysDimItem = zrUtil.clone(sysDimItem); // `coordDimIndex` should not be set directly.\n\n      sysDimItemDimsDef = sysDimItem.dimsDef;\n      sysDimItemOtherDims = sysDimItem.otherDims;\n      sysDimItem.name = sysDimItem.coordDim = sysDimItem.coordDimIndex = sysDimItem.dimsDef = sysDimItem.otherDims = null;\n    }\n\n    var dataDims = normalizeToArray(encodeDef.get(coordDim)); // dimensions provides default dim sequences.\n\n    if (!dataDims.length) {\n      for (var i = 0; i < (sysDimItemDimsDef && sysDimItemDimsDef.length || 1); i++) {\n        while (availDimIdx < result.length && result[availDimIdx].coordDim != null) {\n          availDimIdx++;\n        }\n\n        availDimIdx < result.length && dataDims.push(availDimIdx++);\n      }\n    } // Apply templates.\n\n\n    each(dataDims, function (resultDimIdx, coordDimIndex) {\n      var resultItem = result[resultDimIdx];\n      applyDim(defaults(resultItem, sysDimItem), coordDim, coordDimIndex);\n\n      if (resultItem.name == null && sysDimItemDimsDef) {\n        resultItem.name = resultItem.tooltipName = sysDimItemDimsDef[coordDimIndex];\n      }\n\n      sysDimItemOtherDims && defaults(resultItem.otherDims, sysDimItemOtherDims);\n    });\n  }); // Make sure the first extra dim is 'value'.\n\n  var extra = opt.extraPrefix || 'value'; // Set dim `name` and other `coordDim` and other props.\n\n  for (var resultDimIdx = 0; resultDimIdx < dimCount; resultDimIdx++) {\n    var resultItem = result[resultDimIdx] = result[resultDimIdx] || {};\n    var coordDim = resultItem.coordDim;\n    coordDim == null && (resultItem.coordDim = genName(extra, coordDimNameMap, opt.extraFromZero), resultItem.coordDimIndex = 0, resultItem.isExtraCoord = true);\n    resultItem.name == null && (resultItem.name = genName(resultItem.coordDim, dataDimNameMap));\n    resultItem.type == null && guessOrdinal(data, resultDimIdx) && (resultItem.type = 'ordinal');\n  }\n\n  return result;\n\n  function applyDim(resultItem, coordDim, coordDimIndex) {\n    if (OTHER_DIMS[coordDim]) {\n      resultItem.otherDims[coordDim] = coordDimIndex;\n    } else {\n      resultItem.coordDim = coordDim;\n      resultItem.coordDimIndex = coordDimIndex;\n      coordDimNameMap.set(coordDim, true);\n    }\n  }\n\n  function genName(name, map, fromZero) {\n    if (fromZero || map.get(name) != null) {\n      var i = 0;\n\n      while (map.get(name + i) != null) {\n        i++;\n      }\n\n      name += i;\n    }\n\n    map.set(name, true);\n    return name;\n  }\n} // The rule should not be complex, otherwise user might not\n// be able to known where the data is wrong.\n\n\nvar guessOrdinal = completeDimensions.guessOrdinal = function (data, dimIndex) {\n  for (var i = 0, len = data.length; i < len; i++) {\n    var value = retrieveValue(data[i]);\n\n    if (!zrUtil.isArray(value)) {\n      return false;\n    }\n\n    var value = value[dimIndex]; // Consider usage convenience, '1', '2' will be treated as \"number\".\n    // `isFinit('')` get `true`.\n\n    if (value != null && isFinite(value) && value !== '') {\n      return false;\n    } else if (isString(value) && value !== '-') {\n      return true;\n    }\n  }\n\n  return false;\n};\n\nfunction retrieveValue(o) {\n  return zrUtil.isArray(o) ? o : zrUtil.isObject(o) ? o.value : o;\n}\n\nvar _default = completeDimensions;\nmodule.exports = _default;"]},"metadata":{},"sourceType":"script"}