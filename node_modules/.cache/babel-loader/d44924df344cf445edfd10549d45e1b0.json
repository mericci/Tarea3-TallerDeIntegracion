{"ast":null,"code":"var zrUtil = require(\"zrender/lib/core/util\");\n\nvar axisHelper = require(\"./axisHelper\");\n\nfunction getName(obj) {\n  if (zrUtil.isObject(obj) && obj.value != null) {\n    return obj.value;\n  } else {\n    return obj + '';\n  }\n}\n\nvar _default = {\n  /**\n   * Format labels\n   * @return {Array.<string>}\n   */\n  getFormattedLabels: function () {\n    return axisHelper.getFormattedLabels(this.axis, this.get('axisLabel.formatter'));\n  },\n\n  /**\n   * Get categories\n   */\n  getCategories: function () {\n    return this.get('type') === 'category' && zrUtil.map(this.get('data'), getName);\n  },\n\n  /**\n   * @param {boolean} origin\n   * @return {number|string} min value or 'dataMin' or null/undefined (means auto) or NaN\n   */\n  getMin: function (origin) {\n    var option = this.option;\n    var min = !origin && option.rangeStart != null ? option.rangeStart : option.min;\n\n    if (this.axis && min != null && min !== 'dataMin' && typeof min !== 'function' && !zrUtil.eqNaN(min)) {\n      min = this.axis.scale.parse(min);\n    }\n\n    return min;\n  },\n\n  /**\n   * @param {boolean} origin\n   * @return {number|string} max value or 'dataMax' or null/undefined (means auto) or NaN\n   */\n  getMax: function (origin) {\n    var option = this.option;\n    var max = !origin && option.rangeEnd != null ? option.rangeEnd : option.max;\n\n    if (this.axis && max != null && max !== 'dataMax' && typeof max !== 'function' && !zrUtil.eqNaN(max)) {\n      max = this.axis.scale.parse(max);\n    }\n\n    return max;\n  },\n\n  /**\n   * @return {boolean}\n   */\n  getNeedCrossZero: function () {\n    var option = this.option;\n    return option.rangeStart != null || option.rangeEnd != null ? false : !option.scale;\n  },\n\n  /**\n   * Should be implemented by each axis model if necessary.\n   * @return {module:echarts/model/Component} coordinate system model\n   */\n  getCoordSysModel: zrUtil.noop,\n\n  /**\n   * @param {number} rangeStart Can only be finite number or null/undefined or NaN.\n   * @param {number} rangeEnd Can only be finite number or null/undefined or NaN.\n   */\n  setRange: function (rangeStart, rangeEnd) {\n    this.option.rangeStart = rangeStart;\n    this.option.rangeEnd = rangeEnd;\n  },\n\n  /**\n   * Reset range\n   */\n  resetRange: function () {\n    // rangeStart and rangeEnd is readonly.\n    this.option.rangeStart = this.option.rangeEnd = null;\n  }\n};\nmodule.exports = _default;","map":{"version":3,"sources":["/home/martin/Escritorio/Taller de Integracion/Tarea3-TallerDeIntegracion/node_modules/react-echarts/node_modules/echarts/lib/coord/axisModelCommonMixin.js"],"names":["zrUtil","require","axisHelper","getName","obj","isObject","value","_default","getFormattedLabels","axis","get","getCategories","map","getMin","origin","option","min","rangeStart","eqNaN","scale","parse","getMax","max","rangeEnd","getNeedCrossZero","getCoordSysModel","noop","setRange","resetRange","module","exports"],"mappings":"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","sourcesContent":["var zrUtil = require(\"zrender/lib/core/util\");\n\nvar axisHelper = require(\"./axisHelper\");\n\nfunction getName(obj) {\n  if (zrUtil.isObject(obj) && obj.value != null) {\n    return obj.value;\n  } else {\n    return obj + '';\n  }\n}\n\nvar _default = {\n  /**\n   * Format labels\n   * @return {Array.<string>}\n   */\n  getFormattedLabels: function () {\n    return axisHelper.getFormattedLabels(this.axis, this.get('axisLabel.formatter'));\n  },\n\n  /**\n   * Get categories\n   */\n  getCategories: function () {\n    return this.get('type') === 'category' && zrUtil.map(this.get('data'), getName);\n  },\n\n  /**\n   * @param {boolean} origin\n   * @return {number|string} min value or 'dataMin' or null/undefined (means auto) or NaN\n   */\n  getMin: function (origin) {\n    var option = this.option;\n    var min = !origin && option.rangeStart != null ? option.rangeStart : option.min;\n\n    if (this.axis && min != null && min !== 'dataMin' && typeof min !== 'function' && !zrUtil.eqNaN(min)) {\n      min = this.axis.scale.parse(min);\n    }\n\n    return min;\n  },\n\n  /**\n   * @param {boolean} origin\n   * @return {number|string} max value or 'dataMax' or null/undefined (means auto) or NaN\n   */\n  getMax: function (origin) {\n    var option = this.option;\n    var max = !origin && option.rangeEnd != null ? option.rangeEnd : option.max;\n\n    if (this.axis && max != null && max !== 'dataMax' && typeof max !== 'function' && !zrUtil.eqNaN(max)) {\n      max = this.axis.scale.parse(max);\n    }\n\n    return max;\n  },\n\n  /**\n   * @return {boolean}\n   */\n  getNeedCrossZero: function () {\n    var option = this.option;\n    return option.rangeStart != null || option.rangeEnd != null ? false : !option.scale;\n  },\n\n  /**\n   * Should be implemented by each axis model if necessary.\n   * @return {module:echarts/model/Component} coordinate system model\n   */\n  getCoordSysModel: zrUtil.noop,\n\n  /**\n   * @param {number} rangeStart Can only be finite number or null/undefined or NaN.\n   * @param {number} rangeEnd Can only be finite number or null/undefined or NaN.\n   */\n  setRange: function (rangeStart, rangeEnd) {\n    this.option.rangeStart = rangeStart;\n    this.option.rangeEnd = rangeEnd;\n  },\n\n  /**\n   * Reset range\n   */\n  resetRange: function () {\n    // rangeStart and rangeEnd is readonly.\n    this.option.rangeStart = this.option.rangeEnd = null;\n  }\n};\nmodule.exports = _default;"]},"metadata":{},"sourceType":"script"}