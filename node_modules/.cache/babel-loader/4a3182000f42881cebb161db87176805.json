{"ast":null,"code":"var _number = require(\"../../util/number\");\n\nvar parsePercent = _number.parsePercent;\nvar linearMap = _number.linearMap;\n\nvar labelLayout = require(\"./labelLayout\");\n\nvar zrUtil = require(\"zrender/lib/core/util\");\n\nvar PI2 = Math.PI * 2;\nvar RADIAN = Math.PI / 180;\n\nfunction _default(seriesType, ecModel, api, payload) {\n  ecModel.eachSeriesByType(seriesType, function (seriesModel) {\n    var center = seriesModel.get('center');\n    var radius = seriesModel.get('radius');\n\n    if (!zrUtil.isArray(radius)) {\n      radius = [0, radius];\n    }\n\n    if (!zrUtil.isArray(center)) {\n      center = [center, center];\n    }\n\n    var width = api.getWidth();\n    var height = api.getHeight();\n    var size = Math.min(width, height);\n    var cx = parsePercent(center[0], width);\n    var cy = parsePercent(center[1], height);\n    var r0 = parsePercent(radius[0], size / 2);\n    var r = parsePercent(radius[1], size / 2);\n    var data = seriesModel.getData();\n    var startAngle = -seriesModel.get('startAngle') * RADIAN;\n    var minAngle = seriesModel.get('minAngle') * RADIAN;\n    var validDataCount = 0;\n    data.each('value', function (value) {\n      !isNaN(value) && validDataCount++;\n    });\n    var sum = data.getSum('value'); // Sum may be 0\n\n    var unitRadian = Math.PI / (sum || validDataCount) * 2;\n    var clockwise = seriesModel.get('clockwise');\n    var roseType = seriesModel.get('roseType');\n    var stillShowZeroSum = seriesModel.get('stillShowZeroSum'); // [0...max]\n\n    var extent = data.getDataExtent('value');\n    extent[0] = 0; // In the case some sector angle is smaller than minAngle\n\n    var restAngle = PI2;\n    var valueSumLargerThanMinAngle = 0;\n    var currentAngle = startAngle;\n    var dir = clockwise ? 1 : -1;\n    data.each('value', function (value, idx) {\n      var angle;\n\n      if (isNaN(value)) {\n        data.setItemLayout(idx, {\n          angle: NaN,\n          startAngle: NaN,\n          endAngle: NaN,\n          clockwise: clockwise,\n          cx: cx,\n          cy: cy,\n          r0: r0,\n          r: roseType ? NaN : r\n        });\n        return;\n      } // FIXME 兼容 2.0 但是 roseType 是 area 的时候才是这样？\n\n\n      if (roseType !== 'area') {\n        angle = sum === 0 && stillShowZeroSum ? unitRadian : value * unitRadian;\n      } else {\n        angle = PI2 / validDataCount;\n      }\n\n      if (angle < minAngle) {\n        angle = minAngle;\n        restAngle -= minAngle;\n      } else {\n        valueSumLargerThanMinAngle += value;\n      }\n\n      var endAngle = currentAngle + dir * angle;\n      data.setItemLayout(idx, {\n        angle: angle,\n        startAngle: currentAngle,\n        endAngle: endAngle,\n        clockwise: clockwise,\n        cx: cx,\n        cy: cy,\n        r0: r0,\n        r: roseType ? linearMap(value, extent, [r0, r]) : r\n      });\n      currentAngle = endAngle;\n    }, true); // Some sector is constrained by minAngle\n    // Rest sectors needs recalculate angle\n\n    if (restAngle < PI2 && validDataCount) {\n      // Average the angle if rest angle is not enough after all angles is\n      // Constrained by minAngle\n      if (restAngle <= 1e-3) {\n        var angle = PI2 / validDataCount;\n        data.each('value', function (value, idx) {\n          if (!isNaN(value)) {\n            var layout = data.getItemLayout(idx);\n            layout.angle = angle;\n            layout.startAngle = startAngle + dir * idx * angle;\n            layout.endAngle = startAngle + dir * (idx + 1) * angle;\n          }\n        });\n      } else {\n        unitRadian = restAngle / valueSumLargerThanMinAngle;\n        currentAngle = startAngle;\n        data.each('value', function (value, idx) {\n          if (!isNaN(value)) {\n            var layout = data.getItemLayout(idx);\n            var angle = layout.angle === minAngle ? minAngle : value * unitRadian;\n            layout.startAngle = currentAngle;\n            layout.endAngle = currentAngle + dir * angle;\n            currentAngle += dir * angle;\n          }\n        });\n      }\n    }\n\n    labelLayout(seriesModel, r, width, height);\n  });\n}\n\nmodule.exports = _default;","map":{"version":3,"sources":["/home/martin/Escritorio/Taller de Integracion/Tarea3-TallerDeIntegracion/node_modules/react-echarts/node_modules/echarts/lib/chart/pie/pieLayout.js"],"names":["_number","require","parsePercent","linearMap","labelLayout","zrUtil","PI2","Math","PI","RADIAN","_default","seriesType","ecModel","api","payload","eachSeriesByType","seriesModel","center","get","radius","isArray","width","getWidth","height","getHeight","size","min","cx","cy","r0","r","data","getData","startAngle","minAngle","validDataCount","each","value","isNaN","sum","getSum","unitRadian","clockwise","roseType","stillShowZeroSum","extent","getDataExtent","restAngle","valueSumLargerThanMinAngle","currentAngle","dir","idx","angle","setItemLayout","NaN","endAngle","layout","getItemLayout","module","exports"],"mappings":"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","sourcesContent":["var _number = require(\"../../util/number\");\n\nvar parsePercent = _number.parsePercent;\nvar linearMap = _number.linearMap;\n\nvar labelLayout = require(\"./labelLayout\");\n\nvar zrUtil = require(\"zrender/lib/core/util\");\n\nvar PI2 = Math.PI * 2;\nvar RADIAN = Math.PI / 180;\n\nfunction _default(seriesType, ecModel, api, payload) {\n  ecModel.eachSeriesByType(seriesType, function (seriesModel) {\n    var center = seriesModel.get('center');\n    var radius = seriesModel.get('radius');\n\n    if (!zrUtil.isArray(radius)) {\n      radius = [0, radius];\n    }\n\n    if (!zrUtil.isArray(center)) {\n      center = [center, center];\n    }\n\n    var width = api.getWidth();\n    var height = api.getHeight();\n    var size = Math.min(width, height);\n    var cx = parsePercent(center[0], width);\n    var cy = parsePercent(center[1], height);\n    var r0 = parsePercent(radius[0], size / 2);\n    var r = parsePercent(radius[1], size / 2);\n    var data = seriesModel.getData();\n    var startAngle = -seriesModel.get('startAngle') * RADIAN;\n    var minAngle = seriesModel.get('minAngle') * RADIAN;\n    var validDataCount = 0;\n    data.each('value', function (value) {\n      !isNaN(value) && validDataCount++;\n    });\n    var sum = data.getSum('value'); // Sum may be 0\n\n    var unitRadian = Math.PI / (sum || validDataCount) * 2;\n    var clockwise = seriesModel.get('clockwise');\n    var roseType = seriesModel.get('roseType');\n    var stillShowZeroSum = seriesModel.get('stillShowZeroSum'); // [0...max]\n\n    var extent = data.getDataExtent('value');\n    extent[0] = 0; // In the case some sector angle is smaller than minAngle\n\n    var restAngle = PI2;\n    var valueSumLargerThanMinAngle = 0;\n    var currentAngle = startAngle;\n    var dir = clockwise ? 1 : -1;\n    data.each('value', function (value, idx) {\n      var angle;\n\n      if (isNaN(value)) {\n        data.setItemLayout(idx, {\n          angle: NaN,\n          startAngle: NaN,\n          endAngle: NaN,\n          clockwise: clockwise,\n          cx: cx,\n          cy: cy,\n          r0: r0,\n          r: roseType ? NaN : r\n        });\n        return;\n      } // FIXME 兼容 2.0 但是 roseType 是 area 的时候才是这样？\n\n\n      if (roseType !== 'area') {\n        angle = sum === 0 && stillShowZeroSum ? unitRadian : value * unitRadian;\n      } else {\n        angle = PI2 / validDataCount;\n      }\n\n      if (angle < minAngle) {\n        angle = minAngle;\n        restAngle -= minAngle;\n      } else {\n        valueSumLargerThanMinAngle += value;\n      }\n\n      var endAngle = currentAngle + dir * angle;\n      data.setItemLayout(idx, {\n        angle: angle,\n        startAngle: currentAngle,\n        endAngle: endAngle,\n        clockwise: clockwise,\n        cx: cx,\n        cy: cy,\n        r0: r0,\n        r: roseType ? linearMap(value, extent, [r0, r]) : r\n      });\n      currentAngle = endAngle;\n    }, true); // Some sector is constrained by minAngle\n    // Rest sectors needs recalculate angle\n\n    if (restAngle < PI2 && validDataCount) {\n      // Average the angle if rest angle is not enough after all angles is\n      // Constrained by minAngle\n      if (restAngle <= 1e-3) {\n        var angle = PI2 / validDataCount;\n        data.each('value', function (value, idx) {\n          if (!isNaN(value)) {\n            var layout = data.getItemLayout(idx);\n            layout.angle = angle;\n            layout.startAngle = startAngle + dir * idx * angle;\n            layout.endAngle = startAngle + dir * (idx + 1) * angle;\n          }\n        });\n      } else {\n        unitRadian = restAngle / valueSumLargerThanMinAngle;\n        currentAngle = startAngle;\n        data.each('value', function (value, idx) {\n          if (!isNaN(value)) {\n            var layout = data.getItemLayout(idx);\n            var angle = layout.angle === minAngle ? minAngle : value * unitRadian;\n            layout.startAngle = currentAngle;\n            layout.endAngle = currentAngle + dir * angle;\n            currentAngle += dir * angle;\n          }\n        });\n      }\n    }\n\n    labelLayout(seriesModel, r, width, height);\n  });\n}\n\nmodule.exports = _default;"]},"metadata":{},"sourceType":"script"}