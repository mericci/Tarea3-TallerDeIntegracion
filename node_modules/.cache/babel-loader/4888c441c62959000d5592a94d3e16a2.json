{"ast":null,"code":"var _config = require(\"../config\");\n\nvar __DEV__ = _config.__DEV__;\n\nvar zrUtil = require(\"zrender/lib/core/util\");\n\nvar modelUtil = require(\"../util/model\");\n\nvar Model = require(\"./Model\");\n\nvar ComponentModel = require(\"./Component\");\n\nvar globalDefault = require(\"./globalDefault\");\n\nvar colorPaletteMinin = require(\"./mixin/colorPalette\");\n/**\n * ECharts global model\n *\n * @module {echarts/model/Global}\n */\n\n/**\n * Caution: If the mechanism should be changed some day, these cases\n * should be considered:\n *\n * (1) In `merge option` mode, if using the same option to call `setOption`\n * many times, the result should be the same (try our best to ensure that).\n * (2) In `merge option` mode, if a component has no id/name specified, it\n * will be merged by index, and the result sequence of the components is\n * consistent to the original sequence.\n * (3) `reset` feature (in toolbox). Find detailed info in comments about\n * `mergeOption` in module:echarts/model/OptionManager.\n */\n\n\nvar each = zrUtil.each;\nvar filter = zrUtil.filter;\nvar map = zrUtil.map;\nvar isArray = zrUtil.isArray;\nvar indexOf = zrUtil.indexOf;\nvar isObject = zrUtil.isObject;\nvar OPTION_INNER_KEY = '\\0_ec_inner';\n/**\n * @alias module:echarts/model/Global\n *\n * @param {Object} option\n * @param {module:echarts/model/Model} parentModel\n * @param {Object} theme\n */\n\nvar GlobalModel = Model.extend({\n  constructor: GlobalModel,\n  init: function (option, parentModel, theme, optionManager) {\n    theme = theme || {};\n    this.option = null; // Mark as not initialized.\n\n    /**\n     * @type {module:echarts/model/Model}\n     * @private\n     */\n\n    this._theme = new Model(theme);\n    /**\n     * @type {module:echarts/model/OptionManager}\n     */\n\n    this._optionManager = optionManager;\n  },\n  setOption: function (option, optionPreprocessorFuncs) {\n    zrUtil.assert(!(OPTION_INNER_KEY in option), 'please use chart.getOption()');\n\n    this._optionManager.setOption(option, optionPreprocessorFuncs);\n\n    this.resetOption(null);\n  },\n\n  /**\n   * @param {string} type null/undefined: reset all.\n   *                      'recreate': force recreate all.\n   *                      'timeline': only reset timeline option\n   *                      'media': only reset media query option\n   * @return {boolean} Whether option changed.\n   */\n  resetOption: function (type) {\n    var optionChanged = false;\n    var optionManager = this._optionManager;\n\n    if (!type || type === 'recreate') {\n      var baseOption = optionManager.mountOption(type === 'recreate');\n\n      if (!this.option || type === 'recreate') {\n        initBase.call(this, baseOption);\n      } else {\n        this.restoreData();\n        this.mergeOption(baseOption);\n      }\n\n      optionChanged = true;\n    }\n\n    if (type === 'timeline' || type === 'media') {\n      this.restoreData();\n    }\n\n    if (!type || type === 'recreate' || type === 'timeline') {\n      var timelineOption = optionManager.getTimelineOption(this);\n      timelineOption && (this.mergeOption(timelineOption), optionChanged = true);\n    }\n\n    if (!type || type === 'recreate' || type === 'media') {\n      var mediaOptions = optionManager.getMediaOption(this, this._api);\n\n      if (mediaOptions.length) {\n        each(mediaOptions, function (mediaOption) {\n          this.mergeOption(mediaOption, optionChanged = true);\n        }, this);\n      }\n    }\n\n    return optionChanged;\n  },\n\n  /**\n   * @protected\n   */\n  mergeOption: function (newOption) {\n    var option = this.option;\n    var componentsMap = this._componentsMap;\n    var newCptTypes = []; // 如果不存在对应的 component model 则直接 merge\n\n    each(newOption, function (componentOption, mainType) {\n      if (componentOption == null) {\n        return;\n      }\n\n      if (!ComponentModel.hasClass(mainType)) {\n        option[mainType] = option[mainType] == null ? zrUtil.clone(componentOption) : zrUtil.merge(option[mainType], componentOption, true);\n      } else {\n        newCptTypes.push(mainType);\n      }\n    }); // FIXME OPTION 同步是否要改回原来的\n\n    ComponentModel.topologicalTravel(newCptTypes, ComponentModel.getAllClassMainTypes(), visitComponent, this);\n    this._seriesIndices = this._seriesIndices || [];\n\n    function visitComponent(mainType, dependencies) {\n      var newCptOptionList = modelUtil.normalizeToArray(newOption[mainType]);\n      var mapResult = modelUtil.mappingToExists(componentsMap.get(mainType), newCptOptionList);\n      modelUtil.makeIdAndName(mapResult); // Set mainType and complete subType.\n\n      each(mapResult, function (item, index) {\n        var opt = item.option;\n\n        if (isObject(opt)) {\n          item.keyInfo.mainType = mainType;\n          item.keyInfo.subType = determineSubType(mainType, opt, item.exist);\n        }\n      });\n      var dependentModels = getComponentsByTypes(componentsMap, dependencies);\n      option[mainType] = [];\n      componentsMap.set(mainType, []);\n      each(mapResult, function (resultItem, index) {\n        var componentModel = resultItem.exist;\n        var newCptOption = resultItem.option;\n        zrUtil.assert(isObject(newCptOption) || componentModel, 'Empty component definition'); // Consider where is no new option and should be merged using {},\n        // see removeEdgeAndAdd in topologicalTravel and\n        // ComponentModel.getAllClassMainTypes.\n\n        if (!newCptOption) {\n          componentModel.mergeOption({}, this);\n          componentModel.optionUpdated({}, false);\n        } else {\n          var ComponentModelClass = ComponentModel.getClass(mainType, resultItem.keyInfo.subType, true);\n\n          if (componentModel && componentModel instanceof ComponentModelClass) {\n            componentModel.name = resultItem.keyInfo.name;\n            componentModel.mergeOption(newCptOption, this);\n            componentModel.optionUpdated(newCptOption, false);\n          } else {\n            // PENDING Global as parent ?\n            var extraOpt = zrUtil.extend({\n              dependentModels: dependentModels,\n              componentIndex: index\n            }, resultItem.keyInfo);\n            componentModel = new ComponentModelClass(newCptOption, this, this, extraOpt);\n            zrUtil.extend(componentModel, extraOpt);\n            componentModel.init(newCptOption, this, this, extraOpt); // Call optionUpdated after init.\n            // newCptOption has been used as componentModel.option\n            // and may be merged with theme and default, so pass null\n            // to avoid confusion.\n\n            componentModel.optionUpdated(null, true);\n          }\n        }\n\n        componentsMap.get(mainType)[index] = componentModel;\n        option[mainType][index] = componentModel.option;\n      }, this); // Backup series for filtering.\n\n      if (mainType === 'series') {\n        this._seriesIndices = createSeriesIndices(componentsMap.get('series'));\n      }\n    }\n  },\n\n  /**\n   * Get option for output (cloned option and inner info removed)\n   * @public\n   * @return {Object}\n   */\n  getOption: function () {\n    var option = zrUtil.clone(this.option);\n    each(option, function (opts, mainType) {\n      if (ComponentModel.hasClass(mainType)) {\n        var opts = modelUtil.normalizeToArray(opts);\n\n        for (var i = opts.length - 1; i >= 0; i--) {\n          // Remove options with inner id.\n          if (modelUtil.isIdInner(opts[i])) {\n            opts.splice(i, 1);\n          }\n        }\n\n        option[mainType] = opts;\n      }\n    });\n    delete option[OPTION_INNER_KEY];\n    return option;\n  },\n\n  /**\n   * @return {module:echarts/model/Model}\n   */\n  getTheme: function () {\n    return this._theme;\n  },\n\n  /**\n   * @param {string} mainType\n   * @param {number} [idx=0]\n   * @return {module:echarts/model/Component}\n   */\n  getComponent: function (mainType, idx) {\n    var list = this._componentsMap.get(mainType);\n\n    if (list) {\n      return list[idx || 0];\n    }\n  },\n\n  /**\n   * If none of index and id and name used, return all components with mainType.\n   * @param {Object} condition\n   * @param {string} condition.mainType\n   * @param {string} [condition.subType] If ignore, only query by mainType\n   * @param {number|Array.<number>} [condition.index] Either input index or id or name.\n   * @param {string|Array.<string>} [condition.id] Either input index or id or name.\n   * @param {string|Array.<string>} [condition.name] Either input index or id or name.\n   * @return {Array.<module:echarts/model/Component>}\n   */\n  queryComponents: function (condition) {\n    var mainType = condition.mainType;\n\n    if (!mainType) {\n      return [];\n    }\n\n    var index = condition.index;\n    var id = condition.id;\n    var name = condition.name;\n\n    var cpts = this._componentsMap.get(mainType);\n\n    if (!cpts || !cpts.length) {\n      return [];\n    }\n\n    var result;\n\n    if (index != null) {\n      if (!isArray(index)) {\n        index = [index];\n      }\n\n      result = filter(map(index, function (idx) {\n        return cpts[idx];\n      }), function (val) {\n        return !!val;\n      });\n    } else if (id != null) {\n      var isIdArray = isArray(id);\n      result = filter(cpts, function (cpt) {\n        return isIdArray && indexOf(id, cpt.id) >= 0 || !isIdArray && cpt.id === id;\n      });\n    } else if (name != null) {\n      var isNameArray = isArray(name);\n      result = filter(cpts, function (cpt) {\n        return isNameArray && indexOf(name, cpt.name) >= 0 || !isNameArray && cpt.name === name;\n      });\n    } else {\n      // Return all components with mainType\n      result = cpts.slice();\n    }\n\n    return filterBySubType(result, condition);\n  },\n\n  /**\n   * The interface is different from queryComponents,\n   * which is convenient for inner usage.\n   *\n   * @usage\n   * var result = findComponents(\n   *     {mainType: 'dataZoom', query: {dataZoomId: 'abc'}}\n   * );\n   * var result = findComponents(\n   *     {mainType: 'series', subType: 'pie', query: {seriesName: 'uio'}}\n   * );\n   * var result = findComponents(\n   *     {mainType: 'series'},\n   *     function (model, index) {...}\n   * );\n   * // result like [component0, componnet1, ...]\n   *\n   * @param {Object} condition\n   * @param {string} condition.mainType Mandatory.\n   * @param {string} [condition.subType] Optional.\n   * @param {Object} [condition.query] like {xxxIndex, xxxId, xxxName},\n   *        where xxx is mainType.\n   *        If query attribute is null/undefined or has no index/id/name,\n   *        do not filtering by query conditions, which is convenient for\n   *        no-payload situations or when target of action is global.\n   * @param {Function} [condition.filter] parameter: component, return boolean.\n   * @return {Array.<module:echarts/model/Component>}\n   */\n  findComponents: function (condition) {\n    var query = condition.query;\n    var mainType = condition.mainType;\n    var queryCond = getQueryCond(query);\n    var result = queryCond ? this.queryComponents(queryCond) : this._componentsMap.get(mainType);\n    return doFilter(filterBySubType(result, condition));\n\n    function getQueryCond(q) {\n      var indexAttr = mainType + 'Index';\n      var idAttr = mainType + 'Id';\n      var nameAttr = mainType + 'Name';\n      return q && (q[indexAttr] != null || q[idAttr] != null || q[nameAttr] != null) ? {\n        mainType: mainType,\n        // subType will be filtered finally.\n        index: q[indexAttr],\n        id: q[idAttr],\n        name: q[nameAttr]\n      } : null;\n    }\n\n    function doFilter(res) {\n      return condition.filter ? filter(res, condition.filter) : res;\n    }\n  },\n\n  /**\n   * @usage\n   * eachComponent('legend', function (legendModel, index) {\n   *     ...\n   * });\n   * eachComponent(function (componentType, model, index) {\n   *     // componentType does not include subType\n   *     // (componentType is 'xxx' but not 'xxx.aa')\n   * });\n   * eachComponent(\n   *     {mainType: 'dataZoom', query: {dataZoomId: 'abc'}},\n   *     function (model, index) {...}\n   * );\n   * eachComponent(\n   *     {mainType: 'series', subType: 'pie', query: {seriesName: 'uio'}},\n   *     function (model, index) {...}\n   * );\n   *\n   * @param {string|Object=} mainType When mainType is object, the definition\n   *                                  is the same as the method 'findComponents'.\n   * @param {Function} cb\n   * @param {*} context\n   */\n  eachComponent: function (mainType, cb, context) {\n    var componentsMap = this._componentsMap;\n\n    if (typeof mainType === 'function') {\n      context = cb;\n      cb = mainType;\n      componentsMap.each(function (components, componentType) {\n        each(components, function (component, index) {\n          cb.call(context, componentType, component, index);\n        });\n      });\n    } else if (zrUtil.isString(mainType)) {\n      each(componentsMap.get(mainType), cb, context);\n    } else if (isObject(mainType)) {\n      var queryResult = this.findComponents(mainType);\n      each(queryResult, cb, context);\n    }\n  },\n\n  /**\n   * @param {string} name\n   * @return {Array.<module:echarts/model/Series>}\n   */\n  getSeriesByName: function (name) {\n    var series = this._componentsMap.get('series');\n\n    return filter(series, function (oneSeries) {\n      return oneSeries.name === name;\n    });\n  },\n\n  /**\n   * @param {number} seriesIndex\n   * @return {module:echarts/model/Series}\n   */\n  getSeriesByIndex: function (seriesIndex) {\n    return this._componentsMap.get('series')[seriesIndex];\n  },\n\n  /**\n   * @param {string} subType\n   * @return {Array.<module:echarts/model/Series>}\n   */\n  getSeriesByType: function (subType) {\n    var series = this._componentsMap.get('series');\n\n    return filter(series, function (oneSeries) {\n      return oneSeries.subType === subType;\n    });\n  },\n\n  /**\n   * @return {Array.<module:echarts/model/Series>}\n   */\n  getSeries: function () {\n    return this._componentsMap.get('series').slice();\n  },\n\n  /**\n   * After filtering, series may be different\n   * frome raw series.\n   *\n   * @param {Function} cb\n   * @param {*} context\n   */\n  eachSeries: function (cb, context) {\n    assertSeriesInitialized(this);\n    each(this._seriesIndices, function (rawSeriesIndex) {\n      var series = this._componentsMap.get('series')[rawSeriesIndex];\n\n      cb.call(context, series, rawSeriesIndex);\n    }, this);\n  },\n\n  /**\n   * Iterate raw series before filtered.\n   *\n   * @param {Function} cb\n   * @param {*} context\n   */\n  eachRawSeries: function (cb, context) {\n    each(this._componentsMap.get('series'), cb, context);\n  },\n\n  /**\n   * After filtering, series may be different.\n   * frome raw series.\n   *\n   * @parma {string} subType\n   * @param {Function} cb\n   * @param {*} context\n   */\n  eachSeriesByType: function (subType, cb, context) {\n    assertSeriesInitialized(this);\n    each(this._seriesIndices, function (rawSeriesIndex) {\n      var series = this._componentsMap.get('series')[rawSeriesIndex];\n\n      if (series.subType === subType) {\n        cb.call(context, series, rawSeriesIndex);\n      }\n    }, this);\n  },\n\n  /**\n   * Iterate raw series before filtered of given type.\n   *\n   * @parma {string} subType\n   * @param {Function} cb\n   * @param {*} context\n   */\n  eachRawSeriesByType: function (subType, cb, context) {\n    return each(this.getSeriesByType(subType), cb, context);\n  },\n\n  /**\n   * @param {module:echarts/model/Series} seriesModel\n   */\n  isSeriesFiltered: function (seriesModel) {\n    assertSeriesInitialized(this);\n    return zrUtil.indexOf(this._seriesIndices, seriesModel.componentIndex) < 0;\n  },\n\n  /**\n   * @return {Array.<number>}\n   */\n  getCurrentSeriesIndices: function () {\n    return (this._seriesIndices || []).slice();\n  },\n\n  /**\n   * @param {Function} cb\n   * @param {*} context\n   */\n  filterSeries: function (cb, context) {\n    assertSeriesInitialized(this);\n    var filteredSeries = filter(this._componentsMap.get('series'), cb, context);\n    this._seriesIndices = createSeriesIndices(filteredSeries);\n  },\n  restoreData: function () {\n    var componentsMap = this._componentsMap;\n    this._seriesIndices = createSeriesIndices(componentsMap.get('series'));\n    var componentTypes = [];\n    componentsMap.each(function (components, componentType) {\n      componentTypes.push(componentType);\n    });\n    ComponentModel.topologicalTravel(componentTypes, ComponentModel.getAllClassMainTypes(), function (componentType, dependencies) {\n      each(componentsMap.get(componentType), function (component) {\n        component.restoreData();\n      });\n    });\n  }\n});\n/**\n * @inner\n */\n\nfunction mergeTheme(option, theme) {\n  zrUtil.each(theme, function (themeItem, name) {\n    // 如果有 component model 则把具体的 merge 逻辑交给该 model 处理\n    if (!ComponentModel.hasClass(name)) {\n      if (typeof themeItem === 'object') {\n        option[name] = !option[name] ? zrUtil.clone(themeItem) : zrUtil.merge(option[name], themeItem, false);\n      } else {\n        if (option[name] == null) {\n          option[name] = themeItem;\n        }\n      }\n    }\n  });\n}\n\nfunction initBase(baseOption) {\n  baseOption = baseOption; // Using OPTION_INNER_KEY to mark that this option can not be used outside,\n  // i.e. `chart.setOption(chart.getModel().option);` is forbiden.\n\n  this.option = {};\n  this.option[OPTION_INNER_KEY] = 1;\n  /**\n   * Init with series: [], in case of calling findSeries method\n   * before series initialized.\n   * @type {Object.<string, Array.<module:echarts/model/Model>>}\n   * @private\n   */\n\n  this._componentsMap = zrUtil.createHashMap({\n    series: []\n  });\n  /**\n   * Mapping between filtered series list and raw series list.\n   * key: filtered series indices, value: raw series indices.\n   * @type {Array.<nubmer>}\n   * @private\n   */\n\n  this._seriesIndices = null;\n  mergeTheme(baseOption, this._theme.option); // TODO Needs clone when merging to the unexisted property\n\n  zrUtil.merge(baseOption, globalDefault, false);\n  this.mergeOption(baseOption);\n}\n/**\n * @inner\n * @param {Array.<string>|string} types model types\n * @return {Object} key: {string} type, value: {Array.<Object>} models\n */\n\n\nfunction getComponentsByTypes(componentsMap, types) {\n  if (!zrUtil.isArray(types)) {\n    types = types ? [types] : [];\n  }\n\n  var ret = {};\n  each(types, function (type) {\n    ret[type] = (componentsMap.get(type) || []).slice();\n  });\n  return ret;\n}\n/**\n * @inner\n */\n\n\nfunction determineSubType(mainType, newCptOption, existComponent) {\n  var subType = newCptOption.type ? newCptOption.type : existComponent ? existComponent.subType // Use determineSubType only when there is no existComponent.\n  : ComponentModel.determineSubType(mainType, newCptOption); // tooltip, markline, markpoint may always has no subType\n\n  return subType;\n}\n/**\n * @inner\n */\n\n\nfunction createSeriesIndices(seriesModels) {\n  return map(seriesModels, function (series) {\n    return series.componentIndex;\n  }) || [];\n}\n/**\n * @inner\n */\n\n\nfunction filterBySubType(components, condition) {\n  // Using hasOwnProperty for restrict. Consider\n  // subType is undefined in user payload.\n  return condition.hasOwnProperty('subType') ? filter(components, function (cpt) {\n    return cpt.subType === condition.subType;\n  }) : components;\n}\n/**\n * @inner\n */\n\n\nfunction assertSeriesInitialized(ecModel) {}\n\nzrUtil.mixin(GlobalModel, colorPaletteMinin);\nvar _default = GlobalModel;\nmodule.exports = _default;","map":{"version":3,"sources":["/home/martin/Escritorio/Taller de Integracion/Tarea3-TallerDeIntegracion/node_modules/react-echarts/node_modules/echarts/lib/model/Global.js"],"names":["_config","require","__DEV__","zrUtil","modelUtil","Model","ComponentModel","globalDefault","colorPaletteMinin","each","filter","map","isArray","indexOf","isObject","OPTION_INNER_KEY","GlobalModel","extend","constructor","init","option","parentModel","theme","optionManager","_theme","_optionManager","setOption","optionPreprocessorFuncs","assert","resetOption","type","optionChanged","baseOption","mountOption","initBase","call","restoreData","mergeOption","timelineOption","getTimelineOption","mediaOptions","getMediaOption","_api","length","mediaOption","newOption","componentsMap","_componentsMap","newCptTypes","componentOption","mainType","hasClass","clone","merge","push","topologicalTravel","getAllClassMainTypes","visitComponent","_seriesIndices","dependencies","newCptOptionList","normalizeToArray","mapResult","mappingToExists","get","makeIdAndName","item","index","opt","keyInfo","subType","determineSubType","exist","dependentModels","getComponentsByTypes","set","resultItem","componentModel","newCptOption","optionUpdated","ComponentModelClass","getClass","name","extraOpt","componentIndex","createSeriesIndices","getOption","opts","i","isIdInner","splice","getTheme","getComponent","idx","list","queryComponents","condition","id","cpts","result","val","isIdArray","cpt","isNameArray","slice","filterBySubType","findComponents","query","queryCond","getQueryCond","doFilter","q","indexAttr","idAttr","nameAttr","res","eachComponent","cb","context","components","componentType","component","isString","queryResult","getSeriesByName","series","oneSeries","getSeriesByIndex","seriesIndex","getSeriesByType","getSeries","eachSeries","assertSeriesInitialized","rawSeriesIndex","eachRawSeries","eachSeriesByType","eachRawSeriesByType","isSeriesFiltered","seriesModel","getCurrentSeriesIndices","filterSeries","filteredSeries","componentTypes","mergeTheme","themeItem","createHashMap","types","ret","existComponent","seriesModels","hasOwnProperty","ecModel","mixin","_default","module","exports"],"mappings":"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","sourcesContent":["var _config = require(\"../config\");\n\nvar __DEV__ = _config.__DEV__;\n\nvar zrUtil = require(\"zrender/lib/core/util\");\n\nvar modelUtil = require(\"../util/model\");\n\nvar Model = require(\"./Model\");\n\nvar ComponentModel = require(\"./Component\");\n\nvar globalDefault = require(\"./globalDefault\");\n\nvar colorPaletteMinin = require(\"./mixin/colorPalette\");\n\n/**\n * ECharts global model\n *\n * @module {echarts/model/Global}\n */\n\n/**\n * Caution: If the mechanism should be changed some day, these cases\n * should be considered:\n *\n * (1) In `merge option` mode, if using the same option to call `setOption`\n * many times, the result should be the same (try our best to ensure that).\n * (2) In `merge option` mode, if a component has no id/name specified, it\n * will be merged by index, and the result sequence of the components is\n * consistent to the original sequence.\n * (3) `reset` feature (in toolbox). Find detailed info in comments about\n * `mergeOption` in module:echarts/model/OptionManager.\n */\nvar each = zrUtil.each;\nvar filter = zrUtil.filter;\nvar map = zrUtil.map;\nvar isArray = zrUtil.isArray;\nvar indexOf = zrUtil.indexOf;\nvar isObject = zrUtil.isObject;\nvar OPTION_INNER_KEY = '\\0_ec_inner';\n/**\n * @alias module:echarts/model/Global\n *\n * @param {Object} option\n * @param {module:echarts/model/Model} parentModel\n * @param {Object} theme\n */\n\nvar GlobalModel = Model.extend({\n  constructor: GlobalModel,\n  init: function (option, parentModel, theme, optionManager) {\n    theme = theme || {};\n    this.option = null; // Mark as not initialized.\n\n    /**\n     * @type {module:echarts/model/Model}\n     * @private\n     */\n\n    this._theme = new Model(theme);\n    /**\n     * @type {module:echarts/model/OptionManager}\n     */\n\n    this._optionManager = optionManager;\n  },\n  setOption: function (option, optionPreprocessorFuncs) {\n    zrUtil.assert(!(OPTION_INNER_KEY in option), 'please use chart.getOption()');\n\n    this._optionManager.setOption(option, optionPreprocessorFuncs);\n\n    this.resetOption(null);\n  },\n\n  /**\n   * @param {string} type null/undefined: reset all.\n   *                      'recreate': force recreate all.\n   *                      'timeline': only reset timeline option\n   *                      'media': only reset media query option\n   * @return {boolean} Whether option changed.\n   */\n  resetOption: function (type) {\n    var optionChanged = false;\n    var optionManager = this._optionManager;\n\n    if (!type || type === 'recreate') {\n      var baseOption = optionManager.mountOption(type === 'recreate');\n\n      if (!this.option || type === 'recreate') {\n        initBase.call(this, baseOption);\n      } else {\n        this.restoreData();\n        this.mergeOption(baseOption);\n      }\n\n      optionChanged = true;\n    }\n\n    if (type === 'timeline' || type === 'media') {\n      this.restoreData();\n    }\n\n    if (!type || type === 'recreate' || type === 'timeline') {\n      var timelineOption = optionManager.getTimelineOption(this);\n      timelineOption && (this.mergeOption(timelineOption), optionChanged = true);\n    }\n\n    if (!type || type === 'recreate' || type === 'media') {\n      var mediaOptions = optionManager.getMediaOption(this, this._api);\n\n      if (mediaOptions.length) {\n        each(mediaOptions, function (mediaOption) {\n          this.mergeOption(mediaOption, optionChanged = true);\n        }, this);\n      }\n    }\n\n    return optionChanged;\n  },\n\n  /**\n   * @protected\n   */\n  mergeOption: function (newOption) {\n    var option = this.option;\n    var componentsMap = this._componentsMap;\n    var newCptTypes = []; // 如果不存在对应的 component model 则直接 merge\n\n    each(newOption, function (componentOption, mainType) {\n      if (componentOption == null) {\n        return;\n      }\n\n      if (!ComponentModel.hasClass(mainType)) {\n        option[mainType] = option[mainType] == null ? zrUtil.clone(componentOption) : zrUtil.merge(option[mainType], componentOption, true);\n      } else {\n        newCptTypes.push(mainType);\n      }\n    }); // FIXME OPTION 同步是否要改回原来的\n\n    ComponentModel.topologicalTravel(newCptTypes, ComponentModel.getAllClassMainTypes(), visitComponent, this);\n    this._seriesIndices = this._seriesIndices || [];\n\n    function visitComponent(mainType, dependencies) {\n      var newCptOptionList = modelUtil.normalizeToArray(newOption[mainType]);\n      var mapResult = modelUtil.mappingToExists(componentsMap.get(mainType), newCptOptionList);\n      modelUtil.makeIdAndName(mapResult); // Set mainType and complete subType.\n\n      each(mapResult, function (item, index) {\n        var opt = item.option;\n\n        if (isObject(opt)) {\n          item.keyInfo.mainType = mainType;\n          item.keyInfo.subType = determineSubType(mainType, opt, item.exist);\n        }\n      });\n      var dependentModels = getComponentsByTypes(componentsMap, dependencies);\n      option[mainType] = [];\n      componentsMap.set(mainType, []);\n      each(mapResult, function (resultItem, index) {\n        var componentModel = resultItem.exist;\n        var newCptOption = resultItem.option;\n        zrUtil.assert(isObject(newCptOption) || componentModel, 'Empty component definition'); // Consider where is no new option and should be merged using {},\n        // see removeEdgeAndAdd in topologicalTravel and\n        // ComponentModel.getAllClassMainTypes.\n\n        if (!newCptOption) {\n          componentModel.mergeOption({}, this);\n          componentModel.optionUpdated({}, false);\n        } else {\n          var ComponentModelClass = ComponentModel.getClass(mainType, resultItem.keyInfo.subType, true);\n\n          if (componentModel && componentModel instanceof ComponentModelClass) {\n            componentModel.name = resultItem.keyInfo.name;\n            componentModel.mergeOption(newCptOption, this);\n            componentModel.optionUpdated(newCptOption, false);\n          } else {\n            // PENDING Global as parent ?\n            var extraOpt = zrUtil.extend({\n              dependentModels: dependentModels,\n              componentIndex: index\n            }, resultItem.keyInfo);\n            componentModel = new ComponentModelClass(newCptOption, this, this, extraOpt);\n            zrUtil.extend(componentModel, extraOpt);\n            componentModel.init(newCptOption, this, this, extraOpt); // Call optionUpdated after init.\n            // newCptOption has been used as componentModel.option\n            // and may be merged with theme and default, so pass null\n            // to avoid confusion.\n\n            componentModel.optionUpdated(null, true);\n          }\n        }\n\n        componentsMap.get(mainType)[index] = componentModel;\n        option[mainType][index] = componentModel.option;\n      }, this); // Backup series for filtering.\n\n      if (mainType === 'series') {\n        this._seriesIndices = createSeriesIndices(componentsMap.get('series'));\n      }\n    }\n  },\n\n  /**\n   * Get option for output (cloned option and inner info removed)\n   * @public\n   * @return {Object}\n   */\n  getOption: function () {\n    var option = zrUtil.clone(this.option);\n    each(option, function (opts, mainType) {\n      if (ComponentModel.hasClass(mainType)) {\n        var opts = modelUtil.normalizeToArray(opts);\n\n        for (var i = opts.length - 1; i >= 0; i--) {\n          // Remove options with inner id.\n          if (modelUtil.isIdInner(opts[i])) {\n            opts.splice(i, 1);\n          }\n        }\n\n        option[mainType] = opts;\n      }\n    });\n    delete option[OPTION_INNER_KEY];\n    return option;\n  },\n\n  /**\n   * @return {module:echarts/model/Model}\n   */\n  getTheme: function () {\n    return this._theme;\n  },\n\n  /**\n   * @param {string} mainType\n   * @param {number} [idx=0]\n   * @return {module:echarts/model/Component}\n   */\n  getComponent: function (mainType, idx) {\n    var list = this._componentsMap.get(mainType);\n\n    if (list) {\n      return list[idx || 0];\n    }\n  },\n\n  /**\n   * If none of index and id and name used, return all components with mainType.\n   * @param {Object} condition\n   * @param {string} condition.mainType\n   * @param {string} [condition.subType] If ignore, only query by mainType\n   * @param {number|Array.<number>} [condition.index] Either input index or id or name.\n   * @param {string|Array.<string>} [condition.id] Either input index or id or name.\n   * @param {string|Array.<string>} [condition.name] Either input index or id or name.\n   * @return {Array.<module:echarts/model/Component>}\n   */\n  queryComponents: function (condition) {\n    var mainType = condition.mainType;\n\n    if (!mainType) {\n      return [];\n    }\n\n    var index = condition.index;\n    var id = condition.id;\n    var name = condition.name;\n\n    var cpts = this._componentsMap.get(mainType);\n\n    if (!cpts || !cpts.length) {\n      return [];\n    }\n\n    var result;\n\n    if (index != null) {\n      if (!isArray(index)) {\n        index = [index];\n      }\n\n      result = filter(map(index, function (idx) {\n        return cpts[idx];\n      }), function (val) {\n        return !!val;\n      });\n    } else if (id != null) {\n      var isIdArray = isArray(id);\n      result = filter(cpts, function (cpt) {\n        return isIdArray && indexOf(id, cpt.id) >= 0 || !isIdArray && cpt.id === id;\n      });\n    } else if (name != null) {\n      var isNameArray = isArray(name);\n      result = filter(cpts, function (cpt) {\n        return isNameArray && indexOf(name, cpt.name) >= 0 || !isNameArray && cpt.name === name;\n      });\n    } else {\n      // Return all components with mainType\n      result = cpts.slice();\n    }\n\n    return filterBySubType(result, condition);\n  },\n\n  /**\n   * The interface is different from queryComponents,\n   * which is convenient for inner usage.\n   *\n   * @usage\n   * var result = findComponents(\n   *     {mainType: 'dataZoom', query: {dataZoomId: 'abc'}}\n   * );\n   * var result = findComponents(\n   *     {mainType: 'series', subType: 'pie', query: {seriesName: 'uio'}}\n   * );\n   * var result = findComponents(\n   *     {mainType: 'series'},\n   *     function (model, index) {...}\n   * );\n   * // result like [component0, componnet1, ...]\n   *\n   * @param {Object} condition\n   * @param {string} condition.mainType Mandatory.\n   * @param {string} [condition.subType] Optional.\n   * @param {Object} [condition.query] like {xxxIndex, xxxId, xxxName},\n   *        where xxx is mainType.\n   *        If query attribute is null/undefined or has no index/id/name,\n   *        do not filtering by query conditions, which is convenient for\n   *        no-payload situations or when target of action is global.\n   * @param {Function} [condition.filter] parameter: component, return boolean.\n   * @return {Array.<module:echarts/model/Component>}\n   */\n  findComponents: function (condition) {\n    var query = condition.query;\n    var mainType = condition.mainType;\n    var queryCond = getQueryCond(query);\n    var result = queryCond ? this.queryComponents(queryCond) : this._componentsMap.get(mainType);\n    return doFilter(filterBySubType(result, condition));\n\n    function getQueryCond(q) {\n      var indexAttr = mainType + 'Index';\n      var idAttr = mainType + 'Id';\n      var nameAttr = mainType + 'Name';\n      return q && (q[indexAttr] != null || q[idAttr] != null || q[nameAttr] != null) ? {\n        mainType: mainType,\n        // subType will be filtered finally.\n        index: q[indexAttr],\n        id: q[idAttr],\n        name: q[nameAttr]\n      } : null;\n    }\n\n    function doFilter(res) {\n      return condition.filter ? filter(res, condition.filter) : res;\n    }\n  },\n\n  /**\n   * @usage\n   * eachComponent('legend', function (legendModel, index) {\n   *     ...\n   * });\n   * eachComponent(function (componentType, model, index) {\n   *     // componentType does not include subType\n   *     // (componentType is 'xxx' but not 'xxx.aa')\n   * });\n   * eachComponent(\n   *     {mainType: 'dataZoom', query: {dataZoomId: 'abc'}},\n   *     function (model, index) {...}\n   * );\n   * eachComponent(\n   *     {mainType: 'series', subType: 'pie', query: {seriesName: 'uio'}},\n   *     function (model, index) {...}\n   * );\n   *\n   * @param {string|Object=} mainType When mainType is object, the definition\n   *                                  is the same as the method 'findComponents'.\n   * @param {Function} cb\n   * @param {*} context\n   */\n  eachComponent: function (mainType, cb, context) {\n    var componentsMap = this._componentsMap;\n\n    if (typeof mainType === 'function') {\n      context = cb;\n      cb = mainType;\n      componentsMap.each(function (components, componentType) {\n        each(components, function (component, index) {\n          cb.call(context, componentType, component, index);\n        });\n      });\n    } else if (zrUtil.isString(mainType)) {\n      each(componentsMap.get(mainType), cb, context);\n    } else if (isObject(mainType)) {\n      var queryResult = this.findComponents(mainType);\n      each(queryResult, cb, context);\n    }\n  },\n\n  /**\n   * @param {string} name\n   * @return {Array.<module:echarts/model/Series>}\n   */\n  getSeriesByName: function (name) {\n    var series = this._componentsMap.get('series');\n\n    return filter(series, function (oneSeries) {\n      return oneSeries.name === name;\n    });\n  },\n\n  /**\n   * @param {number} seriesIndex\n   * @return {module:echarts/model/Series}\n   */\n  getSeriesByIndex: function (seriesIndex) {\n    return this._componentsMap.get('series')[seriesIndex];\n  },\n\n  /**\n   * @param {string} subType\n   * @return {Array.<module:echarts/model/Series>}\n   */\n  getSeriesByType: function (subType) {\n    var series = this._componentsMap.get('series');\n\n    return filter(series, function (oneSeries) {\n      return oneSeries.subType === subType;\n    });\n  },\n\n  /**\n   * @return {Array.<module:echarts/model/Series>}\n   */\n  getSeries: function () {\n    return this._componentsMap.get('series').slice();\n  },\n\n  /**\n   * After filtering, series may be different\n   * frome raw series.\n   *\n   * @param {Function} cb\n   * @param {*} context\n   */\n  eachSeries: function (cb, context) {\n    assertSeriesInitialized(this);\n    each(this._seriesIndices, function (rawSeriesIndex) {\n      var series = this._componentsMap.get('series')[rawSeriesIndex];\n\n      cb.call(context, series, rawSeriesIndex);\n    }, this);\n  },\n\n  /**\n   * Iterate raw series before filtered.\n   *\n   * @param {Function} cb\n   * @param {*} context\n   */\n  eachRawSeries: function (cb, context) {\n    each(this._componentsMap.get('series'), cb, context);\n  },\n\n  /**\n   * After filtering, series may be different.\n   * frome raw series.\n   *\n   * @parma {string} subType\n   * @param {Function} cb\n   * @param {*} context\n   */\n  eachSeriesByType: function (subType, cb, context) {\n    assertSeriesInitialized(this);\n    each(this._seriesIndices, function (rawSeriesIndex) {\n      var series = this._componentsMap.get('series')[rawSeriesIndex];\n\n      if (series.subType === subType) {\n        cb.call(context, series, rawSeriesIndex);\n      }\n    }, this);\n  },\n\n  /**\n   * Iterate raw series before filtered of given type.\n   *\n   * @parma {string} subType\n   * @param {Function} cb\n   * @param {*} context\n   */\n  eachRawSeriesByType: function (subType, cb, context) {\n    return each(this.getSeriesByType(subType), cb, context);\n  },\n\n  /**\n   * @param {module:echarts/model/Series} seriesModel\n   */\n  isSeriesFiltered: function (seriesModel) {\n    assertSeriesInitialized(this);\n    return zrUtil.indexOf(this._seriesIndices, seriesModel.componentIndex) < 0;\n  },\n\n  /**\n   * @return {Array.<number>}\n   */\n  getCurrentSeriesIndices: function () {\n    return (this._seriesIndices || []).slice();\n  },\n\n  /**\n   * @param {Function} cb\n   * @param {*} context\n   */\n  filterSeries: function (cb, context) {\n    assertSeriesInitialized(this);\n    var filteredSeries = filter(this._componentsMap.get('series'), cb, context);\n    this._seriesIndices = createSeriesIndices(filteredSeries);\n  },\n  restoreData: function () {\n    var componentsMap = this._componentsMap;\n    this._seriesIndices = createSeriesIndices(componentsMap.get('series'));\n    var componentTypes = [];\n    componentsMap.each(function (components, componentType) {\n      componentTypes.push(componentType);\n    });\n    ComponentModel.topologicalTravel(componentTypes, ComponentModel.getAllClassMainTypes(), function (componentType, dependencies) {\n      each(componentsMap.get(componentType), function (component) {\n        component.restoreData();\n      });\n    });\n  }\n});\n/**\n * @inner\n */\n\nfunction mergeTheme(option, theme) {\n  zrUtil.each(theme, function (themeItem, name) {\n    // 如果有 component model 则把具体的 merge 逻辑交给该 model 处理\n    if (!ComponentModel.hasClass(name)) {\n      if (typeof themeItem === 'object') {\n        option[name] = !option[name] ? zrUtil.clone(themeItem) : zrUtil.merge(option[name], themeItem, false);\n      } else {\n        if (option[name] == null) {\n          option[name] = themeItem;\n        }\n      }\n    }\n  });\n}\n\nfunction initBase(baseOption) {\n  baseOption = baseOption; // Using OPTION_INNER_KEY to mark that this option can not be used outside,\n  // i.e. `chart.setOption(chart.getModel().option);` is forbiden.\n\n  this.option = {};\n  this.option[OPTION_INNER_KEY] = 1;\n  /**\n   * Init with series: [], in case of calling findSeries method\n   * before series initialized.\n   * @type {Object.<string, Array.<module:echarts/model/Model>>}\n   * @private\n   */\n\n  this._componentsMap = zrUtil.createHashMap({\n    series: []\n  });\n  /**\n   * Mapping between filtered series list and raw series list.\n   * key: filtered series indices, value: raw series indices.\n   * @type {Array.<nubmer>}\n   * @private\n   */\n\n  this._seriesIndices = null;\n  mergeTheme(baseOption, this._theme.option); // TODO Needs clone when merging to the unexisted property\n\n  zrUtil.merge(baseOption, globalDefault, false);\n  this.mergeOption(baseOption);\n}\n/**\n * @inner\n * @param {Array.<string>|string} types model types\n * @return {Object} key: {string} type, value: {Array.<Object>} models\n */\n\n\nfunction getComponentsByTypes(componentsMap, types) {\n  if (!zrUtil.isArray(types)) {\n    types = types ? [types] : [];\n  }\n\n  var ret = {};\n  each(types, function (type) {\n    ret[type] = (componentsMap.get(type) || []).slice();\n  });\n  return ret;\n}\n/**\n * @inner\n */\n\n\nfunction determineSubType(mainType, newCptOption, existComponent) {\n  var subType = newCptOption.type ? newCptOption.type : existComponent ? existComponent.subType // Use determineSubType only when there is no existComponent.\n  : ComponentModel.determineSubType(mainType, newCptOption); // tooltip, markline, markpoint may always has no subType\n\n  return subType;\n}\n/**\n * @inner\n */\n\n\nfunction createSeriesIndices(seriesModels) {\n  return map(seriesModels, function (series) {\n    return series.componentIndex;\n  }) || [];\n}\n/**\n * @inner\n */\n\n\nfunction filterBySubType(components, condition) {\n  // Using hasOwnProperty for restrict. Consider\n  // subType is undefined in user payload.\n  return condition.hasOwnProperty('subType') ? filter(components, function (cpt) {\n    return cpt.subType === condition.subType;\n  }) : components;\n}\n/**\n * @inner\n */\n\n\nfunction assertSeriesInitialized(ecModel) {}\n\nzrUtil.mixin(GlobalModel, colorPaletteMinin);\nvar _default = GlobalModel;\nmodule.exports = _default;"]},"metadata":{},"sourceType":"script"}