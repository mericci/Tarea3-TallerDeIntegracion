{"ast":null,"code":"var _util = require(\"../../core/util\");\n\nvar retrieve2 = _util.retrieve2;\nvar retrieve3 = _util.retrieve3;\nvar each = _util.each;\nvar normalizeCssArray = _util.normalizeCssArray;\nvar isString = _util.isString;\nvar isObject = _util.isObject;\n\nvar textContain = require(\"../../contain/text\");\n\nvar roundRectHelper = require(\"./roundRect\");\n\nvar imageHelper = require(\"./image\"); // TODO: Have not support 'start', 'end' yet.\n\n\nvar VALID_TEXT_ALIGN = {\n  left: 1,\n  right: 1,\n  center: 1\n};\nvar VALID_TEXT_VERTICAL_ALIGN = {\n  top: 1,\n  bottom: 1,\n  middle: 1\n};\n/**\n * @param {module:zrender/graphic/Style} style\n * @return {module:zrender/graphic/Style} The input style.\n */\n\nfunction normalizeTextStyle(style) {\n  normalizeStyle(style);\n  each(style.rich, normalizeStyle);\n  return style;\n}\n\nfunction normalizeStyle(style) {\n  if (style) {\n    style.font = textContain.makeFont(style);\n    var textAlign = style.textAlign;\n    textAlign === 'middle' && (textAlign = 'center');\n    style.textAlign = textAlign == null || VALID_TEXT_ALIGN[textAlign] ? textAlign : 'left'; // Compatible with textBaseline.\n\n    var textVerticalAlign = style.textVerticalAlign || style.textBaseline;\n    textVerticalAlign === 'center' && (textVerticalAlign = 'middle');\n    style.textVerticalAlign = textVerticalAlign == null || VALID_TEXT_VERTICAL_ALIGN[textVerticalAlign] ? textVerticalAlign : 'top';\n    var textPadding = style.textPadding;\n\n    if (textPadding) {\n      style.textPadding = normalizeCssArray(style.textPadding);\n    }\n  }\n}\n/**\n * @param {CanvasRenderingContext2D} ctx\n * @param {string} text\n * @param {module:zrender/graphic/Style} style\n * @param {Object|boolean} [rect] {x, y, width, height}\n *                  If set false, rect text is not used.\n */\n\n\nfunction renderText(hostEl, ctx, text, style, rect) {\n  style.rich ? renderRichText(hostEl, ctx, text, style, rect) : renderPlainText(hostEl, ctx, text, style, rect);\n}\n\nfunction renderPlainText(hostEl, ctx, text, style, rect) {\n  var font = setCtx(ctx, 'font', style.font || textContain.DEFAULT_FONT);\n  var textPadding = style.textPadding;\n  var contentBlock = hostEl.__textCotentBlock;\n\n  if (!contentBlock || hostEl.__dirty) {\n    contentBlock = hostEl.__textCotentBlock = textContain.parsePlainText(text, font, textPadding, style.truncate);\n  }\n\n  var outerHeight = contentBlock.outerHeight;\n  var textLines = contentBlock.lines;\n  var lineHeight = contentBlock.lineHeight;\n  var boxPos = getBoxPosition(outerHeight, style, rect);\n  var baseX = boxPos.baseX;\n  var baseY = boxPos.baseY;\n  var textAlign = boxPos.textAlign;\n  var textVerticalAlign = boxPos.textVerticalAlign; // Origin of textRotation should be the base point of text drawing.\n\n  applyTextRotation(ctx, style, rect, baseX, baseY);\n  var boxY = textContain.adjustTextY(baseY, outerHeight, textVerticalAlign);\n  var textX = baseX;\n  var textY = boxY;\n  var needDrawBg = needDrawBackground(style);\n\n  if (needDrawBg || textPadding) {\n    // Consider performance, do not call getTextWidth util necessary.\n    var textWidth = textContain.getWidth(text, font);\n    var outerWidth = textWidth;\n    textPadding && (outerWidth += textPadding[1] + textPadding[3]);\n    var boxX = textContain.adjustTextX(baseX, outerWidth, textAlign);\n    needDrawBg && drawBackground(hostEl, ctx, style, boxX, boxY, outerWidth, outerHeight);\n\n    if (textPadding) {\n      textX = getTextXForPadding(baseX, textAlign, textPadding);\n      textY += textPadding[0];\n    }\n  }\n\n  setCtx(ctx, 'textAlign', textAlign || 'left'); // Force baseline to be \"middle\". Otherwise, if using \"top\", the\n  // text will offset downward a little bit in font \"Microsoft YaHei\".\n\n  setCtx(ctx, 'textBaseline', 'middle'); // Always set shadowBlur and shadowOffset to avoid leak from displayable.\n\n  setCtx(ctx, 'shadowBlur', style.textShadowBlur || 0);\n  setCtx(ctx, 'shadowColor', style.textShadowColor || 'transparent');\n  setCtx(ctx, 'shadowOffsetX', style.textShadowOffsetX || 0);\n  setCtx(ctx, 'shadowOffsetY', style.textShadowOffsetY || 0); // `textBaseline` is set as 'middle'.\n\n  textY += lineHeight / 2;\n  var textStrokeWidth = style.textStrokeWidth;\n  var textStroke = getStroke(style.textStroke, textStrokeWidth);\n  var textFill = getFill(style.textFill);\n\n  if (textStroke) {\n    setCtx(ctx, 'lineWidth', textStrokeWidth);\n    setCtx(ctx, 'strokeStyle', textStroke);\n  }\n\n  if (textFill) {\n    setCtx(ctx, 'fillStyle', textFill);\n  }\n\n  for (var i = 0; i < textLines.length; i++) {\n    // Fill after stroke so the outline will not cover the main part.\n    textStroke && ctx.strokeText(textLines[i], textX, textY);\n    textFill && ctx.fillText(textLines[i], textX, textY);\n    textY += lineHeight;\n  }\n}\n\nfunction renderRichText(hostEl, ctx, text, style, rect) {\n  var contentBlock = hostEl.__textCotentBlock;\n\n  if (!contentBlock || hostEl.__dirty) {\n    contentBlock = hostEl.__textCotentBlock = textContain.parseRichText(text, style);\n  }\n\n  drawRichText(hostEl, ctx, contentBlock, style, rect);\n}\n\nfunction drawRichText(hostEl, ctx, contentBlock, style, rect) {\n  var contentWidth = contentBlock.width;\n  var outerWidth = contentBlock.outerWidth;\n  var outerHeight = contentBlock.outerHeight;\n  var textPadding = style.textPadding;\n  var boxPos = getBoxPosition(outerHeight, style, rect);\n  var baseX = boxPos.baseX;\n  var baseY = boxPos.baseY;\n  var textAlign = boxPos.textAlign;\n  var textVerticalAlign = boxPos.textVerticalAlign; // Origin of textRotation should be the base point of text drawing.\n\n  applyTextRotation(ctx, style, rect, baseX, baseY);\n  var boxX = textContain.adjustTextX(baseX, outerWidth, textAlign);\n  var boxY = textContain.adjustTextY(baseY, outerHeight, textVerticalAlign);\n  var xLeft = boxX;\n  var lineTop = boxY;\n\n  if (textPadding) {\n    xLeft += textPadding[3];\n    lineTop += textPadding[0];\n  }\n\n  var xRight = xLeft + contentWidth;\n  needDrawBackground(style) && drawBackground(hostEl, ctx, style, boxX, boxY, outerWidth, outerHeight);\n\n  for (var i = 0; i < contentBlock.lines.length; i++) {\n    var line = contentBlock.lines[i];\n    var tokens = line.tokens;\n    var tokenCount = tokens.length;\n    var lineHeight = line.lineHeight;\n    var usedWidth = line.width;\n    var leftIndex = 0;\n    var lineXLeft = xLeft;\n    var lineXRight = xRight;\n    var rightIndex = tokenCount - 1;\n    var token;\n\n    while (leftIndex < tokenCount && (token = tokens[leftIndex], !token.textAlign || token.textAlign === 'left')) {\n      placeToken(hostEl, ctx, token, style, lineHeight, lineTop, lineXLeft, 'left');\n      usedWidth -= token.width;\n      lineXLeft += token.width;\n      leftIndex++;\n    }\n\n    while (rightIndex >= 0 && (token = tokens[rightIndex], token.textAlign === 'right')) {\n      placeToken(hostEl, ctx, token, style, lineHeight, lineTop, lineXRight, 'right');\n      usedWidth -= token.width;\n      lineXRight -= token.width;\n      rightIndex--;\n    } // The other tokens are placed as textAlign 'center' if there is enough space.\n\n\n    lineXLeft += (contentWidth - (lineXLeft - xLeft) - (xRight - lineXRight) - usedWidth) / 2;\n\n    while (leftIndex <= rightIndex) {\n      token = tokens[leftIndex]; // Consider width specified by user, use 'center' rather than 'left'.\n\n      placeToken(hostEl, ctx, token, style, lineHeight, lineTop, lineXLeft + token.width / 2, 'center');\n      lineXLeft += token.width;\n      leftIndex++;\n    }\n\n    lineTop += lineHeight;\n  }\n}\n\nfunction applyTextRotation(ctx, style, rect, x, y) {\n  // textRotation only apply in RectText.\n  if (rect && style.textRotation) {\n    var origin = style.textOrigin;\n\n    if (origin === 'center') {\n      x = rect.width / 2 + rect.x;\n      y = rect.height / 2 + rect.y;\n    } else if (origin) {\n      x = origin[0] + rect.x;\n      y = origin[1] + rect.y;\n    }\n\n    ctx.translate(x, y); // Positive: anticlockwise\n\n    ctx.rotate(-style.textRotation);\n    ctx.translate(-x, -y);\n  }\n}\n\nfunction placeToken(hostEl, ctx, token, style, lineHeight, lineTop, x, textAlign) {\n  var tokenStyle = style.rich[token.styleName] || {}; // 'ctx.textBaseline' is always set as 'middle', for sake of\n  // the bias of \"Microsoft YaHei\".\n\n  var textVerticalAlign = token.textVerticalAlign;\n  var y = lineTop + lineHeight / 2;\n\n  if (textVerticalAlign === 'top') {\n    y = lineTop + token.height / 2;\n  } else if (textVerticalAlign === 'bottom') {\n    y = lineTop + lineHeight - token.height / 2;\n  }\n\n  !token.isLineHolder && needDrawBackground(tokenStyle) && drawBackground(hostEl, ctx, tokenStyle, textAlign === 'right' ? x - token.width : textAlign === 'center' ? x - token.width / 2 : x, y - token.height / 2, token.width, token.height);\n  var textPadding = token.textPadding;\n\n  if (textPadding) {\n    x = getTextXForPadding(x, textAlign, textPadding);\n    y -= token.height / 2 - textPadding[2] - token.textHeight / 2;\n  }\n\n  setCtx(ctx, 'shadowBlur', retrieve3(tokenStyle.textShadowBlur, style.textShadowBlur, 0));\n  setCtx(ctx, 'shadowColor', tokenStyle.textShadowColor || style.textShadowColor || 'transparent');\n  setCtx(ctx, 'shadowOffsetX', retrieve3(tokenStyle.textShadowOffsetX, style.textShadowOffsetX, 0));\n  setCtx(ctx, 'shadowOffsetY', retrieve3(tokenStyle.textShadowOffsetY, style.textShadowOffsetY, 0));\n  setCtx(ctx, 'textAlign', textAlign); // Force baseline to be \"middle\". Otherwise, if using \"top\", the\n  // text will offset downward a little bit in font \"Microsoft YaHei\".\n\n  setCtx(ctx, 'textBaseline', 'middle');\n  setCtx(ctx, 'font', token.font || textContain.DEFAULT_FONT);\n  var textStroke = getStroke(tokenStyle.textStroke || style.textStroke, textStrokeWidth);\n  var textFill = getFill(tokenStyle.textFill || style.textFill);\n  var textStrokeWidth = retrieve2(tokenStyle.textStrokeWidth, style.textStrokeWidth); // Fill after stroke so the outline will not cover the main part.\n\n  if (textStroke) {\n    setCtx(ctx, 'lineWidth', textStrokeWidth);\n    setCtx(ctx, 'strokeStyle', textStroke);\n    ctx.strokeText(token.text, x, y);\n  }\n\n  if (textFill) {\n    setCtx(ctx, 'fillStyle', textFill);\n    ctx.fillText(token.text, x, y);\n  }\n}\n\nfunction needDrawBackground(style) {\n  return style.textBackgroundColor || style.textBorderWidth && style.textBorderColor;\n} // style: {textBackgroundColor, textBorderWidth, textBorderColor, textBorderRadius}\n// shape: {x, y, width, height}\n\n\nfunction drawBackground(hostEl, ctx, style, x, y, width, height) {\n  var textBackgroundColor = style.textBackgroundColor;\n  var textBorderWidth = style.textBorderWidth;\n  var textBorderColor = style.textBorderColor;\n  var isPlainBg = isString(textBackgroundColor);\n  setCtx(ctx, 'shadowBlur', style.textBoxShadowBlur || 0);\n  setCtx(ctx, 'shadowColor', style.textBoxShadowColor || 'transparent');\n  setCtx(ctx, 'shadowOffsetX', style.textBoxShadowOffsetX || 0);\n  setCtx(ctx, 'shadowOffsetY', style.textBoxShadowOffsetY || 0);\n\n  if (isPlainBg || textBorderWidth && textBorderColor) {\n    ctx.beginPath();\n    var textBorderRadius = style.textBorderRadius;\n\n    if (!textBorderRadius) {\n      ctx.rect(x, y, width, height);\n    } else {\n      roundRectHelper.buildPath(ctx, {\n        x: x,\n        y: y,\n        width: width,\n        height: height,\n        r: textBorderRadius\n      });\n    }\n\n    ctx.closePath();\n  }\n\n  if (isPlainBg) {\n    setCtx(ctx, 'fillStyle', textBackgroundColor);\n    ctx.fill();\n  } else if (isObject(textBackgroundColor)) {\n    var image = textBackgroundColor.image;\n    image = imageHelper.createOrUpdateImage(image, null, hostEl, onBgImageLoaded, textBackgroundColor);\n\n    if (image && imageHelper.isImageReady(image)) {\n      ctx.drawImage(image, x, y, width, height);\n    }\n  }\n\n  if (textBorderWidth && textBorderColor) {\n    setCtx(ctx, 'lineWidth', textBorderWidth);\n    setCtx(ctx, 'strokeStyle', textBorderColor);\n    ctx.stroke();\n  }\n}\n\nfunction onBgImageLoaded(image, textBackgroundColor) {\n  // Replace image, so that `contain/text.js#parseRichText`\n  // will get correct result in next tick.\n  textBackgroundColor.image = image;\n}\n\nfunction getBoxPosition(blockHeiht, style, rect) {\n  var baseX = style.x || 0;\n  var baseY = style.y || 0;\n  var textAlign = style.textAlign;\n  var textVerticalAlign = style.textVerticalAlign; // Text position represented by coord\n\n  if (rect) {\n    var textPosition = style.textPosition;\n\n    if (textPosition instanceof Array) {\n      // Percent\n      baseX = rect.x + parsePercent(textPosition[0], rect.width);\n      baseY = rect.y + parsePercent(textPosition[1], rect.height);\n    } else {\n      var res = textContain.adjustTextPositionOnRect(textPosition, rect, style.textDistance);\n      baseX = res.x;\n      baseY = res.y; // Default align and baseline when has textPosition\n\n      textAlign = textAlign || res.textAlign;\n      textVerticalAlign = textVerticalAlign || res.textVerticalAlign;\n    } // textOffset is only support in RectText, otherwise\n    // we have to adjust boundingRect for textOffset.\n\n\n    var textOffset = style.textOffset;\n\n    if (textOffset) {\n      baseX += textOffset[0];\n      baseY += textOffset[1];\n    }\n  }\n\n  return {\n    baseX: baseX,\n    baseY: baseY,\n    textAlign: textAlign,\n    textVerticalAlign: textVerticalAlign\n  };\n}\n\nfunction setCtx(ctx, prop, value) {\n  // FIXME ??? performance try\n  // if (ctx.__currentValues[prop] !== value) {\n  // ctx[prop] = ctx.__currentValues[prop] = value;\n  ctx[prop] = value; // }\n\n  return ctx[prop];\n}\n/**\n * @param {string} [stroke] If specified, do not check style.textStroke.\n * @param {string} [lineWidth] If specified, do not check style.textStroke.\n * @param {number} style\n */\n\n\nfunction getStroke(stroke, lineWidth) {\n  return stroke == null || lineWidth <= 0 || stroke === 'transparent' || stroke === 'none' ? null // TODO pattern and gradient?\n  : stroke.image || stroke.colorStops ? '#000' : stroke;\n}\n\nfunction getFill(fill) {\n  return fill == null || fill === 'none' ? null // TODO pattern and gradient?\n  : fill.image || fill.colorStops ? '#000' : fill;\n}\n\nfunction parsePercent(value, maxValue) {\n  if (typeof value === 'string') {\n    if (value.lastIndexOf('%') >= 0) {\n      return parseFloat(value) / 100 * maxValue;\n    }\n\n    return parseFloat(value);\n  }\n\n  return value;\n}\n\nfunction getTextXForPadding(x, textAlign, textPadding) {\n  return textAlign === 'right' ? x - textPadding[1] : textAlign === 'center' ? x + textPadding[3] / 2 - textPadding[1] / 2 : x + textPadding[3];\n}\n/**\n * @param {string} text\n * @param {module:zrender/Style} style\n * @return {boolean}\n */\n\n\nfunction needDrawText(text, style) {\n  return text != null && (text || style.textBackgroundColor || style.textBorderWidth && style.textBorderColor || style.textPadding);\n}\n\nexports.normalizeTextStyle = normalizeTextStyle;\nexports.renderText = renderText;\nexports.getStroke = getStroke;\nexports.getFill = getFill;\nexports.needDrawText = needDrawText;","map":{"version":3,"sources":["/home/martin/Escritorio/Taller de Integracion/Tarea3-TallerDeIntegracion/node_modules/react-echarts/node_modules/zrender/lib/graphic/helper/text.js"],"names":["_util","require","retrieve2","retrieve3","each","normalizeCssArray","isString","isObject","textContain","roundRectHelper","imageHelper","VALID_TEXT_ALIGN","left","right","center","VALID_TEXT_VERTICAL_ALIGN","top","bottom","middle","normalizeTextStyle","style","normalizeStyle","rich","font","makeFont","textAlign","textVerticalAlign","textBaseline","textPadding","renderText","hostEl","ctx","text","rect","renderRichText","renderPlainText","setCtx","DEFAULT_FONT","contentBlock","__textCotentBlock","__dirty","parsePlainText","truncate","outerHeight","textLines","lines","lineHeight","boxPos","getBoxPosition","baseX","baseY","applyTextRotation","boxY","adjustTextY","textX","textY","needDrawBg","needDrawBackground","textWidth","getWidth","outerWidth","boxX","adjustTextX","drawBackground","getTextXForPadding","textShadowBlur","textShadowColor","textShadowOffsetX","textShadowOffsetY","textStrokeWidth","textStroke","getStroke","textFill","getFill","i","length","strokeText","fillText","parseRichText","drawRichText","contentWidth","width","xLeft","lineTop","xRight","line","tokens","tokenCount","usedWidth","leftIndex","lineXLeft","lineXRight","rightIndex","token","placeToken","x","y","textRotation","origin","textOrigin","height","translate","rotate","tokenStyle","styleName","isLineHolder","textHeight","textBackgroundColor","textBorderWidth","textBorderColor","isPlainBg","textBoxShadowBlur","textBoxShadowColor","textBoxShadowOffsetX","textBoxShadowOffsetY","beginPath","textBorderRadius","buildPath","r","closePath","fill","image","createOrUpdateImage","onBgImageLoaded","isImageReady","drawImage","stroke","blockHeiht","textPosition","Array","parsePercent","res","adjustTextPositionOnRect","textDistance","textOffset","prop","value","lineWidth","colorStops","maxValue","lastIndexOf","parseFloat","needDrawText","exports"],"mappings":"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","sourcesContent":["var _util = require(\"../../core/util\");\n\nvar retrieve2 = _util.retrieve2;\nvar retrieve3 = _util.retrieve3;\nvar each = _util.each;\nvar normalizeCssArray = _util.normalizeCssArray;\nvar isString = _util.isString;\nvar isObject = _util.isObject;\n\nvar textContain = require(\"../../contain/text\");\n\nvar roundRectHelper = require(\"./roundRect\");\n\nvar imageHelper = require(\"./image\");\n\n// TODO: Have not support 'start', 'end' yet.\nvar VALID_TEXT_ALIGN = {\n  left: 1,\n  right: 1,\n  center: 1\n};\nvar VALID_TEXT_VERTICAL_ALIGN = {\n  top: 1,\n  bottom: 1,\n  middle: 1\n};\n/**\n * @param {module:zrender/graphic/Style} style\n * @return {module:zrender/graphic/Style} The input style.\n */\n\nfunction normalizeTextStyle(style) {\n  normalizeStyle(style);\n  each(style.rich, normalizeStyle);\n  return style;\n}\n\nfunction normalizeStyle(style) {\n  if (style) {\n    style.font = textContain.makeFont(style);\n    var textAlign = style.textAlign;\n    textAlign === 'middle' && (textAlign = 'center');\n    style.textAlign = textAlign == null || VALID_TEXT_ALIGN[textAlign] ? textAlign : 'left'; // Compatible with textBaseline.\n\n    var textVerticalAlign = style.textVerticalAlign || style.textBaseline;\n    textVerticalAlign === 'center' && (textVerticalAlign = 'middle');\n    style.textVerticalAlign = textVerticalAlign == null || VALID_TEXT_VERTICAL_ALIGN[textVerticalAlign] ? textVerticalAlign : 'top';\n    var textPadding = style.textPadding;\n\n    if (textPadding) {\n      style.textPadding = normalizeCssArray(style.textPadding);\n    }\n  }\n}\n/**\n * @param {CanvasRenderingContext2D} ctx\n * @param {string} text\n * @param {module:zrender/graphic/Style} style\n * @param {Object|boolean} [rect] {x, y, width, height}\n *                  If set false, rect text is not used.\n */\n\n\nfunction renderText(hostEl, ctx, text, style, rect) {\n  style.rich ? renderRichText(hostEl, ctx, text, style, rect) : renderPlainText(hostEl, ctx, text, style, rect);\n}\n\nfunction renderPlainText(hostEl, ctx, text, style, rect) {\n  var font = setCtx(ctx, 'font', style.font || textContain.DEFAULT_FONT);\n  var textPadding = style.textPadding;\n  var contentBlock = hostEl.__textCotentBlock;\n\n  if (!contentBlock || hostEl.__dirty) {\n    contentBlock = hostEl.__textCotentBlock = textContain.parsePlainText(text, font, textPadding, style.truncate);\n  }\n\n  var outerHeight = contentBlock.outerHeight;\n  var textLines = contentBlock.lines;\n  var lineHeight = contentBlock.lineHeight;\n  var boxPos = getBoxPosition(outerHeight, style, rect);\n  var baseX = boxPos.baseX;\n  var baseY = boxPos.baseY;\n  var textAlign = boxPos.textAlign;\n  var textVerticalAlign = boxPos.textVerticalAlign; // Origin of textRotation should be the base point of text drawing.\n\n  applyTextRotation(ctx, style, rect, baseX, baseY);\n  var boxY = textContain.adjustTextY(baseY, outerHeight, textVerticalAlign);\n  var textX = baseX;\n  var textY = boxY;\n  var needDrawBg = needDrawBackground(style);\n\n  if (needDrawBg || textPadding) {\n    // Consider performance, do not call getTextWidth util necessary.\n    var textWidth = textContain.getWidth(text, font);\n    var outerWidth = textWidth;\n    textPadding && (outerWidth += textPadding[1] + textPadding[3]);\n    var boxX = textContain.adjustTextX(baseX, outerWidth, textAlign);\n    needDrawBg && drawBackground(hostEl, ctx, style, boxX, boxY, outerWidth, outerHeight);\n\n    if (textPadding) {\n      textX = getTextXForPadding(baseX, textAlign, textPadding);\n      textY += textPadding[0];\n    }\n  }\n\n  setCtx(ctx, 'textAlign', textAlign || 'left'); // Force baseline to be \"middle\". Otherwise, if using \"top\", the\n  // text will offset downward a little bit in font \"Microsoft YaHei\".\n\n  setCtx(ctx, 'textBaseline', 'middle'); // Always set shadowBlur and shadowOffset to avoid leak from displayable.\n\n  setCtx(ctx, 'shadowBlur', style.textShadowBlur || 0);\n  setCtx(ctx, 'shadowColor', style.textShadowColor || 'transparent');\n  setCtx(ctx, 'shadowOffsetX', style.textShadowOffsetX || 0);\n  setCtx(ctx, 'shadowOffsetY', style.textShadowOffsetY || 0); // `textBaseline` is set as 'middle'.\n\n  textY += lineHeight / 2;\n  var textStrokeWidth = style.textStrokeWidth;\n  var textStroke = getStroke(style.textStroke, textStrokeWidth);\n  var textFill = getFill(style.textFill);\n\n  if (textStroke) {\n    setCtx(ctx, 'lineWidth', textStrokeWidth);\n    setCtx(ctx, 'strokeStyle', textStroke);\n  }\n\n  if (textFill) {\n    setCtx(ctx, 'fillStyle', textFill);\n  }\n\n  for (var i = 0; i < textLines.length; i++) {\n    // Fill after stroke so the outline will not cover the main part.\n    textStroke && ctx.strokeText(textLines[i], textX, textY);\n    textFill && ctx.fillText(textLines[i], textX, textY);\n    textY += lineHeight;\n  }\n}\n\nfunction renderRichText(hostEl, ctx, text, style, rect) {\n  var contentBlock = hostEl.__textCotentBlock;\n\n  if (!contentBlock || hostEl.__dirty) {\n    contentBlock = hostEl.__textCotentBlock = textContain.parseRichText(text, style);\n  }\n\n  drawRichText(hostEl, ctx, contentBlock, style, rect);\n}\n\nfunction drawRichText(hostEl, ctx, contentBlock, style, rect) {\n  var contentWidth = contentBlock.width;\n  var outerWidth = contentBlock.outerWidth;\n  var outerHeight = contentBlock.outerHeight;\n  var textPadding = style.textPadding;\n  var boxPos = getBoxPosition(outerHeight, style, rect);\n  var baseX = boxPos.baseX;\n  var baseY = boxPos.baseY;\n  var textAlign = boxPos.textAlign;\n  var textVerticalAlign = boxPos.textVerticalAlign; // Origin of textRotation should be the base point of text drawing.\n\n  applyTextRotation(ctx, style, rect, baseX, baseY);\n  var boxX = textContain.adjustTextX(baseX, outerWidth, textAlign);\n  var boxY = textContain.adjustTextY(baseY, outerHeight, textVerticalAlign);\n  var xLeft = boxX;\n  var lineTop = boxY;\n\n  if (textPadding) {\n    xLeft += textPadding[3];\n    lineTop += textPadding[0];\n  }\n\n  var xRight = xLeft + contentWidth;\n  needDrawBackground(style) && drawBackground(hostEl, ctx, style, boxX, boxY, outerWidth, outerHeight);\n\n  for (var i = 0; i < contentBlock.lines.length; i++) {\n    var line = contentBlock.lines[i];\n    var tokens = line.tokens;\n    var tokenCount = tokens.length;\n    var lineHeight = line.lineHeight;\n    var usedWidth = line.width;\n    var leftIndex = 0;\n    var lineXLeft = xLeft;\n    var lineXRight = xRight;\n    var rightIndex = tokenCount - 1;\n    var token;\n\n    while (leftIndex < tokenCount && (token = tokens[leftIndex], !token.textAlign || token.textAlign === 'left')) {\n      placeToken(hostEl, ctx, token, style, lineHeight, lineTop, lineXLeft, 'left');\n      usedWidth -= token.width;\n      lineXLeft += token.width;\n      leftIndex++;\n    }\n\n    while (rightIndex >= 0 && (token = tokens[rightIndex], token.textAlign === 'right')) {\n      placeToken(hostEl, ctx, token, style, lineHeight, lineTop, lineXRight, 'right');\n      usedWidth -= token.width;\n      lineXRight -= token.width;\n      rightIndex--;\n    } // The other tokens are placed as textAlign 'center' if there is enough space.\n\n\n    lineXLeft += (contentWidth - (lineXLeft - xLeft) - (xRight - lineXRight) - usedWidth) / 2;\n\n    while (leftIndex <= rightIndex) {\n      token = tokens[leftIndex]; // Consider width specified by user, use 'center' rather than 'left'.\n\n      placeToken(hostEl, ctx, token, style, lineHeight, lineTop, lineXLeft + token.width / 2, 'center');\n      lineXLeft += token.width;\n      leftIndex++;\n    }\n\n    lineTop += lineHeight;\n  }\n}\n\nfunction applyTextRotation(ctx, style, rect, x, y) {\n  // textRotation only apply in RectText.\n  if (rect && style.textRotation) {\n    var origin = style.textOrigin;\n\n    if (origin === 'center') {\n      x = rect.width / 2 + rect.x;\n      y = rect.height / 2 + rect.y;\n    } else if (origin) {\n      x = origin[0] + rect.x;\n      y = origin[1] + rect.y;\n    }\n\n    ctx.translate(x, y); // Positive: anticlockwise\n\n    ctx.rotate(-style.textRotation);\n    ctx.translate(-x, -y);\n  }\n}\n\nfunction placeToken(hostEl, ctx, token, style, lineHeight, lineTop, x, textAlign) {\n  var tokenStyle = style.rich[token.styleName] || {}; // 'ctx.textBaseline' is always set as 'middle', for sake of\n  // the bias of \"Microsoft YaHei\".\n\n  var textVerticalAlign = token.textVerticalAlign;\n  var y = lineTop + lineHeight / 2;\n\n  if (textVerticalAlign === 'top') {\n    y = lineTop + token.height / 2;\n  } else if (textVerticalAlign === 'bottom') {\n    y = lineTop + lineHeight - token.height / 2;\n  }\n\n  !token.isLineHolder && needDrawBackground(tokenStyle) && drawBackground(hostEl, ctx, tokenStyle, textAlign === 'right' ? x - token.width : textAlign === 'center' ? x - token.width / 2 : x, y - token.height / 2, token.width, token.height);\n  var textPadding = token.textPadding;\n\n  if (textPadding) {\n    x = getTextXForPadding(x, textAlign, textPadding);\n    y -= token.height / 2 - textPadding[2] - token.textHeight / 2;\n  }\n\n  setCtx(ctx, 'shadowBlur', retrieve3(tokenStyle.textShadowBlur, style.textShadowBlur, 0));\n  setCtx(ctx, 'shadowColor', tokenStyle.textShadowColor || style.textShadowColor || 'transparent');\n  setCtx(ctx, 'shadowOffsetX', retrieve3(tokenStyle.textShadowOffsetX, style.textShadowOffsetX, 0));\n  setCtx(ctx, 'shadowOffsetY', retrieve3(tokenStyle.textShadowOffsetY, style.textShadowOffsetY, 0));\n  setCtx(ctx, 'textAlign', textAlign); // Force baseline to be \"middle\". Otherwise, if using \"top\", the\n  // text will offset downward a little bit in font \"Microsoft YaHei\".\n\n  setCtx(ctx, 'textBaseline', 'middle');\n  setCtx(ctx, 'font', token.font || textContain.DEFAULT_FONT);\n  var textStroke = getStroke(tokenStyle.textStroke || style.textStroke, textStrokeWidth);\n  var textFill = getFill(tokenStyle.textFill || style.textFill);\n  var textStrokeWidth = retrieve2(tokenStyle.textStrokeWidth, style.textStrokeWidth); // Fill after stroke so the outline will not cover the main part.\n\n  if (textStroke) {\n    setCtx(ctx, 'lineWidth', textStrokeWidth);\n    setCtx(ctx, 'strokeStyle', textStroke);\n    ctx.strokeText(token.text, x, y);\n  }\n\n  if (textFill) {\n    setCtx(ctx, 'fillStyle', textFill);\n    ctx.fillText(token.text, x, y);\n  }\n}\n\nfunction needDrawBackground(style) {\n  return style.textBackgroundColor || style.textBorderWidth && style.textBorderColor;\n} // style: {textBackgroundColor, textBorderWidth, textBorderColor, textBorderRadius}\n// shape: {x, y, width, height}\n\n\nfunction drawBackground(hostEl, ctx, style, x, y, width, height) {\n  var textBackgroundColor = style.textBackgroundColor;\n  var textBorderWidth = style.textBorderWidth;\n  var textBorderColor = style.textBorderColor;\n  var isPlainBg = isString(textBackgroundColor);\n  setCtx(ctx, 'shadowBlur', style.textBoxShadowBlur || 0);\n  setCtx(ctx, 'shadowColor', style.textBoxShadowColor || 'transparent');\n  setCtx(ctx, 'shadowOffsetX', style.textBoxShadowOffsetX || 0);\n  setCtx(ctx, 'shadowOffsetY', style.textBoxShadowOffsetY || 0);\n\n  if (isPlainBg || textBorderWidth && textBorderColor) {\n    ctx.beginPath();\n    var textBorderRadius = style.textBorderRadius;\n\n    if (!textBorderRadius) {\n      ctx.rect(x, y, width, height);\n    } else {\n      roundRectHelper.buildPath(ctx, {\n        x: x,\n        y: y,\n        width: width,\n        height: height,\n        r: textBorderRadius\n      });\n    }\n\n    ctx.closePath();\n  }\n\n  if (isPlainBg) {\n    setCtx(ctx, 'fillStyle', textBackgroundColor);\n    ctx.fill();\n  } else if (isObject(textBackgroundColor)) {\n    var image = textBackgroundColor.image;\n    image = imageHelper.createOrUpdateImage(image, null, hostEl, onBgImageLoaded, textBackgroundColor);\n\n    if (image && imageHelper.isImageReady(image)) {\n      ctx.drawImage(image, x, y, width, height);\n    }\n  }\n\n  if (textBorderWidth && textBorderColor) {\n    setCtx(ctx, 'lineWidth', textBorderWidth);\n    setCtx(ctx, 'strokeStyle', textBorderColor);\n    ctx.stroke();\n  }\n}\n\nfunction onBgImageLoaded(image, textBackgroundColor) {\n  // Replace image, so that `contain/text.js#parseRichText`\n  // will get correct result in next tick.\n  textBackgroundColor.image = image;\n}\n\nfunction getBoxPosition(blockHeiht, style, rect) {\n  var baseX = style.x || 0;\n  var baseY = style.y || 0;\n  var textAlign = style.textAlign;\n  var textVerticalAlign = style.textVerticalAlign; // Text position represented by coord\n\n  if (rect) {\n    var textPosition = style.textPosition;\n\n    if (textPosition instanceof Array) {\n      // Percent\n      baseX = rect.x + parsePercent(textPosition[0], rect.width);\n      baseY = rect.y + parsePercent(textPosition[1], rect.height);\n    } else {\n      var res = textContain.adjustTextPositionOnRect(textPosition, rect, style.textDistance);\n      baseX = res.x;\n      baseY = res.y; // Default align and baseline when has textPosition\n\n      textAlign = textAlign || res.textAlign;\n      textVerticalAlign = textVerticalAlign || res.textVerticalAlign;\n    } // textOffset is only support in RectText, otherwise\n    // we have to adjust boundingRect for textOffset.\n\n\n    var textOffset = style.textOffset;\n\n    if (textOffset) {\n      baseX += textOffset[0];\n      baseY += textOffset[1];\n    }\n  }\n\n  return {\n    baseX: baseX,\n    baseY: baseY,\n    textAlign: textAlign,\n    textVerticalAlign: textVerticalAlign\n  };\n}\n\nfunction setCtx(ctx, prop, value) {\n  // FIXME ??? performance try\n  // if (ctx.__currentValues[prop] !== value) {\n  // ctx[prop] = ctx.__currentValues[prop] = value;\n  ctx[prop] = value; // }\n\n  return ctx[prop];\n}\n/**\n * @param {string} [stroke] If specified, do not check style.textStroke.\n * @param {string} [lineWidth] If specified, do not check style.textStroke.\n * @param {number} style\n */\n\n\nfunction getStroke(stroke, lineWidth) {\n  return stroke == null || lineWidth <= 0 || stroke === 'transparent' || stroke === 'none' ? null // TODO pattern and gradient?\n  : stroke.image || stroke.colorStops ? '#000' : stroke;\n}\n\nfunction getFill(fill) {\n  return fill == null || fill === 'none' ? null // TODO pattern and gradient?\n  : fill.image || fill.colorStops ? '#000' : fill;\n}\n\nfunction parsePercent(value, maxValue) {\n  if (typeof value === 'string') {\n    if (value.lastIndexOf('%') >= 0) {\n      return parseFloat(value) / 100 * maxValue;\n    }\n\n    return parseFloat(value);\n  }\n\n  return value;\n}\n\nfunction getTextXForPadding(x, textAlign, textPadding) {\n  return textAlign === 'right' ? x - textPadding[1] : textAlign === 'center' ? x + textPadding[3] / 2 - textPadding[1] / 2 : x + textPadding[3];\n}\n/**\n * @param {string} text\n * @param {module:zrender/Style} style\n * @return {boolean}\n */\n\n\nfunction needDrawText(text, style) {\n  return text != null && (text || style.textBackgroundColor || style.textBorderWidth && style.textBorderColor || style.textPadding);\n}\n\nexports.normalizeTextStyle = normalizeTextStyle;\nexports.renderText = renderText;\nexports.getStroke = getStroke;\nexports.getFill = getFill;\nexports.needDrawText = needDrawText;"]},"metadata":{},"sourceType":"script"}