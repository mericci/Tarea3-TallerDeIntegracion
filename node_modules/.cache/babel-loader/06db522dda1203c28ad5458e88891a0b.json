{"ast":null,"code":"var Definable = require(\"./Definable\");\n\nvar zrUtil = require(\"../../core/util\");\n\nvar matrix = require(\"../../core/matrix\");\n/**\n * @file Manages SVG clipPath elements.\n * @author Zhang Wenli\n */\n\n/**\n * Manages SVG clipPath elements.\n *\n * @class\n * @extends Definable\n * @param   {SVGElement} svgRoot root of SVG document\n */\n\n\nfunction ClippathManager(svgRoot) {\n  Definable.call(this, svgRoot, 'clipPath', '__clippath_in_use__');\n}\n\nzrUtil.inherits(ClippathManager, Definable);\n/**\n * Update clipPath.\n *\n * @param {Displayable} displayable displayable element\n */\n\nClippathManager.prototype.update = function (displayable) {\n  var svgEl = this.getSvgElement(displayable);\n\n  if (svgEl) {\n    this.updateDom(svgEl, displayable.__clipPaths, false);\n  }\n\n  var textEl = this.getTextSvgElement(displayable);\n\n  if (textEl) {\n    // Make another clipPath for text, since it's transform\n    // matrix is not the same with svgElement\n    this.updateDom(textEl, displayable.__clipPaths, true);\n  }\n\n  this.markUsed(displayable);\n};\n/**\n * Create an SVGElement of displayable and create a <clipPath> of its\n * clipPath\n *\n * @param {Displayable} parentEl  parent element\n * @param {ClipPath[]}  clipPaths clipPaths of parent element\n * @param {boolean}     isText    if parent element is Text\n */\n\n\nClippathManager.prototype.updateDom = function (parentEl, clipPaths, isText) {\n  if (clipPaths && clipPaths.length > 0) {\n    // Has clipPath, create <clipPath> with the first clipPath\n    var defs = this.getDefs(true);\n    var clipPath = clipPaths[0];\n    var clipPathEl;\n    var id;\n    var dom = isText ? '_textDom' : '_dom';\n\n    if (clipPath[dom]) {\n      // Use a dom that is already in <defs>\n      id = clipPath[dom].getAttribute('id');\n      clipPathEl = clipPath[dom]; // Use a dom that is already in <defs>\n\n      if (!defs.contains(clipPathEl)) {\n        // This happens when set old clipPath that has\n        // been previously removed\n        defs.appendChild(clipPathEl);\n      }\n    } else {\n      // New <clipPath>\n      id = 'zr-clip-' + this.nextId;\n      ++this.nextId;\n      clipPathEl = this.createElement('clipPath');\n      clipPathEl.setAttribute('id', id);\n      defs.appendChild(clipPathEl);\n      clipPath[dom] = clipPathEl;\n    } // Build path and add to <clipPath>\n\n\n    var svgProxy = this.getSvgProxy(clipPath);\n\n    if (clipPath.transform && clipPath.parent.invTransform && !isText) {\n      /**\n       * If a clipPath has a parent with transform, the transform\n       * of parent should not be considered when setting transform\n       * of clipPath. So we need to transform back from parent's\n       * transform, which is done by multiplying parent's inverse\n       * transform.\n       */\n      // Store old transform\n      var transform = Array.prototype.slice.call(clipPath.transform); // Transform back from parent, and brush path\n\n      matrix.mul(clipPath.transform, clipPath.parent.invTransform, clipPath.transform);\n      svgProxy.brush(clipPath); // Set back transform of clipPath\n\n      clipPath.transform = transform;\n    } else {\n      svgProxy.brush(clipPath);\n    }\n\n    var pathEl = this.getSvgElement(clipPath);\n    /**\n     * Use `cloneNode()` here to appendChild to multiple parents,\n     * which may happend when Text and other shapes are using the same\n     * clipPath. Since Text will create an extra clipPath DOM due to\n     * different transform rules.\n     */\n\n    clipPathEl.appendChild(pathEl.cloneNode());\n    parentEl.setAttribute('clip-path', 'url(#' + id + ')');\n\n    if (clipPaths.length > 1) {\n      // Make the other clipPaths recursively\n      this.updateDom(clipPathEl, clipPaths.slice(1), isText);\n    }\n  } else {\n    // No clipPath\n    if (parentEl) {\n      parentEl.setAttribute('clip-path', 'none');\n    }\n  }\n};\n/**\n * Mark a single clipPath to be used\n *\n * @param {Displayable} displayable displayable element\n */\n\n\nClippathManager.prototype.markUsed = function (displayable) {\n  var that = this;\n\n  if (displayable.__clipPaths && displayable.__clipPaths.length > 0) {\n    zrUtil.each(displayable.__clipPaths, function (clipPath) {\n      if (clipPath._dom) {\n        Definable.prototype.markUsed.call(that, clipPath._dom);\n      }\n\n      if (clipPath._textDom) {\n        Definable.prototype.markUsed.call(that, clipPath._textDom);\n      }\n    });\n  }\n};\n\nvar _default = ClippathManager;\nmodule.exports = _default;","map":{"version":3,"sources":["/home/martin/Escritorio/Taller de Integracion/Tarea3-TallerDeIntegracion/node_modules/react-echarts/node_modules/zrender/lib/svg/helper/ClippathManager.js"],"names":["Definable","require","zrUtil","matrix","ClippathManager","svgRoot","call","inherits","prototype","update","displayable","svgEl","getSvgElement","updateDom","__clipPaths","textEl","getTextSvgElement","markUsed","parentEl","clipPaths","isText","length","defs","getDefs","clipPath","clipPathEl","id","dom","getAttribute","contains","appendChild","nextId","createElement","setAttribute","svgProxy","getSvgProxy","transform","parent","invTransform","Array","slice","mul","brush","pathEl","cloneNode","that","each","_dom","_textDom","_default","module","exports"],"mappings":"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","sourcesContent":["var Definable = require(\"./Definable\");\n\nvar zrUtil = require(\"../../core/util\");\n\nvar matrix = require(\"../../core/matrix\");\n\n/**\n * @file Manages SVG clipPath elements.\n * @author Zhang Wenli\n */\n\n/**\n * Manages SVG clipPath elements.\n *\n * @class\n * @extends Definable\n * @param   {SVGElement} svgRoot root of SVG document\n */\nfunction ClippathManager(svgRoot) {\n  Definable.call(this, svgRoot, 'clipPath', '__clippath_in_use__');\n}\n\nzrUtil.inherits(ClippathManager, Definable);\n/**\n * Update clipPath.\n *\n * @param {Displayable} displayable displayable element\n */\n\nClippathManager.prototype.update = function (displayable) {\n  var svgEl = this.getSvgElement(displayable);\n\n  if (svgEl) {\n    this.updateDom(svgEl, displayable.__clipPaths, false);\n  }\n\n  var textEl = this.getTextSvgElement(displayable);\n\n  if (textEl) {\n    // Make another clipPath for text, since it's transform\n    // matrix is not the same with svgElement\n    this.updateDom(textEl, displayable.__clipPaths, true);\n  }\n\n  this.markUsed(displayable);\n};\n/**\n * Create an SVGElement of displayable and create a <clipPath> of its\n * clipPath\n *\n * @param {Displayable} parentEl  parent element\n * @param {ClipPath[]}  clipPaths clipPaths of parent element\n * @param {boolean}     isText    if parent element is Text\n */\n\n\nClippathManager.prototype.updateDom = function (parentEl, clipPaths, isText) {\n  if (clipPaths && clipPaths.length > 0) {\n    // Has clipPath, create <clipPath> with the first clipPath\n    var defs = this.getDefs(true);\n    var clipPath = clipPaths[0];\n    var clipPathEl;\n    var id;\n    var dom = isText ? '_textDom' : '_dom';\n\n    if (clipPath[dom]) {\n      // Use a dom that is already in <defs>\n      id = clipPath[dom].getAttribute('id');\n      clipPathEl = clipPath[dom]; // Use a dom that is already in <defs>\n\n      if (!defs.contains(clipPathEl)) {\n        // This happens when set old clipPath that has\n        // been previously removed\n        defs.appendChild(clipPathEl);\n      }\n    } else {\n      // New <clipPath>\n      id = 'zr-clip-' + this.nextId;\n      ++this.nextId;\n      clipPathEl = this.createElement('clipPath');\n      clipPathEl.setAttribute('id', id);\n      defs.appendChild(clipPathEl);\n      clipPath[dom] = clipPathEl;\n    } // Build path and add to <clipPath>\n\n\n    var svgProxy = this.getSvgProxy(clipPath);\n\n    if (clipPath.transform && clipPath.parent.invTransform && !isText) {\n      /**\n       * If a clipPath has a parent with transform, the transform\n       * of parent should not be considered when setting transform\n       * of clipPath. So we need to transform back from parent's\n       * transform, which is done by multiplying parent's inverse\n       * transform.\n       */\n      // Store old transform\n      var transform = Array.prototype.slice.call(clipPath.transform); // Transform back from parent, and brush path\n\n      matrix.mul(clipPath.transform, clipPath.parent.invTransform, clipPath.transform);\n      svgProxy.brush(clipPath); // Set back transform of clipPath\n\n      clipPath.transform = transform;\n    } else {\n      svgProxy.brush(clipPath);\n    }\n\n    var pathEl = this.getSvgElement(clipPath);\n    /**\n     * Use `cloneNode()` here to appendChild to multiple parents,\n     * which may happend when Text and other shapes are using the same\n     * clipPath. Since Text will create an extra clipPath DOM due to\n     * different transform rules.\n     */\n\n    clipPathEl.appendChild(pathEl.cloneNode());\n    parentEl.setAttribute('clip-path', 'url(#' + id + ')');\n\n    if (clipPaths.length > 1) {\n      // Make the other clipPaths recursively\n      this.updateDom(clipPathEl, clipPaths.slice(1), isText);\n    }\n  } else {\n    // No clipPath\n    if (parentEl) {\n      parentEl.setAttribute('clip-path', 'none');\n    }\n  }\n};\n/**\n * Mark a single clipPath to be used\n *\n * @param {Displayable} displayable displayable element\n */\n\n\nClippathManager.prototype.markUsed = function (displayable) {\n  var that = this;\n\n  if (displayable.__clipPaths && displayable.__clipPaths.length > 0) {\n    zrUtil.each(displayable.__clipPaths, function (clipPath) {\n      if (clipPath._dom) {\n        Definable.prototype.markUsed.call(that, clipPath._dom);\n      }\n\n      if (clipPath._textDom) {\n        Definable.prototype.markUsed.call(that, clipPath._textDom);\n      }\n    });\n  }\n};\n\nvar _default = ClippathManager;\nmodule.exports = _default;"]},"metadata":{},"sourceType":"script"}