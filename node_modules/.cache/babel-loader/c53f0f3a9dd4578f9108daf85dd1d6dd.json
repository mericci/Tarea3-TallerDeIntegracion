{"ast":null,"code":"var _util = require(\"zrender/lib/core/util\");\n\nvar retrieve = _util.retrieve;\nvar defaults = _util.defaults;\nvar extend = _util.extend;\nvar each = _util.each;\n\nvar formatUtil = require(\"../../util/format\");\n\nvar graphic = require(\"../../util/graphic\");\n\nvar Model = require(\"../../model/Model\");\n\nvar _number = require(\"../../util/number\");\n\nvar isRadianAroundZero = _number.isRadianAroundZero;\nvar remRadian = _number.remRadian;\n\nvar _symbol = require(\"../../util/symbol\");\n\nvar createSymbol = _symbol.createSymbol;\n\nvar matrixUtil = require(\"zrender/lib/core/matrix\");\n\nvar _vector = require(\"zrender/lib/core/vector\");\n\nvar v2ApplyTransform = _vector.applyTransform;\nvar PI = Math.PI;\n\nfunction makeAxisEventDataBase(axisModel) {\n  var eventData = {\n    componentType: axisModel.mainType\n  };\n  eventData[axisModel.mainType + 'Index'] = axisModel.componentIndex;\n  return eventData;\n}\n/**\n * A final axis is translated and rotated from a \"standard axis\".\n * So opt.position and opt.rotation is required.\n *\n * A standard axis is and axis from [0, 0] to [0, axisExtent[1]],\n * for example: (0, 0) ------------> (0, 50)\n *\n * nameDirection or tickDirection or labelDirection is 1 means tick\n * or label is below the standard axis, whereas is -1 means above\n * the standard axis. labelOffset means offset between label and axis,\n * which is useful when 'onZero', where axisLabel is in the grid and\n * label in outside grid.\n *\n * Tips: like always,\n * positive rotation represents anticlockwise, and negative rotation\n * represents clockwise.\n * The direction of position coordinate is the same as the direction\n * of screen coordinate.\n *\n * Do not need to consider axis 'inverse', which is auto processed by\n * axis extent.\n *\n * @param {module:zrender/container/Group} group\n * @param {Object} axisModel\n * @param {Object} opt Standard axis parameters.\n * @param {Array.<number>} opt.position [x, y]\n * @param {number} opt.rotation by radian\n * @param {number} [opt.nameDirection=1] 1 or -1 Used when nameLocation is 'middle' or 'center'.\n * @param {number} [opt.tickDirection=1] 1 or -1\n * @param {number} [opt.labelDirection=1] 1 or -1\n * @param {number} [opt.labelOffset=0] Usefull when onZero.\n * @param {string} [opt.axisLabelShow] default get from axisModel.\n * @param {string} [opt.axisName] default get from axisModel.\n * @param {number} [opt.axisNameAvailableWidth]\n * @param {number} [opt.labelRotate] by degree, default get from axisModel.\n * @param {number} [opt.labelInterval] Default label interval when label\n *                                     interval from model is null or 'auto'.\n * @param {number} [opt.strokeContainThreshold] Default label interval when label\n * @param {number} [opt.nameTruncateMaxWidth]\n */\n\n\nvar AxisBuilder = function (axisModel, opt) {\n  /**\n   * @readOnly\n   */\n  this.opt = opt;\n  /**\n   * @readOnly\n   */\n\n  this.axisModel = axisModel; // Default value\n\n  defaults(opt, {\n    labelOffset: 0,\n    nameDirection: 1,\n    tickDirection: 1,\n    labelDirection: 1,\n    silent: true\n  });\n  /**\n   * @readOnly\n   */\n\n  this.group = new graphic.Group(); // FIXME Not use a seperate text group?\n\n  var dumbGroup = new graphic.Group({\n    position: opt.position.slice(),\n    rotation: opt.rotation\n  }); // this.group.add(dumbGroup);\n  // this._dumbGroup = dumbGroup;\n\n  dumbGroup.updateTransform();\n  this._transform = dumbGroup.transform;\n  this._dumbGroup = dumbGroup;\n};\n\nAxisBuilder.prototype = {\n  constructor: AxisBuilder,\n  hasBuilder: function (name) {\n    return !!builders[name];\n  },\n  add: function (name) {\n    builders[name].call(this);\n  },\n  getGroup: function () {\n    return this.group;\n  }\n};\nvar builders = {\n  /**\n   * @private\n   */\n  axisLine: function () {\n    var opt = this.opt;\n    var axisModel = this.axisModel;\n\n    if (!axisModel.get('axisLine.show')) {\n      return;\n    }\n\n    var extent = this.axisModel.axis.getExtent();\n    var matrix = this._transform;\n    var pt1 = [extent[0], 0];\n    var pt2 = [extent[1], 0];\n\n    if (matrix) {\n      v2ApplyTransform(pt1, pt1, matrix);\n      v2ApplyTransform(pt2, pt2, matrix);\n    }\n\n    var lineStyle = extend({\n      lineCap: 'round'\n    }, axisModel.getModel('axisLine.lineStyle').getLineStyle());\n    this.group.add(new graphic.Line(graphic.subPixelOptimizeLine({\n      // Id for animation\n      anid: 'line',\n      shape: {\n        x1: pt1[0],\n        y1: pt1[1],\n        x2: pt2[0],\n        y2: pt2[1]\n      },\n      style: lineStyle,\n      strokeContainThreshold: opt.strokeContainThreshold || 5,\n      silent: true,\n      z2: 1\n    })));\n    var arrows = axisModel.get('axisLine.symbol');\n    var arrowSize = axisModel.get('axisLine.symbolSize');\n\n    if (arrows != null) {\n      if (typeof arrows === 'string') {\n        // Use the same arrow for start and end point\n        arrows = [arrows, arrows];\n      }\n\n      if (typeof arrowSize === 'string' || typeof arrowSize === 'number') {\n        // Use the same size for width and height\n        arrowSize = [arrowSize, arrowSize];\n      }\n\n      var symbolWidth = arrowSize[0];\n      var symbolHeight = arrowSize[1];\n      each([[opt.rotation + Math.PI / 2, pt1], [opt.rotation - Math.PI / 2, pt2]], function (item, index) {\n        if (arrows[index] !== 'none' && arrows[index] != null) {\n          var symbol = createSymbol(arrows[index], -symbolWidth / 2, -symbolHeight / 2, symbolWidth, symbolHeight, lineStyle.stroke, true);\n          symbol.attr({\n            rotation: item[0],\n            position: item[1],\n            silent: true\n          });\n          this.group.add(symbol);\n        }\n      }, this);\n    }\n  },\n\n  /**\n   * @private\n   */\n  axisTickLabel: function () {\n    var axisModel = this.axisModel;\n    var opt = this.opt;\n    var tickEls = buildAxisTick(this, axisModel, opt);\n    var labelEls = buildAxisLabel(this, axisModel, opt);\n    fixMinMaxLabelShow(axisModel, labelEls, tickEls);\n  },\n\n  /**\n   * @private\n   */\n  axisName: function () {\n    var opt = this.opt;\n    var axisModel = this.axisModel;\n    var name = retrieve(opt.axisName, axisModel.get('name'));\n\n    if (!name) {\n      return;\n    }\n\n    var nameLocation = axisModel.get('nameLocation');\n    var nameDirection = opt.nameDirection;\n    var textStyleModel = axisModel.getModel('nameTextStyle');\n    var gap = axisModel.get('nameGap') || 0;\n    var extent = this.axisModel.axis.getExtent();\n    var gapSignal = extent[0] > extent[1] ? -1 : 1;\n    var pos = [nameLocation === 'start' ? extent[0] - gapSignal * gap : nameLocation === 'end' ? extent[1] + gapSignal * gap : (extent[0] + extent[1]) / 2, // 'middle'\n    // Reuse labelOffset.\n    isNameLocationCenter(nameLocation) ? opt.labelOffset + nameDirection * gap : 0];\n    var labelLayout;\n    var nameRotation = axisModel.get('nameRotate');\n\n    if (nameRotation != null) {\n      nameRotation = nameRotation * PI / 180; // To radian.\n    }\n\n    var axisNameAvailableWidth;\n\n    if (isNameLocationCenter(nameLocation)) {\n      labelLayout = innerTextLayout(opt.rotation, nameRotation != null ? nameRotation : opt.rotation, // Adapt to axis.\n      nameDirection);\n    } else {\n      labelLayout = endTextLayout(opt, nameLocation, nameRotation || 0, extent);\n      axisNameAvailableWidth = opt.axisNameAvailableWidth;\n\n      if (axisNameAvailableWidth != null) {\n        axisNameAvailableWidth = Math.abs(axisNameAvailableWidth / Math.sin(labelLayout.rotation));\n        !isFinite(axisNameAvailableWidth) && (axisNameAvailableWidth = null);\n      }\n    }\n\n    var textFont = textStyleModel.getFont();\n    var truncateOpt = axisModel.get('nameTruncate', true) || {};\n    var ellipsis = truncateOpt.ellipsis;\n    var maxWidth = retrieve(opt.nameTruncateMaxWidth, truncateOpt.maxWidth, axisNameAvailableWidth); // FIXME\n    // truncate rich text? (consider performance)\n\n    var truncatedText = ellipsis != null && maxWidth != null ? formatUtil.truncateText(name, maxWidth, textFont, ellipsis, {\n      minChar: 2,\n      placeholder: truncateOpt.placeholder\n    }) : name;\n    var tooltipOpt = axisModel.get('tooltip', true);\n    var mainType = axisModel.mainType;\n    var formatterParams = {\n      componentType: mainType,\n      name: name,\n      $vars: ['name']\n    };\n    formatterParams[mainType + 'Index'] = axisModel.componentIndex;\n    var textEl = new graphic.Text({\n      // Id for animation\n      anid: 'name',\n      __fullText: name,\n      __truncatedText: truncatedText,\n      position: pos,\n      rotation: labelLayout.rotation,\n      silent: isSilent(axisModel),\n      z2: 1,\n      tooltip: tooltipOpt && tooltipOpt.show ? extend({\n        content: name,\n        formatter: function () {\n          return name;\n        },\n        formatterParams: formatterParams\n      }, tooltipOpt) : null\n    });\n    graphic.setTextStyle(textEl.style, textStyleModel, {\n      text: truncatedText,\n      textFont: textFont,\n      textFill: textStyleModel.getTextColor() || axisModel.get('axisLine.lineStyle.color'),\n      textAlign: labelLayout.textAlign,\n      textVerticalAlign: labelLayout.textVerticalAlign\n    });\n\n    if (axisModel.get('triggerEvent')) {\n      textEl.eventData = makeAxisEventDataBase(axisModel);\n      textEl.eventData.targetType = 'axisName';\n      textEl.eventData.name = name;\n    } // FIXME\n\n\n    this._dumbGroup.add(textEl);\n\n    textEl.updateTransform();\n    this.group.add(textEl);\n    textEl.decomposeTransform();\n  }\n};\n/**\n * @public\n * @static\n * @param {Object} opt\n * @param {number} axisRotation in radian\n * @param {number} textRotation in radian\n * @param {number} direction\n * @return {Object} {\n *  rotation, // according to axis\n *  textAlign,\n *  textVerticalAlign\n * }\n */\n\nvar innerTextLayout = AxisBuilder.innerTextLayout = function (axisRotation, textRotation, direction) {\n  var rotationDiff = remRadian(textRotation - axisRotation);\n  var textAlign;\n  var textVerticalAlign;\n\n  if (isRadianAroundZero(rotationDiff)) {\n    // Label is parallel with axis line.\n    textVerticalAlign = direction > 0 ? 'top' : 'bottom';\n    textAlign = 'center';\n  } else if (isRadianAroundZero(rotationDiff - PI)) {\n    // Label is inverse parallel with axis line.\n    textVerticalAlign = direction > 0 ? 'bottom' : 'top';\n    textAlign = 'center';\n  } else {\n    textVerticalAlign = 'middle';\n\n    if (rotationDiff > 0 && rotationDiff < PI) {\n      textAlign = direction > 0 ? 'right' : 'left';\n    } else {\n      textAlign = direction > 0 ? 'left' : 'right';\n    }\n  }\n\n  return {\n    rotation: rotationDiff,\n    textAlign: textAlign,\n    textVerticalAlign: textVerticalAlign\n  };\n};\n\nfunction endTextLayout(opt, textPosition, textRotate, extent) {\n  var rotationDiff = remRadian(textRotate - opt.rotation);\n  var textAlign;\n  var textVerticalAlign;\n  var inverse = extent[0] > extent[1];\n  var onLeft = textPosition === 'start' && !inverse || textPosition !== 'start' && inverse;\n\n  if (isRadianAroundZero(rotationDiff - PI / 2)) {\n    textVerticalAlign = onLeft ? 'bottom' : 'top';\n    textAlign = 'center';\n  } else if (isRadianAroundZero(rotationDiff - PI * 1.5)) {\n    textVerticalAlign = onLeft ? 'top' : 'bottom';\n    textAlign = 'center';\n  } else {\n    textVerticalAlign = 'middle';\n\n    if (rotationDiff < PI * 1.5 && rotationDiff > PI / 2) {\n      textAlign = onLeft ? 'left' : 'right';\n    } else {\n      textAlign = onLeft ? 'right' : 'left';\n    }\n  }\n\n  return {\n    rotation: rotationDiff,\n    textAlign: textAlign,\n    textVerticalAlign: textVerticalAlign\n  };\n}\n\nfunction isSilent(axisModel) {\n  var tooltipOpt = axisModel.get('tooltip');\n  return axisModel.get('silent') // Consider mouse cursor, add these restrictions.\n  || !(axisModel.get('triggerEvent') || tooltipOpt && tooltipOpt.show);\n}\n\nfunction fixMinMaxLabelShow(axisModel, labelEls, tickEls) {\n  // If min or max are user set, we need to check\n  // If the tick on min(max) are overlap on their neighbour tick\n  // If they are overlapped, we need to hide the min(max) tick label\n  var showMinLabel = axisModel.get('axisLabel.showMinLabel');\n  var showMaxLabel = axisModel.get('axisLabel.showMaxLabel'); // FIXME\n  // Have not consider onBand yet, where tick els is more than label els.\n\n  labelEls = labelEls || [];\n  tickEls = tickEls || [];\n  var firstLabel = labelEls[0];\n  var nextLabel = labelEls[1];\n  var lastLabel = labelEls[labelEls.length - 1];\n  var prevLabel = labelEls[labelEls.length - 2];\n  var firstTick = tickEls[0];\n  var nextTick = tickEls[1];\n  var lastTick = tickEls[tickEls.length - 1];\n  var prevTick = tickEls[tickEls.length - 2];\n\n  if (showMinLabel === false) {\n    ignoreEl(firstLabel);\n    ignoreEl(firstTick);\n  } else if (isTwoLabelOverlapped(firstLabel, nextLabel)) {\n    if (showMinLabel) {\n      ignoreEl(nextLabel);\n      ignoreEl(nextTick);\n    } else {\n      ignoreEl(firstLabel);\n      ignoreEl(firstTick);\n    }\n  }\n\n  if (showMaxLabel === false) {\n    ignoreEl(lastLabel);\n    ignoreEl(lastTick);\n  } else if (isTwoLabelOverlapped(prevLabel, lastLabel)) {\n    if (showMaxLabel) {\n      ignoreEl(prevLabel);\n      ignoreEl(prevTick);\n    } else {\n      ignoreEl(lastLabel);\n      ignoreEl(lastTick);\n    }\n  }\n}\n\nfunction ignoreEl(el) {\n  el && (el.ignore = true);\n}\n\nfunction isTwoLabelOverlapped(current, next, labelLayout) {\n  // current and next has the same rotation.\n  var firstRect = current && current.getBoundingRect().clone();\n  var nextRect = next && next.getBoundingRect().clone();\n\n  if (!firstRect || !nextRect) {\n    return;\n  } // When checking intersect of two rotated labels, we use mRotationBack\n  // to avoid that boundingRect is enlarge when using `boundingRect.applyTransform`.\n\n\n  var mRotationBack = matrixUtil.identity([]);\n  matrixUtil.rotate(mRotationBack, mRotationBack, -current.rotation);\n  firstRect.applyTransform(matrixUtil.mul([], mRotationBack, current.getLocalTransform()));\n  nextRect.applyTransform(matrixUtil.mul([], mRotationBack, next.getLocalTransform()));\n  return firstRect.intersect(nextRect);\n}\n\nfunction isNameLocationCenter(nameLocation) {\n  return nameLocation === 'middle' || nameLocation === 'center';\n}\n/**\n * @static\n */\n\n\nvar ifIgnoreOnTick = AxisBuilder.ifIgnoreOnTick = function (axis, i, interval, ticksCnt, showMinLabel, showMaxLabel) {\n  if (i === 0 && showMinLabel || i === ticksCnt - 1 && showMaxLabel) {\n    return false;\n  } // FIXME\n  // Have not consider label overlap (if label is too long) yet.\n\n\n  var rawTick;\n  var scale = axis.scale;\n  return scale.type === 'ordinal' && (typeof interval === 'function' ? (rawTick = scale.getTicks()[i], !interval(rawTick, scale.getLabel(rawTick))) : i % (interval + 1));\n};\n/**\n * @static\n */\n\n\nvar getInterval = AxisBuilder.getInterval = function (model, labelInterval) {\n  var interval = model.get('interval');\n\n  if (interval == null || interval == 'auto') {\n    interval = labelInterval;\n  }\n\n  return interval;\n};\n\nfunction buildAxisTick(axisBuilder, axisModel, opt) {\n  var axis = axisModel.axis;\n\n  if (!axisModel.get('axisTick.show') || axis.scale.isBlank()) {\n    return;\n  }\n\n  var tickModel = axisModel.getModel('axisTick');\n  var lineStyleModel = tickModel.getModel('lineStyle');\n  var tickLen = tickModel.get('length');\n  var tickInterval = getInterval(tickModel, opt.labelInterval);\n  var ticksCoords = axis.getTicksCoords(tickModel.get('alignWithLabel')); // FIXME\n  // Corresponds to ticksCoords ?\n\n  var ticks = axis.scale.getTicks();\n  var showMinLabel = axisModel.get('axisLabel.showMinLabel');\n  var showMaxLabel = axisModel.get('axisLabel.showMaxLabel');\n  var pt1 = [];\n  var pt2 = [];\n  var matrix = axisBuilder._transform;\n  var tickEls = [];\n  var ticksCnt = ticksCoords.length;\n\n  for (var i = 0; i < ticksCnt; i++) {\n    // Only ordinal scale support tick interval\n    if (ifIgnoreOnTick(axis, i, tickInterval, ticksCnt, showMinLabel, showMaxLabel)) {\n      continue;\n    }\n\n    var tickCoord = ticksCoords[i];\n    pt1[0] = tickCoord;\n    pt1[1] = 0;\n    pt2[0] = tickCoord;\n    pt2[1] = opt.tickDirection * tickLen;\n\n    if (matrix) {\n      v2ApplyTransform(pt1, pt1, matrix);\n      v2ApplyTransform(pt2, pt2, matrix);\n    } // Tick line, Not use group transform to have better line draw\n\n\n    var tickEl = new graphic.Line(graphic.subPixelOptimizeLine({\n      // Id for animation\n      anid: 'tick_' + ticks[i],\n      shape: {\n        x1: pt1[0],\n        y1: pt1[1],\n        x2: pt2[0],\n        y2: pt2[1]\n      },\n      style: defaults(lineStyleModel.getLineStyle(), {\n        stroke: axisModel.get('axisLine.lineStyle.color')\n      }),\n      z2: 2,\n      silent: true\n    }));\n    axisBuilder.group.add(tickEl);\n    tickEls.push(tickEl);\n  }\n\n  return tickEls;\n}\n\nfunction buildAxisLabel(axisBuilder, axisModel, opt) {\n  var axis = axisModel.axis;\n  var show = retrieve(opt.axisLabelShow, axisModel.get('axisLabel.show'));\n\n  if (!show || axis.scale.isBlank()) {\n    return;\n  }\n\n  var labelModel = axisModel.getModel('axisLabel');\n  var labelMargin = labelModel.get('margin');\n  var ticks = axis.scale.getTicks();\n  var labels = axisModel.getFormattedLabels(); // Special label rotate.\n\n  var labelRotation = (retrieve(opt.labelRotate, labelModel.get('rotate')) || 0) * PI / 180;\n  var labelLayout = innerTextLayout(opt.rotation, labelRotation, opt.labelDirection);\n  var categoryData = axisModel.get('data');\n  var labelEls = [];\n  var silent = isSilent(axisModel);\n  var triggerEvent = axisModel.get('triggerEvent');\n  var showMinLabel = axisModel.get('axisLabel.showMinLabel');\n  var showMaxLabel = axisModel.get('axisLabel.showMaxLabel');\n  each(ticks, function (tickVal, index) {\n    if (ifIgnoreOnTick(axis, index, opt.labelInterval, ticks.length, showMinLabel, showMaxLabel)) {\n      return;\n    }\n\n    var itemLabelModel = labelModel;\n\n    if (categoryData && categoryData[tickVal] && categoryData[tickVal].textStyle) {\n      itemLabelModel = new Model(categoryData[tickVal].textStyle, labelModel, axisModel.ecModel);\n    }\n\n    var textColor = itemLabelModel.getTextColor() || axisModel.get('axisLine.lineStyle.color');\n    var tickCoord = axis.dataToCoord(tickVal);\n    var pos = [tickCoord, opt.labelOffset + opt.labelDirection * labelMargin];\n    var labelStr = axis.scale.getLabel(tickVal);\n    var textEl = new graphic.Text({\n      // Id for animation\n      anid: 'label_' + tickVal,\n      position: pos,\n      rotation: labelLayout.rotation,\n      silent: silent,\n      z2: 10\n    });\n    graphic.setTextStyle(textEl.style, itemLabelModel, {\n      text: labels[index],\n      textAlign: itemLabelModel.getShallow('align', true) || labelLayout.textAlign,\n      textVerticalAlign: itemLabelModel.getShallow('verticalAlign', true) || itemLabelModel.getShallow('baseline', true) || labelLayout.textVerticalAlign,\n      textFill: typeof textColor === 'function' ? textColor( // (1) In category axis with data zoom, tick is not the original\n      // index of axis.data. So tick should not be exposed to user\n      // in category axis.\n      // (2) Compatible with previous version, which always returns labelStr.\n      // But in interval scale labelStr is like '223,445', which maked\n      // user repalce ','. So we modify it to return original val but remain\n      // it as 'string' to avoid error in replacing.\n      axis.type === 'category' ? labelStr : axis.type === 'value' ? tickVal + '' : tickVal, index) : textColor\n    }); // Pack data for mouse event\n\n    if (triggerEvent) {\n      textEl.eventData = makeAxisEventDataBase(axisModel);\n      textEl.eventData.targetType = 'axisLabel';\n      textEl.eventData.value = labelStr;\n    } // FIXME\n\n\n    axisBuilder._dumbGroup.add(textEl);\n\n    textEl.updateTransform();\n    labelEls.push(textEl);\n    axisBuilder.group.add(textEl);\n    textEl.decomposeTransform();\n  });\n  return labelEls;\n}\n\nvar _default = AxisBuilder;\nmodule.exports = _default;","map":{"version":3,"sources":["/home/martin/Escritorio/Taller de Integracion/Tarea3-TallerDeIntegracion/node_modules/react-echarts/node_modules/echarts/lib/component/axis/AxisBuilder.js"],"names":["_util","require","retrieve","defaults","extend","each","formatUtil","graphic","Model","_number","isRadianAroundZero","remRadian","_symbol","createSymbol","matrixUtil","_vector","v2ApplyTransform","applyTransform","PI","Math","makeAxisEventDataBase","axisModel","eventData","componentType","mainType","componentIndex","AxisBuilder","opt","labelOffset","nameDirection","tickDirection","labelDirection","silent","group","Group","dumbGroup","position","slice","rotation","updateTransform","_transform","transform","_dumbGroup","prototype","constructor","hasBuilder","name","builders","add","call","getGroup","axisLine","get","extent","axis","getExtent","matrix","pt1","pt2","lineStyle","lineCap","getModel","getLineStyle","Line","subPixelOptimizeLine","anid","shape","x1","y1","x2","y2","style","strokeContainThreshold","z2","arrows","arrowSize","symbolWidth","symbolHeight","item","index","symbol","stroke","attr","axisTickLabel","tickEls","buildAxisTick","labelEls","buildAxisLabel","fixMinMaxLabelShow","axisName","nameLocation","textStyleModel","gap","gapSignal","pos","isNameLocationCenter","labelLayout","nameRotation","axisNameAvailableWidth","innerTextLayout","endTextLayout","abs","sin","isFinite","textFont","getFont","truncateOpt","ellipsis","maxWidth","nameTruncateMaxWidth","truncatedText","truncateText","minChar","placeholder","tooltipOpt","formatterParams","$vars","textEl","Text","__fullText","__truncatedText","isSilent","tooltip","show","content","formatter","setTextStyle","text","textFill","getTextColor","textAlign","textVerticalAlign","targetType","decomposeTransform","axisRotation","textRotation","direction","rotationDiff","textPosition","textRotate","inverse","onLeft","showMinLabel","showMaxLabel","firstLabel","nextLabel","lastLabel","length","prevLabel","firstTick","nextTick","lastTick","prevTick","ignoreEl","isTwoLabelOverlapped","el","ignore","current","next","firstRect","getBoundingRect","clone","nextRect","mRotationBack","identity","rotate","mul","getLocalTransform","intersect","ifIgnoreOnTick","i","interval","ticksCnt","rawTick","scale","type","getTicks","getLabel","getInterval","model","labelInterval","axisBuilder","isBlank","tickModel","lineStyleModel","tickLen","tickInterval","ticksCoords","getTicksCoords","ticks","tickCoord","tickEl","push","axisLabelShow","labelModel","labelMargin","labels","getFormattedLabels","labelRotation","labelRotate","categoryData","triggerEvent","tickVal","itemLabelModel","textStyle","ecModel","textColor","dataToCoord","labelStr","getShallow","value","_default","module","exports"],"mappings":"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","sourcesContent":["var _util = require(\"zrender/lib/core/util\");\n\nvar retrieve = _util.retrieve;\nvar defaults = _util.defaults;\nvar extend = _util.extend;\nvar each = _util.each;\n\nvar formatUtil = require(\"../../util/format\");\n\nvar graphic = require(\"../../util/graphic\");\n\nvar Model = require(\"../../model/Model\");\n\nvar _number = require(\"../../util/number\");\n\nvar isRadianAroundZero = _number.isRadianAroundZero;\nvar remRadian = _number.remRadian;\n\nvar _symbol = require(\"../../util/symbol\");\n\nvar createSymbol = _symbol.createSymbol;\n\nvar matrixUtil = require(\"zrender/lib/core/matrix\");\n\nvar _vector = require(\"zrender/lib/core/vector\");\n\nvar v2ApplyTransform = _vector.applyTransform;\nvar PI = Math.PI;\n\nfunction makeAxisEventDataBase(axisModel) {\n  var eventData = {\n    componentType: axisModel.mainType\n  };\n  eventData[axisModel.mainType + 'Index'] = axisModel.componentIndex;\n  return eventData;\n}\n/**\n * A final axis is translated and rotated from a \"standard axis\".\n * So opt.position and opt.rotation is required.\n *\n * A standard axis is and axis from [0, 0] to [0, axisExtent[1]],\n * for example: (0, 0) ------------> (0, 50)\n *\n * nameDirection or tickDirection or labelDirection is 1 means tick\n * or label is below the standard axis, whereas is -1 means above\n * the standard axis. labelOffset means offset between label and axis,\n * which is useful when 'onZero', where axisLabel is in the grid and\n * label in outside grid.\n *\n * Tips: like always,\n * positive rotation represents anticlockwise, and negative rotation\n * represents clockwise.\n * The direction of position coordinate is the same as the direction\n * of screen coordinate.\n *\n * Do not need to consider axis 'inverse', which is auto processed by\n * axis extent.\n *\n * @param {module:zrender/container/Group} group\n * @param {Object} axisModel\n * @param {Object} opt Standard axis parameters.\n * @param {Array.<number>} opt.position [x, y]\n * @param {number} opt.rotation by radian\n * @param {number} [opt.nameDirection=1] 1 or -1 Used when nameLocation is 'middle' or 'center'.\n * @param {number} [opt.tickDirection=1] 1 or -1\n * @param {number} [opt.labelDirection=1] 1 or -1\n * @param {number} [opt.labelOffset=0] Usefull when onZero.\n * @param {string} [opt.axisLabelShow] default get from axisModel.\n * @param {string} [opt.axisName] default get from axisModel.\n * @param {number} [opt.axisNameAvailableWidth]\n * @param {number} [opt.labelRotate] by degree, default get from axisModel.\n * @param {number} [opt.labelInterval] Default label interval when label\n *                                     interval from model is null or 'auto'.\n * @param {number} [opt.strokeContainThreshold] Default label interval when label\n * @param {number} [opt.nameTruncateMaxWidth]\n */\n\n\nvar AxisBuilder = function (axisModel, opt) {\n  /**\n   * @readOnly\n   */\n  this.opt = opt;\n  /**\n   * @readOnly\n   */\n\n  this.axisModel = axisModel; // Default value\n\n  defaults(opt, {\n    labelOffset: 0,\n    nameDirection: 1,\n    tickDirection: 1,\n    labelDirection: 1,\n    silent: true\n  });\n  /**\n   * @readOnly\n   */\n\n  this.group = new graphic.Group(); // FIXME Not use a seperate text group?\n\n  var dumbGroup = new graphic.Group({\n    position: opt.position.slice(),\n    rotation: opt.rotation\n  }); // this.group.add(dumbGroup);\n  // this._dumbGroup = dumbGroup;\n\n  dumbGroup.updateTransform();\n  this._transform = dumbGroup.transform;\n  this._dumbGroup = dumbGroup;\n};\n\nAxisBuilder.prototype = {\n  constructor: AxisBuilder,\n  hasBuilder: function (name) {\n    return !!builders[name];\n  },\n  add: function (name) {\n    builders[name].call(this);\n  },\n  getGroup: function () {\n    return this.group;\n  }\n};\nvar builders = {\n  /**\n   * @private\n   */\n  axisLine: function () {\n    var opt = this.opt;\n    var axisModel = this.axisModel;\n\n    if (!axisModel.get('axisLine.show')) {\n      return;\n    }\n\n    var extent = this.axisModel.axis.getExtent();\n    var matrix = this._transform;\n    var pt1 = [extent[0], 0];\n    var pt2 = [extent[1], 0];\n\n    if (matrix) {\n      v2ApplyTransform(pt1, pt1, matrix);\n      v2ApplyTransform(pt2, pt2, matrix);\n    }\n\n    var lineStyle = extend({\n      lineCap: 'round'\n    }, axisModel.getModel('axisLine.lineStyle').getLineStyle());\n    this.group.add(new graphic.Line(graphic.subPixelOptimizeLine({\n      // Id for animation\n      anid: 'line',\n      shape: {\n        x1: pt1[0],\n        y1: pt1[1],\n        x2: pt2[0],\n        y2: pt2[1]\n      },\n      style: lineStyle,\n      strokeContainThreshold: opt.strokeContainThreshold || 5,\n      silent: true,\n      z2: 1\n    })));\n    var arrows = axisModel.get('axisLine.symbol');\n    var arrowSize = axisModel.get('axisLine.symbolSize');\n\n    if (arrows != null) {\n      if (typeof arrows === 'string') {\n        // Use the same arrow for start and end point\n        arrows = [arrows, arrows];\n      }\n\n      if (typeof arrowSize === 'string' || typeof arrowSize === 'number') {\n        // Use the same size for width and height\n        arrowSize = [arrowSize, arrowSize];\n      }\n\n      var symbolWidth = arrowSize[0];\n      var symbolHeight = arrowSize[1];\n      each([[opt.rotation + Math.PI / 2, pt1], [opt.rotation - Math.PI / 2, pt2]], function (item, index) {\n        if (arrows[index] !== 'none' && arrows[index] != null) {\n          var symbol = createSymbol(arrows[index], -symbolWidth / 2, -symbolHeight / 2, symbolWidth, symbolHeight, lineStyle.stroke, true);\n          symbol.attr({\n            rotation: item[0],\n            position: item[1],\n            silent: true\n          });\n          this.group.add(symbol);\n        }\n      }, this);\n    }\n  },\n\n  /**\n   * @private\n   */\n  axisTickLabel: function () {\n    var axisModel = this.axisModel;\n    var opt = this.opt;\n    var tickEls = buildAxisTick(this, axisModel, opt);\n    var labelEls = buildAxisLabel(this, axisModel, opt);\n    fixMinMaxLabelShow(axisModel, labelEls, tickEls);\n  },\n\n  /**\n   * @private\n   */\n  axisName: function () {\n    var opt = this.opt;\n    var axisModel = this.axisModel;\n    var name = retrieve(opt.axisName, axisModel.get('name'));\n\n    if (!name) {\n      return;\n    }\n\n    var nameLocation = axisModel.get('nameLocation');\n    var nameDirection = opt.nameDirection;\n    var textStyleModel = axisModel.getModel('nameTextStyle');\n    var gap = axisModel.get('nameGap') || 0;\n    var extent = this.axisModel.axis.getExtent();\n    var gapSignal = extent[0] > extent[1] ? -1 : 1;\n    var pos = [nameLocation === 'start' ? extent[0] - gapSignal * gap : nameLocation === 'end' ? extent[1] + gapSignal * gap : (extent[0] + extent[1]) / 2, // 'middle'\n    // Reuse labelOffset.\n    isNameLocationCenter(nameLocation) ? opt.labelOffset + nameDirection * gap : 0];\n    var labelLayout;\n    var nameRotation = axisModel.get('nameRotate');\n\n    if (nameRotation != null) {\n      nameRotation = nameRotation * PI / 180; // To radian.\n    }\n\n    var axisNameAvailableWidth;\n\n    if (isNameLocationCenter(nameLocation)) {\n      labelLayout = innerTextLayout(opt.rotation, nameRotation != null ? nameRotation : opt.rotation, // Adapt to axis.\n      nameDirection);\n    } else {\n      labelLayout = endTextLayout(opt, nameLocation, nameRotation || 0, extent);\n      axisNameAvailableWidth = opt.axisNameAvailableWidth;\n\n      if (axisNameAvailableWidth != null) {\n        axisNameAvailableWidth = Math.abs(axisNameAvailableWidth / Math.sin(labelLayout.rotation));\n        !isFinite(axisNameAvailableWidth) && (axisNameAvailableWidth = null);\n      }\n    }\n\n    var textFont = textStyleModel.getFont();\n    var truncateOpt = axisModel.get('nameTruncate', true) || {};\n    var ellipsis = truncateOpt.ellipsis;\n    var maxWidth = retrieve(opt.nameTruncateMaxWidth, truncateOpt.maxWidth, axisNameAvailableWidth); // FIXME\n    // truncate rich text? (consider performance)\n\n    var truncatedText = ellipsis != null && maxWidth != null ? formatUtil.truncateText(name, maxWidth, textFont, ellipsis, {\n      minChar: 2,\n      placeholder: truncateOpt.placeholder\n    }) : name;\n    var tooltipOpt = axisModel.get('tooltip', true);\n    var mainType = axisModel.mainType;\n    var formatterParams = {\n      componentType: mainType,\n      name: name,\n      $vars: ['name']\n    };\n    formatterParams[mainType + 'Index'] = axisModel.componentIndex;\n    var textEl = new graphic.Text({\n      // Id for animation\n      anid: 'name',\n      __fullText: name,\n      __truncatedText: truncatedText,\n      position: pos,\n      rotation: labelLayout.rotation,\n      silent: isSilent(axisModel),\n      z2: 1,\n      tooltip: tooltipOpt && tooltipOpt.show ? extend({\n        content: name,\n        formatter: function () {\n          return name;\n        },\n        formatterParams: formatterParams\n      }, tooltipOpt) : null\n    });\n    graphic.setTextStyle(textEl.style, textStyleModel, {\n      text: truncatedText,\n      textFont: textFont,\n      textFill: textStyleModel.getTextColor() || axisModel.get('axisLine.lineStyle.color'),\n      textAlign: labelLayout.textAlign,\n      textVerticalAlign: labelLayout.textVerticalAlign\n    });\n\n    if (axisModel.get('triggerEvent')) {\n      textEl.eventData = makeAxisEventDataBase(axisModel);\n      textEl.eventData.targetType = 'axisName';\n      textEl.eventData.name = name;\n    } // FIXME\n\n\n    this._dumbGroup.add(textEl);\n\n    textEl.updateTransform();\n    this.group.add(textEl);\n    textEl.decomposeTransform();\n  }\n};\n/**\n * @public\n * @static\n * @param {Object} opt\n * @param {number} axisRotation in radian\n * @param {number} textRotation in radian\n * @param {number} direction\n * @return {Object} {\n *  rotation, // according to axis\n *  textAlign,\n *  textVerticalAlign\n * }\n */\n\nvar innerTextLayout = AxisBuilder.innerTextLayout = function (axisRotation, textRotation, direction) {\n  var rotationDiff = remRadian(textRotation - axisRotation);\n  var textAlign;\n  var textVerticalAlign;\n\n  if (isRadianAroundZero(rotationDiff)) {\n    // Label is parallel with axis line.\n    textVerticalAlign = direction > 0 ? 'top' : 'bottom';\n    textAlign = 'center';\n  } else if (isRadianAroundZero(rotationDiff - PI)) {\n    // Label is inverse parallel with axis line.\n    textVerticalAlign = direction > 0 ? 'bottom' : 'top';\n    textAlign = 'center';\n  } else {\n    textVerticalAlign = 'middle';\n\n    if (rotationDiff > 0 && rotationDiff < PI) {\n      textAlign = direction > 0 ? 'right' : 'left';\n    } else {\n      textAlign = direction > 0 ? 'left' : 'right';\n    }\n  }\n\n  return {\n    rotation: rotationDiff,\n    textAlign: textAlign,\n    textVerticalAlign: textVerticalAlign\n  };\n};\n\nfunction endTextLayout(opt, textPosition, textRotate, extent) {\n  var rotationDiff = remRadian(textRotate - opt.rotation);\n  var textAlign;\n  var textVerticalAlign;\n  var inverse = extent[0] > extent[1];\n  var onLeft = textPosition === 'start' && !inverse || textPosition !== 'start' && inverse;\n\n  if (isRadianAroundZero(rotationDiff - PI / 2)) {\n    textVerticalAlign = onLeft ? 'bottom' : 'top';\n    textAlign = 'center';\n  } else if (isRadianAroundZero(rotationDiff - PI * 1.5)) {\n    textVerticalAlign = onLeft ? 'top' : 'bottom';\n    textAlign = 'center';\n  } else {\n    textVerticalAlign = 'middle';\n\n    if (rotationDiff < PI * 1.5 && rotationDiff > PI / 2) {\n      textAlign = onLeft ? 'left' : 'right';\n    } else {\n      textAlign = onLeft ? 'right' : 'left';\n    }\n  }\n\n  return {\n    rotation: rotationDiff,\n    textAlign: textAlign,\n    textVerticalAlign: textVerticalAlign\n  };\n}\n\nfunction isSilent(axisModel) {\n  var tooltipOpt = axisModel.get('tooltip');\n  return axisModel.get('silent') // Consider mouse cursor, add these restrictions.\n  || !(axisModel.get('triggerEvent') || tooltipOpt && tooltipOpt.show);\n}\n\nfunction fixMinMaxLabelShow(axisModel, labelEls, tickEls) {\n  // If min or max are user set, we need to check\n  // If the tick on min(max) are overlap on their neighbour tick\n  // If they are overlapped, we need to hide the min(max) tick label\n  var showMinLabel = axisModel.get('axisLabel.showMinLabel');\n  var showMaxLabel = axisModel.get('axisLabel.showMaxLabel'); // FIXME\n  // Have not consider onBand yet, where tick els is more than label els.\n\n  labelEls = labelEls || [];\n  tickEls = tickEls || [];\n  var firstLabel = labelEls[0];\n  var nextLabel = labelEls[1];\n  var lastLabel = labelEls[labelEls.length - 1];\n  var prevLabel = labelEls[labelEls.length - 2];\n  var firstTick = tickEls[0];\n  var nextTick = tickEls[1];\n  var lastTick = tickEls[tickEls.length - 1];\n  var prevTick = tickEls[tickEls.length - 2];\n\n  if (showMinLabel === false) {\n    ignoreEl(firstLabel);\n    ignoreEl(firstTick);\n  } else if (isTwoLabelOverlapped(firstLabel, nextLabel)) {\n    if (showMinLabel) {\n      ignoreEl(nextLabel);\n      ignoreEl(nextTick);\n    } else {\n      ignoreEl(firstLabel);\n      ignoreEl(firstTick);\n    }\n  }\n\n  if (showMaxLabel === false) {\n    ignoreEl(lastLabel);\n    ignoreEl(lastTick);\n  } else if (isTwoLabelOverlapped(prevLabel, lastLabel)) {\n    if (showMaxLabel) {\n      ignoreEl(prevLabel);\n      ignoreEl(prevTick);\n    } else {\n      ignoreEl(lastLabel);\n      ignoreEl(lastTick);\n    }\n  }\n}\n\nfunction ignoreEl(el) {\n  el && (el.ignore = true);\n}\n\nfunction isTwoLabelOverlapped(current, next, labelLayout) {\n  // current and next has the same rotation.\n  var firstRect = current && current.getBoundingRect().clone();\n  var nextRect = next && next.getBoundingRect().clone();\n\n  if (!firstRect || !nextRect) {\n    return;\n  } // When checking intersect of two rotated labels, we use mRotationBack\n  // to avoid that boundingRect is enlarge when using `boundingRect.applyTransform`.\n\n\n  var mRotationBack = matrixUtil.identity([]);\n  matrixUtil.rotate(mRotationBack, mRotationBack, -current.rotation);\n  firstRect.applyTransform(matrixUtil.mul([], mRotationBack, current.getLocalTransform()));\n  nextRect.applyTransform(matrixUtil.mul([], mRotationBack, next.getLocalTransform()));\n  return firstRect.intersect(nextRect);\n}\n\nfunction isNameLocationCenter(nameLocation) {\n  return nameLocation === 'middle' || nameLocation === 'center';\n}\n/**\n * @static\n */\n\n\nvar ifIgnoreOnTick = AxisBuilder.ifIgnoreOnTick = function (axis, i, interval, ticksCnt, showMinLabel, showMaxLabel) {\n  if (i === 0 && showMinLabel || i === ticksCnt - 1 && showMaxLabel) {\n    return false;\n  } // FIXME\n  // Have not consider label overlap (if label is too long) yet.\n\n\n  var rawTick;\n  var scale = axis.scale;\n  return scale.type === 'ordinal' && (typeof interval === 'function' ? (rawTick = scale.getTicks()[i], !interval(rawTick, scale.getLabel(rawTick))) : i % (interval + 1));\n};\n/**\n * @static\n */\n\n\nvar getInterval = AxisBuilder.getInterval = function (model, labelInterval) {\n  var interval = model.get('interval');\n\n  if (interval == null || interval == 'auto') {\n    interval = labelInterval;\n  }\n\n  return interval;\n};\n\nfunction buildAxisTick(axisBuilder, axisModel, opt) {\n  var axis = axisModel.axis;\n\n  if (!axisModel.get('axisTick.show') || axis.scale.isBlank()) {\n    return;\n  }\n\n  var tickModel = axisModel.getModel('axisTick');\n  var lineStyleModel = tickModel.getModel('lineStyle');\n  var tickLen = tickModel.get('length');\n  var tickInterval = getInterval(tickModel, opt.labelInterval);\n  var ticksCoords = axis.getTicksCoords(tickModel.get('alignWithLabel')); // FIXME\n  // Corresponds to ticksCoords ?\n\n  var ticks = axis.scale.getTicks();\n  var showMinLabel = axisModel.get('axisLabel.showMinLabel');\n  var showMaxLabel = axisModel.get('axisLabel.showMaxLabel');\n  var pt1 = [];\n  var pt2 = [];\n  var matrix = axisBuilder._transform;\n  var tickEls = [];\n  var ticksCnt = ticksCoords.length;\n\n  for (var i = 0; i < ticksCnt; i++) {\n    // Only ordinal scale support tick interval\n    if (ifIgnoreOnTick(axis, i, tickInterval, ticksCnt, showMinLabel, showMaxLabel)) {\n      continue;\n    }\n\n    var tickCoord = ticksCoords[i];\n    pt1[0] = tickCoord;\n    pt1[1] = 0;\n    pt2[0] = tickCoord;\n    pt2[1] = opt.tickDirection * tickLen;\n\n    if (matrix) {\n      v2ApplyTransform(pt1, pt1, matrix);\n      v2ApplyTransform(pt2, pt2, matrix);\n    } // Tick line, Not use group transform to have better line draw\n\n\n    var tickEl = new graphic.Line(graphic.subPixelOptimizeLine({\n      // Id for animation\n      anid: 'tick_' + ticks[i],\n      shape: {\n        x1: pt1[0],\n        y1: pt1[1],\n        x2: pt2[0],\n        y2: pt2[1]\n      },\n      style: defaults(lineStyleModel.getLineStyle(), {\n        stroke: axisModel.get('axisLine.lineStyle.color')\n      }),\n      z2: 2,\n      silent: true\n    }));\n    axisBuilder.group.add(tickEl);\n    tickEls.push(tickEl);\n  }\n\n  return tickEls;\n}\n\nfunction buildAxisLabel(axisBuilder, axisModel, opt) {\n  var axis = axisModel.axis;\n  var show = retrieve(opt.axisLabelShow, axisModel.get('axisLabel.show'));\n\n  if (!show || axis.scale.isBlank()) {\n    return;\n  }\n\n  var labelModel = axisModel.getModel('axisLabel');\n  var labelMargin = labelModel.get('margin');\n  var ticks = axis.scale.getTicks();\n  var labels = axisModel.getFormattedLabels(); // Special label rotate.\n\n  var labelRotation = (retrieve(opt.labelRotate, labelModel.get('rotate')) || 0) * PI / 180;\n  var labelLayout = innerTextLayout(opt.rotation, labelRotation, opt.labelDirection);\n  var categoryData = axisModel.get('data');\n  var labelEls = [];\n  var silent = isSilent(axisModel);\n  var triggerEvent = axisModel.get('triggerEvent');\n  var showMinLabel = axisModel.get('axisLabel.showMinLabel');\n  var showMaxLabel = axisModel.get('axisLabel.showMaxLabel');\n  each(ticks, function (tickVal, index) {\n    if (ifIgnoreOnTick(axis, index, opt.labelInterval, ticks.length, showMinLabel, showMaxLabel)) {\n      return;\n    }\n\n    var itemLabelModel = labelModel;\n\n    if (categoryData && categoryData[tickVal] && categoryData[tickVal].textStyle) {\n      itemLabelModel = new Model(categoryData[tickVal].textStyle, labelModel, axisModel.ecModel);\n    }\n\n    var textColor = itemLabelModel.getTextColor() || axisModel.get('axisLine.lineStyle.color');\n    var tickCoord = axis.dataToCoord(tickVal);\n    var pos = [tickCoord, opt.labelOffset + opt.labelDirection * labelMargin];\n    var labelStr = axis.scale.getLabel(tickVal);\n    var textEl = new graphic.Text({\n      // Id for animation\n      anid: 'label_' + tickVal,\n      position: pos,\n      rotation: labelLayout.rotation,\n      silent: silent,\n      z2: 10\n    });\n    graphic.setTextStyle(textEl.style, itemLabelModel, {\n      text: labels[index],\n      textAlign: itemLabelModel.getShallow('align', true) || labelLayout.textAlign,\n      textVerticalAlign: itemLabelModel.getShallow('verticalAlign', true) || itemLabelModel.getShallow('baseline', true) || labelLayout.textVerticalAlign,\n      textFill: typeof textColor === 'function' ? textColor( // (1) In category axis with data zoom, tick is not the original\n      // index of axis.data. So tick should not be exposed to user\n      // in category axis.\n      // (2) Compatible with previous version, which always returns labelStr.\n      // But in interval scale labelStr is like '223,445', which maked\n      // user repalce ','. So we modify it to return original val but remain\n      // it as 'string' to avoid error in replacing.\n      axis.type === 'category' ? labelStr : axis.type === 'value' ? tickVal + '' : tickVal, index) : textColor\n    }); // Pack data for mouse event\n\n    if (triggerEvent) {\n      textEl.eventData = makeAxisEventDataBase(axisModel);\n      textEl.eventData.targetType = 'axisLabel';\n      textEl.eventData.value = labelStr;\n    } // FIXME\n\n\n    axisBuilder._dumbGroup.add(textEl);\n\n    textEl.updateTransform();\n    labelEls.push(textEl);\n    axisBuilder.group.add(textEl);\n    textEl.decomposeTransform();\n  });\n  return labelEls;\n}\n\nvar _default = AxisBuilder;\nmodule.exports = _default;"]},"metadata":{},"sourceType":"script"}