{"ast":null,"code":"var clazzUtil = require(\"../util/clazz\");\n/**\n * // Scale class management\n * @module echarts/scale/Scale\n */\n\n/**\n * @param {Object} [setting]\n */\n\n\nfunction Scale(setting) {\n  this._setting = setting || {};\n  /**\n   * Extent\n   * @type {Array.<number>}\n   * @protected\n   */\n\n  this._extent = [Infinity, -Infinity];\n  /**\n   * Step is calculated in adjustExtent\n   * @type {Array.<number>}\n   * @protected\n   */\n\n  this._interval = 0;\n  this.init && this.init.apply(this, arguments);\n}\n/**\n * Parse input val to valid inner number.\n * @param {*} val\n * @return {number}\n */\n\n\nScale.prototype.parse = function (val) {\n  // Notice: This would be a trap here, If the implementation\n  // of this method depends on extent, and this method is used\n  // before extent set (like in dataZoom), it would be wrong.\n  // Nevertheless, parse does not depend on extent generally.\n  return val;\n};\n\nScale.prototype.getSetting = function (name) {\n  return this._setting[name];\n};\n\nScale.prototype.contain = function (val) {\n  var extent = this._extent;\n  return val >= extent[0] && val <= extent[1];\n};\n/**\n * Normalize value to linear [0, 1], return 0.5 if extent span is 0\n * @param {number} val\n * @return {number}\n */\n\n\nScale.prototype.normalize = function (val) {\n  var extent = this._extent;\n\n  if (extent[1] === extent[0]) {\n    return 0.5;\n  }\n\n  return (val - extent[0]) / (extent[1] - extent[0]);\n};\n/**\n * Scale normalized value\n * @param {number} val\n * @return {number}\n */\n\n\nScale.prototype.scale = function (val) {\n  var extent = this._extent;\n  return val * (extent[1] - extent[0]) + extent[0];\n};\n/**\n * Set extent from data\n * @param {Array.<number>} other\n */\n\n\nScale.prototype.unionExtent = function (other) {\n  var extent = this._extent;\n  other[0] < extent[0] && (extent[0] = other[0]);\n  other[1] > extent[1] && (extent[1] = other[1]); // not setExtent because in log axis it may transformed to power\n  // this.setExtent(extent[0], extent[1]);\n};\n/**\n * Set extent from data\n * @param {module:echarts/data/List} data\n * @param {string} dim\n */\n\n\nScale.prototype.unionExtentFromData = function (data, dim) {\n  this.unionExtent(data.getDataExtent(dim, true));\n};\n/**\n * Get extent\n * @return {Array.<number>}\n */\n\n\nScale.prototype.getExtent = function () {\n  return this._extent.slice();\n};\n/**\n * Set extent\n * @param {number} start\n * @param {number} end\n */\n\n\nScale.prototype.setExtent = function (start, end) {\n  var thisExtent = this._extent;\n\n  if (!isNaN(start)) {\n    thisExtent[0] = start;\n  }\n\n  if (!isNaN(end)) {\n    thisExtent[1] = end;\n  }\n};\n/**\n * @return {Array.<string>}\n */\n\n\nScale.prototype.getTicksLabels = function () {\n  var labels = [];\n  var ticks = this.getTicks();\n\n  for (var i = 0; i < ticks.length; i++) {\n    labels.push(this.getLabel(ticks[i]));\n  }\n\n  return labels;\n};\n/**\n * When axis extent depends on data and no data exists,\n * axis ticks should not be drawn, which is named 'blank'.\n */\n\n\nScale.prototype.isBlank = function () {\n  return this._isBlank;\n},\n/**\n * When axis extent depends on data and no data exists,\n * axis ticks should not be drawn, which is named 'blank'.\n */\nScale.prototype.setBlank = function (isBlank) {\n  this._isBlank = isBlank;\n};\nclazzUtil.enableClassExtend(Scale);\nclazzUtil.enableClassManagement(Scale, {\n  registerWhenExtend: true\n});\nvar _default = Scale;\nmodule.exports = _default;","map":{"version":3,"sources":["/home/martin/Escritorio/Taller de Integracion/Tarea3-TallerDeIntegracion/node_modules/react-echarts/node_modules/echarts/lib/scale/Scale.js"],"names":["clazzUtil","require","Scale","setting","_setting","_extent","Infinity","_interval","init","apply","arguments","prototype","parse","val","getSetting","name","contain","extent","normalize","scale","unionExtent","other","unionExtentFromData","data","dim","getDataExtent","getExtent","slice","setExtent","start","end","thisExtent","isNaN","getTicksLabels","labels","ticks","getTicks","i","length","push","getLabel","isBlank","_isBlank","setBlank","enableClassExtend","enableClassManagement","registerWhenExtend","_default","module","exports"],"mappings":"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","sourcesContent":["var clazzUtil = require(\"../util/clazz\");\n\n/**\n * // Scale class management\n * @module echarts/scale/Scale\n */\n\n/**\n * @param {Object} [setting]\n */\nfunction Scale(setting) {\n  this._setting = setting || {};\n  /**\n   * Extent\n   * @type {Array.<number>}\n   * @protected\n   */\n\n  this._extent = [Infinity, -Infinity];\n  /**\n   * Step is calculated in adjustExtent\n   * @type {Array.<number>}\n   * @protected\n   */\n\n  this._interval = 0;\n  this.init && this.init.apply(this, arguments);\n}\n/**\n * Parse input val to valid inner number.\n * @param {*} val\n * @return {number}\n */\n\n\nScale.prototype.parse = function (val) {\n  // Notice: This would be a trap here, If the implementation\n  // of this method depends on extent, and this method is used\n  // before extent set (like in dataZoom), it would be wrong.\n  // Nevertheless, parse does not depend on extent generally.\n  return val;\n};\n\nScale.prototype.getSetting = function (name) {\n  return this._setting[name];\n};\n\nScale.prototype.contain = function (val) {\n  var extent = this._extent;\n  return val >= extent[0] && val <= extent[1];\n};\n/**\n * Normalize value to linear [0, 1], return 0.5 if extent span is 0\n * @param {number} val\n * @return {number}\n */\n\n\nScale.prototype.normalize = function (val) {\n  var extent = this._extent;\n\n  if (extent[1] === extent[0]) {\n    return 0.5;\n  }\n\n  return (val - extent[0]) / (extent[1] - extent[0]);\n};\n/**\n * Scale normalized value\n * @param {number} val\n * @return {number}\n */\n\n\nScale.prototype.scale = function (val) {\n  var extent = this._extent;\n  return val * (extent[1] - extent[0]) + extent[0];\n};\n/**\n * Set extent from data\n * @param {Array.<number>} other\n */\n\n\nScale.prototype.unionExtent = function (other) {\n  var extent = this._extent;\n  other[0] < extent[0] && (extent[0] = other[0]);\n  other[1] > extent[1] && (extent[1] = other[1]); // not setExtent because in log axis it may transformed to power\n  // this.setExtent(extent[0], extent[1]);\n};\n/**\n * Set extent from data\n * @param {module:echarts/data/List} data\n * @param {string} dim\n */\n\n\nScale.prototype.unionExtentFromData = function (data, dim) {\n  this.unionExtent(data.getDataExtent(dim, true));\n};\n/**\n * Get extent\n * @return {Array.<number>}\n */\n\n\nScale.prototype.getExtent = function () {\n  return this._extent.slice();\n};\n/**\n * Set extent\n * @param {number} start\n * @param {number} end\n */\n\n\nScale.prototype.setExtent = function (start, end) {\n  var thisExtent = this._extent;\n\n  if (!isNaN(start)) {\n    thisExtent[0] = start;\n  }\n\n  if (!isNaN(end)) {\n    thisExtent[1] = end;\n  }\n};\n/**\n * @return {Array.<string>}\n */\n\n\nScale.prototype.getTicksLabels = function () {\n  var labels = [];\n  var ticks = this.getTicks();\n\n  for (var i = 0; i < ticks.length; i++) {\n    labels.push(this.getLabel(ticks[i]));\n  }\n\n  return labels;\n};\n/**\n * When axis extent depends on data and no data exists,\n * axis ticks should not be drawn, which is named 'blank'.\n */\n\n\nScale.prototype.isBlank = function () {\n  return this._isBlank;\n},\n/**\n * When axis extent depends on data and no data exists,\n * axis ticks should not be drawn, which is named 'blank'.\n */\nScale.prototype.setBlank = function (isBlank) {\n  this._isBlank = isBlank;\n};\nclazzUtil.enableClassExtend(Scale);\nclazzUtil.enableClassManagement(Scale, {\n  registerWhenExtend: true\n});\nvar _default = Scale;\nmodule.exports = _default;"]},"metadata":{},"sourceType":"script"}