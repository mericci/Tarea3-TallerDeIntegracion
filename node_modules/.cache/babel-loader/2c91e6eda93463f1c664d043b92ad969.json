{"ast":null,"code":"var zrUtil = require(\"zrender/lib/core/util\");\n\nvar formatUtil = require(\"./format\");\n\nvar nubmerUtil = require(\"./number\");\n\nvar Model = require(\"../model/Model\");\n\nvar each = zrUtil.each;\nvar isObject = zrUtil.isObject;\n/**\n * If value is not array, then translate it to array.\n * @param  {*} value\n * @return {Array} [value] or value\n */\n\nfunction normalizeToArray(value) {\n  return value instanceof Array ? value : value == null ? [] : [value];\n}\n/**\n * Sync default option between normal and emphasis like `position` and `show`\n * In case some one will write code like\n *     label: {\n *         normal: {\n *             show: false,\n *             position: 'outside',\n *             fontSize: 18\n *         },\n *         emphasis: {\n *             show: true\n *         }\n *     }\n * @param {Object} opt\n * @param {Array.<string>} subOpts\n */\n\n\nfunction defaultEmphasis(opt, subOpts) {\n  if (opt) {\n    var emphasisOpt = opt.emphasis = opt.emphasis || {};\n    var normalOpt = opt.normal = opt.normal || {}; // Default emphasis option from normal\n\n    for (var i = 0, len = subOpts.length; i < len; i++) {\n      var subOptName = subOpts[i];\n\n      if (!emphasisOpt.hasOwnProperty(subOptName) && normalOpt.hasOwnProperty(subOptName)) {\n        emphasisOpt[subOptName] = normalOpt[subOptName];\n      }\n    }\n  }\n}\n\nvar TEXT_STYLE_OPTIONS = ['fontStyle', 'fontWeight', 'fontSize', 'fontFamily', 'rich', 'tag', 'color', 'textBorderColor', 'textBorderWidth', 'width', 'height', 'lineHeight', 'align', 'verticalAlign', 'baseline', 'shadowColor', 'shadowBlur', 'shadowOffsetX', 'shadowOffsetY', 'textShadowColor', 'textShadowBlur', 'textShadowOffsetX', 'textShadowOffsetY', 'backgroundColor', 'borderColor', 'borderWidth', 'borderRadius', 'padding']; // modelUtil.LABEL_OPTIONS = modelUtil.TEXT_STYLE_OPTIONS.concat([\n//     'position', 'offset', 'rotate', 'origin', 'show', 'distance', 'formatter',\n//     'fontStyle', 'fontWeight', 'fontSize', 'fontFamily',\n//     // FIXME: deprecated, check and remove it.\n//     'textStyle'\n// ]);\n\n/**\n * data could be [12, 2323, {value: 223}, [1221, 23], {value: [2, 23]}]\n * This helper method retieves value from data.\n * @param {string|number|Date|Array|Object} dataItem\n * @return {number|string|Date|Array.<number|string|Date>}\n */\n\nfunction getDataItemValue(dataItem) {\n  // Performance sensitive.\n  return dataItem && (dataItem.value == null ? dataItem : dataItem.value);\n}\n/**\n * data could be [12, 2323, {value: 223}, [1221, 23], {value: [2, 23]}]\n * This helper method determine if dataItem has extra option besides value\n * @param {string|number|Date|Array|Object} dataItem\n */\n\n\nfunction isDataItemOption(dataItem) {\n  return isObject(dataItem) && !(dataItem instanceof Array); // // markLine data can be array\n  // && !(dataItem[0] && isObject(dataItem[0]) && !(dataItem[0] instanceof Array));\n}\n/**\n * This helper method convert value in data.\n * @param {string|number|Date} value\n * @param {Object|string} [dimInfo] If string (like 'x'), dimType defaults 'number'.\n */\n\n\nfunction converDataValue(value, dimInfo) {\n  // Performance sensitive.\n  var dimType = dimInfo && dimInfo.type;\n\n  if (dimType === 'ordinal') {\n    return value;\n  }\n\n  if (dimType === 'time' // spead up when using timestamp\n  && typeof value !== 'number' && value != null && value !== '-') {\n    value = +nubmerUtil.parseDate(value);\n  } // dimType defaults 'number'.\n  // If dimType is not ordinal and value is null or undefined or NaN or '-',\n  // parse to NaN.\n\n\n  return value == null || value === '' ? NaN : +value; // If string (like '-'), using '+' parse to NaN\n}\n/**\n * Create a model proxy to be used in tooltip for edge data, markLine data, markPoint data.\n * @param {module:echarts/data/List} data\n * @param {Object} opt\n * @param {string} [opt.seriesIndex]\n * @param {Object} [opt.name]\n * @param {Object} [opt.mainType]\n * @param {Object} [opt.subType]\n */\n\n\nfunction createDataFormatModel(data, opt) {\n  var model = new Model();\n  zrUtil.mixin(model, dataFormatMixin);\n  model.seriesIndex = opt.seriesIndex;\n  model.name = opt.name || '';\n  model.mainType = opt.mainType;\n  model.subType = opt.subType;\n\n  model.getData = function () {\n    return data;\n  };\n\n  return model;\n} // PENDING A little ugly\n\n\nvar dataFormatMixin = {\n  /**\n   * Get params for formatter\n   * @param {number} dataIndex\n   * @param {string} [dataType]\n   * @return {Object}\n   */\n  getDataParams: function (dataIndex, dataType) {\n    var data = this.getData(dataType);\n    var rawValue = this.getRawValue(dataIndex, dataType);\n    var rawDataIndex = data.getRawIndex(dataIndex);\n    var name = data.getName(dataIndex, true);\n    var itemOpt = data.getRawDataItem(dataIndex);\n    var color = data.getItemVisual(dataIndex, 'color');\n    return {\n      componentType: this.mainType,\n      componentSubType: this.subType,\n      seriesType: this.mainType === 'series' ? this.subType : null,\n      seriesIndex: this.seriesIndex,\n      seriesId: this.id,\n      seriesName: this.name,\n      name: name,\n      dataIndex: rawDataIndex,\n      data: itemOpt,\n      dataType: dataType,\n      value: rawValue,\n      color: color,\n      marker: formatUtil.getTooltipMarker(color),\n      // Param name list for mapping `a`, `b`, `c`, `d`, `e`\n      $vars: ['seriesName', 'name', 'value']\n    };\n  },\n\n  /**\n   * Format label\n   * @param {number} dataIndex\n   * @param {string} [status='normal'] 'normal' or 'emphasis'\n   * @param {string} [dataType]\n   * @param {number} [dimIndex]\n   * @param {string} [labelProp='label']\n   * @return {string}\n   */\n  getFormattedLabel: function (dataIndex, status, dataType, dimIndex, labelProp) {\n    status = status || 'normal';\n    var data = this.getData(dataType);\n    var itemModel = data.getItemModel(dataIndex);\n    var params = this.getDataParams(dataIndex, dataType);\n\n    if (dimIndex != null && params.value instanceof Array) {\n      params.value = params.value[dimIndex];\n    }\n\n    var formatter = itemModel.get([labelProp || 'label', status, 'formatter']);\n\n    if (typeof formatter === 'function') {\n      params.status = status;\n      return formatter(params);\n    } else if (typeof formatter === 'string') {\n      return formatUtil.formatTpl(formatter, params);\n    }\n  },\n\n  /**\n   * Get raw value in option\n   * @param {number} idx\n   * @param {string} [dataType]\n   * @return {Object}\n   */\n  getRawValue: function (idx, dataType) {\n    var data = this.getData(dataType);\n    var dataItem = data.getRawDataItem(idx);\n\n    if (dataItem != null) {\n      return isObject(dataItem) && !(dataItem instanceof Array) ? dataItem.value : dataItem;\n    }\n  },\n\n  /**\n   * Should be implemented.\n   * @param {number} dataIndex\n   * @param {boolean} [multipleSeries=false]\n   * @param {number} [dataType]\n   * @return {string} tooltip string\n   */\n  formatTooltip: zrUtil.noop\n};\n/**\n * Mapping to exists for merge.\n *\n * @public\n * @param {Array.<Object>|Array.<module:echarts/model/Component>} exists\n * @param {Object|Array.<Object>} newCptOptions\n * @return {Array.<Object>} Result, like [{exist: ..., option: ...}, {}],\n *                          index of which is the same as exists.\n */\n\nfunction mappingToExists(exists, newCptOptions) {\n  // Mapping by the order by original option (but not order of\n  // new option) in merge mode. Because we should ensure\n  // some specified index (like xAxisIndex) is consistent with\n  // original option, which is easy to understand, espatially in\n  // media query. And in most case, merge option is used to\n  // update partial option but not be expected to change order.\n  newCptOptions = (newCptOptions || []).slice();\n  var result = zrUtil.map(exists || [], function (obj, index) {\n    return {\n      exist: obj\n    };\n  }); // Mapping by id or name if specified.\n\n  each(newCptOptions, function (cptOption, index) {\n    if (!isObject(cptOption)) {\n      return;\n    } // id has highest priority.\n\n\n    for (var i = 0; i < result.length; i++) {\n      if (!result[i].option // Consider name: two map to one.\n      && cptOption.id != null && result[i].exist.id === cptOption.id + '') {\n        result[i].option = cptOption;\n        newCptOptions[index] = null;\n        return;\n      }\n    }\n\n    for (var i = 0; i < result.length; i++) {\n      var exist = result[i].exist;\n\n      if (!result[i].option // Consider name: two map to one.\n      // Can not match when both ids exist but different.\n      && (exist.id == null || cptOption.id == null) && cptOption.name != null && !isIdInner(cptOption) && !isIdInner(exist) && exist.name === cptOption.name + '') {\n        result[i].option = cptOption;\n        newCptOptions[index] = null;\n        return;\n      }\n    }\n  }); // Otherwise mapping by index.\n\n  each(newCptOptions, function (cptOption, index) {\n    if (!isObject(cptOption)) {\n      return;\n    }\n\n    var i = 0;\n\n    for (; i < result.length; i++) {\n      var exist = result[i].exist;\n\n      if (!result[i].option // Existing model that already has id should be able to\n      // mapped to (because after mapping performed model may\n      // be assigned with a id, whish should not affect next\n      // mapping), except those has inner id.\n      && !isIdInner(exist) // Caution:\n      // Do not overwrite id. But name can be overwritten,\n      // because axis use name as 'show label text'.\n      // 'exist' always has id and name and we dont\n      // need to check it.\n      && cptOption.id == null) {\n        result[i].option = cptOption;\n        break;\n      }\n    }\n\n    if (i >= result.length) {\n      result.push({\n        option: cptOption\n      });\n    }\n  });\n  return result;\n}\n/**\n * Make id and name for mapping result (result of mappingToExists)\n * into `keyInfo` field.\n *\n * @public\n * @param {Array.<Object>} Result, like [{exist: ..., option: ...}, {}],\n *                          which order is the same as exists.\n * @return {Array.<Object>} The input.\n */\n\n\nfunction makeIdAndName(mapResult) {\n  // We use this id to hash component models and view instances\n  // in echarts. id can be specified by user, or auto generated.\n  // The id generation rule ensures new view instance are able\n  // to mapped to old instance when setOption are called in\n  // no-merge mode. So we generate model id by name and plus\n  // type in view id.\n  // name can be duplicated among components, which is convenient\n  // to specify multi components (like series) by one name.\n  // Ensure that each id is distinct.\n  var idMap = zrUtil.createHashMap();\n  each(mapResult, function (item, index) {\n    var existCpt = item.exist;\n    existCpt && idMap.set(existCpt.id, item);\n  });\n  each(mapResult, function (item, index) {\n    var opt = item.option;\n    zrUtil.assert(!opt || opt.id == null || !idMap.get(opt.id) || idMap.get(opt.id) === item, 'id duplicates: ' + (opt && opt.id));\n    opt && opt.id != null && idMap.set(opt.id, item);\n    !item.keyInfo && (item.keyInfo = {});\n  }); // Make name and id.\n\n  each(mapResult, function (item, index) {\n    var existCpt = item.exist;\n    var opt = item.option;\n    var keyInfo = item.keyInfo;\n\n    if (!isObject(opt)) {\n      return;\n    } // name can be overwitten. Consider case: axis.name = '20km'.\n    // But id generated by name will not be changed, which affect\n    // only in that case: setOption with 'not merge mode' and view\n    // instance will be recreated, which can be accepted.\n\n\n    keyInfo.name = opt.name != null ? opt.name + '' : existCpt ? existCpt.name : '\\0-'; // name may be displayed on screen, so use '-'.\n\n    if (existCpt) {\n      keyInfo.id = existCpt.id;\n    } else if (opt.id != null) {\n      keyInfo.id = opt.id + '';\n    } else {\n      // Consider this situatoin:\n      //  optionA: [{name: 'a'}, {name: 'a'}, {..}]\n      //  optionB [{..}, {name: 'a'}, {name: 'a'}]\n      // Series with the same name between optionA and optionB\n      // should be mapped.\n      var idNum = 0;\n\n      do {\n        keyInfo.id = '\\0' + keyInfo.name + '\\0' + idNum++;\n      } while (idMap.get(keyInfo.id));\n    }\n\n    idMap.set(keyInfo.id, item);\n  });\n}\n/**\n * @public\n * @param {Object} cptOption\n * @return {boolean}\n */\n\n\nfunction isIdInner(cptOption) {\n  return isObject(cptOption) && cptOption.id && (cptOption.id + '').indexOf('\\0_ec_\\0') === 0;\n}\n/**\n * A helper for removing duplicate items between batchA and batchB,\n * and in themselves, and categorize by series.\n *\n * @param {Array.<Object>} batchA Like: [{seriesId: 2, dataIndex: [32, 4, 5]}, ...]\n * @param {Array.<Object>} batchB Like: [{seriesId: 2, dataIndex: [32, 4, 5]}, ...]\n * @return {Array.<Array.<Object>, Array.<Object>>} result: [resultBatchA, resultBatchB]\n */\n\n\nfunction compressBatches(batchA, batchB) {\n  var mapA = {};\n  var mapB = {};\n  makeMap(batchA || [], mapA);\n  makeMap(batchB || [], mapB, mapA);\n  return [mapToArray(mapA), mapToArray(mapB)];\n\n  function makeMap(sourceBatch, map, otherMap) {\n    for (var i = 0, len = sourceBatch.length; i < len; i++) {\n      var seriesId = sourceBatch[i].seriesId;\n      var dataIndices = normalizeToArray(sourceBatch[i].dataIndex);\n      var otherDataIndices = otherMap && otherMap[seriesId];\n\n      for (var j = 0, lenj = dataIndices.length; j < lenj; j++) {\n        var dataIndex = dataIndices[j];\n\n        if (otherDataIndices && otherDataIndices[dataIndex]) {\n          otherDataIndices[dataIndex] = null;\n        } else {\n          (map[seriesId] || (map[seriesId] = {}))[dataIndex] = 1;\n        }\n      }\n    }\n  }\n\n  function mapToArray(map, isData) {\n    var result = [];\n\n    for (var i in map) {\n      if (map.hasOwnProperty(i) && map[i] != null) {\n        if (isData) {\n          result.push(+i);\n        } else {\n          var dataIndices = mapToArray(map[i], true);\n          dataIndices.length && result.push({\n            seriesId: i,\n            dataIndex: dataIndices\n          });\n        }\n      }\n    }\n\n    return result;\n  }\n}\n/**\n * @param {module:echarts/data/List} data\n * @param {Object} payload Contains dataIndex (means rawIndex) / dataIndexInside / name\n *                         each of which can be Array or primary type.\n * @return {number|Array.<number>} dataIndex If not found, return undefined/null.\n */\n\n\nfunction queryDataIndex(data, payload) {\n  if (payload.dataIndexInside != null) {\n    return payload.dataIndexInside;\n  } else if (payload.dataIndex != null) {\n    return zrUtil.isArray(payload.dataIndex) ? zrUtil.map(payload.dataIndex, function (value) {\n      return data.indexOfRawIndex(value);\n    }) : data.indexOfRawIndex(payload.dataIndex);\n  } else if (payload.name != null) {\n    return zrUtil.isArray(payload.name) ? zrUtil.map(payload.name, function (value) {\n      return data.indexOfName(value);\n    }) : data.indexOfName(payload.name);\n  }\n}\n/**\n * Enable property storage to any host object.\n * Notice: Serialization is not supported.\n *\n * For example:\n * var get = modelUitl.makeGetter();\n *\n * function some(hostObj) {\n *      get(hostObj)._someProperty = 1212;\n *      ...\n * }\n *\n * @return {Function}\n */\n\n\nvar makeGetter = function () {\n  var index = 0;\n  return function () {\n    var key = '\\0__ec_prop_getter_' + index++;\n    return function (hostObj) {\n      return hostObj[key] || (hostObj[key] = {});\n    };\n  };\n}();\n/**\n * @param {module:echarts/model/Global} ecModel\n * @param {string|Object} finder\n *        If string, e.g., 'geo', means {geoIndex: 0}.\n *        If Object, could contain some of these properties below:\n *        {\n *            seriesIndex, seriesId, seriesName,\n *            geoIndex, geoId, geoName,\n *            bmapIndex, bmapId, bmapName,\n *            xAxisIndex, xAxisId, xAxisName,\n *            yAxisIndex, yAxisId, yAxisName,\n *            gridIndex, gridId, gridName,\n *            ... (can be extended)\n *        }\n *        Each properties can be number|string|Array.<number>|Array.<string>\n *        For example, a finder could be\n *        {\n *            seriesIndex: 3,\n *            geoId: ['aa', 'cc'],\n *            gridName: ['xx', 'rr']\n *        }\n *        xxxIndex can be set as 'all' (means all xxx) or 'none' (means not specify)\n *        If nothing or null/undefined specified, return nothing.\n * @param {Object} [opt]\n * @param {string} [opt.defaultMainType]\n * @param {Array.<string>} [opt.includeMainTypes]\n * @return {Object} result like:\n *        {\n *            seriesModels: [seriesModel1, seriesModel2],\n *            seriesModel: seriesModel1, // The first model\n *            geoModels: [geoModel1, geoModel2],\n *            geoModel: geoModel1, // The first model\n *            ...\n *        }\n */\n\n\nfunction parseFinder(ecModel, finder, opt) {\n  if (zrUtil.isString(finder)) {\n    var obj = {};\n    obj[finder + 'Index'] = 0;\n    finder = obj;\n  }\n\n  var defaultMainType = opt && opt.defaultMainType;\n\n  if (defaultMainType && !has(finder, defaultMainType + 'Index') && !has(finder, defaultMainType + 'Id') && !has(finder, defaultMainType + 'Name')) {\n    finder[defaultMainType + 'Index'] = 0;\n  }\n\n  var result = {};\n  each(finder, function (value, key) {\n    var value = finder[key]; // Exclude 'dataIndex' and other illgal keys.\n\n    if (key === 'dataIndex' || key === 'dataIndexInside') {\n      result[key] = value;\n      return;\n    }\n\n    var parsedKey = key.match(/^(\\w+)(Index|Id|Name)$/) || [];\n    var mainType = parsedKey[1];\n    var queryType = (parsedKey[2] || '').toLowerCase();\n\n    if (!mainType || !queryType || value == null || queryType === 'index' && value === 'none' || opt && opt.includeMainTypes && zrUtil.indexOf(opt.includeMainTypes, mainType) < 0) {\n      return;\n    }\n\n    var queryParam = {\n      mainType: mainType\n    };\n\n    if (queryType !== 'index' || value !== 'all') {\n      queryParam[queryType] = value;\n    }\n\n    var models = ecModel.queryComponents(queryParam);\n    result[mainType + 'Models'] = models;\n    result[mainType + 'Model'] = models[0];\n  });\n  return result;\n}\n/**\n * @see {module:echarts/data/helper/completeDimensions}\n * @param {module:echarts/data/List} data\n * @param {string|number} dataDim\n * @return {string}\n */\n\n\nfunction dataDimToCoordDim(data, dataDim) {\n  var dimensions = data.dimensions;\n  dataDim = data.getDimension(dataDim);\n\n  for (var i = 0; i < dimensions.length; i++) {\n    var dimItem = data.getDimensionInfo(dimensions[i]);\n\n    if (dimItem.name === dataDim) {\n      return dimItem.coordDim;\n    }\n  }\n}\n/**\n * @see {module:echarts/data/helper/completeDimensions}\n * @param {module:echarts/data/List} data\n * @param {string} coordDim\n * @return {Array.<string>} data dimensions on the coordDim.\n */\n\n\nfunction coordDimToDataDim(data, coordDim) {\n  var dataDim = [];\n  each(data.dimensions, function (dimName) {\n    var dimItem = data.getDimensionInfo(dimName);\n\n    if (dimItem.coordDim === coordDim) {\n      dataDim[dimItem.coordDimIndex] = dimItem.name;\n    }\n  });\n  return dataDim;\n}\n/**\n * @see {module:echarts/data/helper/completeDimensions}\n * @param {module:echarts/data/List} data\n * @param {string} otherDim Can be `otherDims`\n *                        like 'label' or 'tooltip'.\n * @return {Array.<string>} data dimensions on the otherDim.\n */\n\n\nfunction otherDimToDataDim(data, otherDim) {\n  var dataDim = [];\n  each(data.dimensions, function (dimName) {\n    var dimItem = data.getDimensionInfo(dimName);\n    var otherDims = dimItem.otherDims;\n    var dimIndex = otherDims[otherDim];\n\n    if (dimIndex != null && dimIndex !== false) {\n      dataDim[dimIndex] = dimItem.name;\n    }\n  });\n  return dataDim;\n}\n\nfunction has(obj, prop) {\n  return obj && obj.hasOwnProperty(prop);\n}\n\nexports.normalizeToArray = normalizeToArray;\nexports.defaultEmphasis = defaultEmphasis;\nexports.TEXT_STYLE_OPTIONS = TEXT_STYLE_OPTIONS;\nexports.getDataItemValue = getDataItemValue;\nexports.isDataItemOption = isDataItemOption;\nexports.converDataValue = converDataValue;\nexports.createDataFormatModel = createDataFormatModel;\nexports.dataFormatMixin = dataFormatMixin;\nexports.mappingToExists = mappingToExists;\nexports.makeIdAndName = makeIdAndName;\nexports.isIdInner = isIdInner;\nexports.compressBatches = compressBatches;\nexports.queryDataIndex = queryDataIndex;\nexports.makeGetter = makeGetter;\nexports.parseFinder = parseFinder;\nexports.dataDimToCoordDim = dataDimToCoordDim;\nexports.coordDimToDataDim = coordDimToDataDim;\nexports.otherDimToDataDim = otherDimToDataDim;","map":{"version":3,"sources":["/home/martin/Escritorio/Taller de Integracion/Tarea3-TallerDeIntegracion/node_modules/react-echarts/node_modules/echarts/lib/util/model.js"],"names":["zrUtil","require","formatUtil","nubmerUtil","Model","each","isObject","normalizeToArray","value","Array","defaultEmphasis","opt","subOpts","emphasisOpt","emphasis","normalOpt","normal","i","len","length","subOptName","hasOwnProperty","TEXT_STYLE_OPTIONS","getDataItemValue","dataItem","isDataItemOption","converDataValue","dimInfo","dimType","type","parseDate","NaN","createDataFormatModel","data","model","mixin","dataFormatMixin","seriesIndex","name","mainType","subType","getData","getDataParams","dataIndex","dataType","rawValue","getRawValue","rawDataIndex","getRawIndex","getName","itemOpt","getRawDataItem","color","getItemVisual","componentType","componentSubType","seriesType","seriesId","id","seriesName","marker","getTooltipMarker","$vars","getFormattedLabel","status","dimIndex","labelProp","itemModel","getItemModel","params","formatter","get","formatTpl","idx","formatTooltip","noop","mappingToExists","exists","newCptOptions","slice","result","map","obj","index","exist","cptOption","option","isIdInner","push","makeIdAndName","mapResult","idMap","createHashMap","item","existCpt","set","assert","keyInfo","idNum","indexOf","compressBatches","batchA","batchB","mapA","mapB","makeMap","mapToArray","sourceBatch","otherMap","dataIndices","otherDataIndices","j","lenj","isData","queryDataIndex","payload","dataIndexInside","isArray","indexOfRawIndex","indexOfName","makeGetter","key","hostObj","parseFinder","ecModel","finder","isString","defaultMainType","has","parsedKey","match","queryType","toLowerCase","includeMainTypes","queryParam","models","queryComponents","dataDimToCoordDim","dataDim","dimensions","getDimension","dimItem","getDimensionInfo","coordDim","coordDimToDataDim","dimName","coordDimIndex","otherDimToDataDim","otherDim","otherDims","prop","exports"],"mappings":"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","sourcesContent":["var zrUtil = require(\"zrender/lib/core/util\");\n\nvar formatUtil = require(\"./format\");\n\nvar nubmerUtil = require(\"./number\");\n\nvar Model = require(\"../model/Model\");\n\nvar each = zrUtil.each;\nvar isObject = zrUtil.isObject;\n/**\n * If value is not array, then translate it to array.\n * @param  {*} value\n * @return {Array} [value] or value\n */\n\nfunction normalizeToArray(value) {\n  return value instanceof Array ? value : value == null ? [] : [value];\n}\n/**\n * Sync default option between normal and emphasis like `position` and `show`\n * In case some one will write code like\n *     label: {\n *         normal: {\n *             show: false,\n *             position: 'outside',\n *             fontSize: 18\n *         },\n *         emphasis: {\n *             show: true\n *         }\n *     }\n * @param {Object} opt\n * @param {Array.<string>} subOpts\n */\n\n\nfunction defaultEmphasis(opt, subOpts) {\n  if (opt) {\n    var emphasisOpt = opt.emphasis = opt.emphasis || {};\n    var normalOpt = opt.normal = opt.normal || {}; // Default emphasis option from normal\n\n    for (var i = 0, len = subOpts.length; i < len; i++) {\n      var subOptName = subOpts[i];\n\n      if (!emphasisOpt.hasOwnProperty(subOptName) && normalOpt.hasOwnProperty(subOptName)) {\n        emphasisOpt[subOptName] = normalOpt[subOptName];\n      }\n    }\n  }\n}\n\nvar TEXT_STYLE_OPTIONS = ['fontStyle', 'fontWeight', 'fontSize', 'fontFamily', 'rich', 'tag', 'color', 'textBorderColor', 'textBorderWidth', 'width', 'height', 'lineHeight', 'align', 'verticalAlign', 'baseline', 'shadowColor', 'shadowBlur', 'shadowOffsetX', 'shadowOffsetY', 'textShadowColor', 'textShadowBlur', 'textShadowOffsetX', 'textShadowOffsetY', 'backgroundColor', 'borderColor', 'borderWidth', 'borderRadius', 'padding']; // modelUtil.LABEL_OPTIONS = modelUtil.TEXT_STYLE_OPTIONS.concat([\n//     'position', 'offset', 'rotate', 'origin', 'show', 'distance', 'formatter',\n//     'fontStyle', 'fontWeight', 'fontSize', 'fontFamily',\n//     // FIXME: deprecated, check and remove it.\n//     'textStyle'\n// ]);\n\n/**\n * data could be [12, 2323, {value: 223}, [1221, 23], {value: [2, 23]}]\n * This helper method retieves value from data.\n * @param {string|number|Date|Array|Object} dataItem\n * @return {number|string|Date|Array.<number|string|Date>}\n */\n\nfunction getDataItemValue(dataItem) {\n  // Performance sensitive.\n  return dataItem && (dataItem.value == null ? dataItem : dataItem.value);\n}\n/**\n * data could be [12, 2323, {value: 223}, [1221, 23], {value: [2, 23]}]\n * This helper method determine if dataItem has extra option besides value\n * @param {string|number|Date|Array|Object} dataItem\n */\n\n\nfunction isDataItemOption(dataItem) {\n  return isObject(dataItem) && !(dataItem instanceof Array); // // markLine data can be array\n  // && !(dataItem[0] && isObject(dataItem[0]) && !(dataItem[0] instanceof Array));\n}\n/**\n * This helper method convert value in data.\n * @param {string|number|Date} value\n * @param {Object|string} [dimInfo] If string (like 'x'), dimType defaults 'number'.\n */\n\n\nfunction converDataValue(value, dimInfo) {\n  // Performance sensitive.\n  var dimType = dimInfo && dimInfo.type;\n\n  if (dimType === 'ordinal') {\n    return value;\n  }\n\n  if (dimType === 'time' // spead up when using timestamp\n  && typeof value !== 'number' && value != null && value !== '-') {\n    value = +nubmerUtil.parseDate(value);\n  } // dimType defaults 'number'.\n  // If dimType is not ordinal and value is null or undefined or NaN or '-',\n  // parse to NaN.\n\n\n  return value == null || value === '' ? NaN : +value; // If string (like '-'), using '+' parse to NaN\n}\n/**\n * Create a model proxy to be used in tooltip for edge data, markLine data, markPoint data.\n * @param {module:echarts/data/List} data\n * @param {Object} opt\n * @param {string} [opt.seriesIndex]\n * @param {Object} [opt.name]\n * @param {Object} [opt.mainType]\n * @param {Object} [opt.subType]\n */\n\n\nfunction createDataFormatModel(data, opt) {\n  var model = new Model();\n  zrUtil.mixin(model, dataFormatMixin);\n  model.seriesIndex = opt.seriesIndex;\n  model.name = opt.name || '';\n  model.mainType = opt.mainType;\n  model.subType = opt.subType;\n\n  model.getData = function () {\n    return data;\n  };\n\n  return model;\n} // PENDING A little ugly\n\n\nvar dataFormatMixin = {\n  /**\n   * Get params for formatter\n   * @param {number} dataIndex\n   * @param {string} [dataType]\n   * @return {Object}\n   */\n  getDataParams: function (dataIndex, dataType) {\n    var data = this.getData(dataType);\n    var rawValue = this.getRawValue(dataIndex, dataType);\n    var rawDataIndex = data.getRawIndex(dataIndex);\n    var name = data.getName(dataIndex, true);\n    var itemOpt = data.getRawDataItem(dataIndex);\n    var color = data.getItemVisual(dataIndex, 'color');\n    return {\n      componentType: this.mainType,\n      componentSubType: this.subType,\n      seriesType: this.mainType === 'series' ? this.subType : null,\n      seriesIndex: this.seriesIndex,\n      seriesId: this.id,\n      seriesName: this.name,\n      name: name,\n      dataIndex: rawDataIndex,\n      data: itemOpt,\n      dataType: dataType,\n      value: rawValue,\n      color: color,\n      marker: formatUtil.getTooltipMarker(color),\n      // Param name list for mapping `a`, `b`, `c`, `d`, `e`\n      $vars: ['seriesName', 'name', 'value']\n    };\n  },\n\n  /**\n   * Format label\n   * @param {number} dataIndex\n   * @param {string} [status='normal'] 'normal' or 'emphasis'\n   * @param {string} [dataType]\n   * @param {number} [dimIndex]\n   * @param {string} [labelProp='label']\n   * @return {string}\n   */\n  getFormattedLabel: function (dataIndex, status, dataType, dimIndex, labelProp) {\n    status = status || 'normal';\n    var data = this.getData(dataType);\n    var itemModel = data.getItemModel(dataIndex);\n    var params = this.getDataParams(dataIndex, dataType);\n\n    if (dimIndex != null && params.value instanceof Array) {\n      params.value = params.value[dimIndex];\n    }\n\n    var formatter = itemModel.get([labelProp || 'label', status, 'formatter']);\n\n    if (typeof formatter === 'function') {\n      params.status = status;\n      return formatter(params);\n    } else if (typeof formatter === 'string') {\n      return formatUtil.formatTpl(formatter, params);\n    }\n  },\n\n  /**\n   * Get raw value in option\n   * @param {number} idx\n   * @param {string} [dataType]\n   * @return {Object}\n   */\n  getRawValue: function (idx, dataType) {\n    var data = this.getData(dataType);\n    var dataItem = data.getRawDataItem(idx);\n\n    if (dataItem != null) {\n      return isObject(dataItem) && !(dataItem instanceof Array) ? dataItem.value : dataItem;\n    }\n  },\n\n  /**\n   * Should be implemented.\n   * @param {number} dataIndex\n   * @param {boolean} [multipleSeries=false]\n   * @param {number} [dataType]\n   * @return {string} tooltip string\n   */\n  formatTooltip: zrUtil.noop\n};\n/**\n * Mapping to exists for merge.\n *\n * @public\n * @param {Array.<Object>|Array.<module:echarts/model/Component>} exists\n * @param {Object|Array.<Object>} newCptOptions\n * @return {Array.<Object>} Result, like [{exist: ..., option: ...}, {}],\n *                          index of which is the same as exists.\n */\n\nfunction mappingToExists(exists, newCptOptions) {\n  // Mapping by the order by original option (but not order of\n  // new option) in merge mode. Because we should ensure\n  // some specified index (like xAxisIndex) is consistent with\n  // original option, which is easy to understand, espatially in\n  // media query. And in most case, merge option is used to\n  // update partial option but not be expected to change order.\n  newCptOptions = (newCptOptions || []).slice();\n  var result = zrUtil.map(exists || [], function (obj, index) {\n    return {\n      exist: obj\n    };\n  }); // Mapping by id or name if specified.\n\n  each(newCptOptions, function (cptOption, index) {\n    if (!isObject(cptOption)) {\n      return;\n    } // id has highest priority.\n\n\n    for (var i = 0; i < result.length; i++) {\n      if (!result[i].option // Consider name: two map to one.\n      && cptOption.id != null && result[i].exist.id === cptOption.id + '') {\n        result[i].option = cptOption;\n        newCptOptions[index] = null;\n        return;\n      }\n    }\n\n    for (var i = 0; i < result.length; i++) {\n      var exist = result[i].exist;\n\n      if (!result[i].option // Consider name: two map to one.\n      // Can not match when both ids exist but different.\n      && (exist.id == null || cptOption.id == null) && cptOption.name != null && !isIdInner(cptOption) && !isIdInner(exist) && exist.name === cptOption.name + '') {\n        result[i].option = cptOption;\n        newCptOptions[index] = null;\n        return;\n      }\n    }\n  }); // Otherwise mapping by index.\n\n  each(newCptOptions, function (cptOption, index) {\n    if (!isObject(cptOption)) {\n      return;\n    }\n\n    var i = 0;\n\n    for (; i < result.length; i++) {\n      var exist = result[i].exist;\n\n      if (!result[i].option // Existing model that already has id should be able to\n      // mapped to (because after mapping performed model may\n      // be assigned with a id, whish should not affect next\n      // mapping), except those has inner id.\n      && !isIdInner(exist) // Caution:\n      // Do not overwrite id. But name can be overwritten,\n      // because axis use name as 'show label text'.\n      // 'exist' always has id and name and we dont\n      // need to check it.\n      && cptOption.id == null) {\n        result[i].option = cptOption;\n        break;\n      }\n    }\n\n    if (i >= result.length) {\n      result.push({\n        option: cptOption\n      });\n    }\n  });\n  return result;\n}\n/**\n * Make id and name for mapping result (result of mappingToExists)\n * into `keyInfo` field.\n *\n * @public\n * @param {Array.<Object>} Result, like [{exist: ..., option: ...}, {}],\n *                          which order is the same as exists.\n * @return {Array.<Object>} The input.\n */\n\n\nfunction makeIdAndName(mapResult) {\n  // We use this id to hash component models and view instances\n  // in echarts. id can be specified by user, or auto generated.\n  // The id generation rule ensures new view instance are able\n  // to mapped to old instance when setOption are called in\n  // no-merge mode. So we generate model id by name and plus\n  // type in view id.\n  // name can be duplicated among components, which is convenient\n  // to specify multi components (like series) by one name.\n  // Ensure that each id is distinct.\n  var idMap = zrUtil.createHashMap();\n  each(mapResult, function (item, index) {\n    var existCpt = item.exist;\n    existCpt && idMap.set(existCpt.id, item);\n  });\n  each(mapResult, function (item, index) {\n    var opt = item.option;\n    zrUtil.assert(!opt || opt.id == null || !idMap.get(opt.id) || idMap.get(opt.id) === item, 'id duplicates: ' + (opt && opt.id));\n    opt && opt.id != null && idMap.set(opt.id, item);\n    !item.keyInfo && (item.keyInfo = {});\n  }); // Make name and id.\n\n  each(mapResult, function (item, index) {\n    var existCpt = item.exist;\n    var opt = item.option;\n    var keyInfo = item.keyInfo;\n\n    if (!isObject(opt)) {\n      return;\n    } // name can be overwitten. Consider case: axis.name = '20km'.\n    // But id generated by name will not be changed, which affect\n    // only in that case: setOption with 'not merge mode' and view\n    // instance will be recreated, which can be accepted.\n\n\n    keyInfo.name = opt.name != null ? opt.name + '' : existCpt ? existCpt.name : '\\0-'; // name may be displayed on screen, so use '-'.\n\n    if (existCpt) {\n      keyInfo.id = existCpt.id;\n    } else if (opt.id != null) {\n      keyInfo.id = opt.id + '';\n    } else {\n      // Consider this situatoin:\n      //  optionA: [{name: 'a'}, {name: 'a'}, {..}]\n      //  optionB [{..}, {name: 'a'}, {name: 'a'}]\n      // Series with the same name between optionA and optionB\n      // should be mapped.\n      var idNum = 0;\n\n      do {\n        keyInfo.id = '\\0' + keyInfo.name + '\\0' + idNum++;\n      } while (idMap.get(keyInfo.id));\n    }\n\n    idMap.set(keyInfo.id, item);\n  });\n}\n/**\n * @public\n * @param {Object} cptOption\n * @return {boolean}\n */\n\n\nfunction isIdInner(cptOption) {\n  return isObject(cptOption) && cptOption.id && (cptOption.id + '').indexOf('\\0_ec_\\0') === 0;\n}\n/**\n * A helper for removing duplicate items between batchA and batchB,\n * and in themselves, and categorize by series.\n *\n * @param {Array.<Object>} batchA Like: [{seriesId: 2, dataIndex: [32, 4, 5]}, ...]\n * @param {Array.<Object>} batchB Like: [{seriesId: 2, dataIndex: [32, 4, 5]}, ...]\n * @return {Array.<Array.<Object>, Array.<Object>>} result: [resultBatchA, resultBatchB]\n */\n\n\nfunction compressBatches(batchA, batchB) {\n  var mapA = {};\n  var mapB = {};\n  makeMap(batchA || [], mapA);\n  makeMap(batchB || [], mapB, mapA);\n  return [mapToArray(mapA), mapToArray(mapB)];\n\n  function makeMap(sourceBatch, map, otherMap) {\n    for (var i = 0, len = sourceBatch.length; i < len; i++) {\n      var seriesId = sourceBatch[i].seriesId;\n      var dataIndices = normalizeToArray(sourceBatch[i].dataIndex);\n      var otherDataIndices = otherMap && otherMap[seriesId];\n\n      for (var j = 0, lenj = dataIndices.length; j < lenj; j++) {\n        var dataIndex = dataIndices[j];\n\n        if (otherDataIndices && otherDataIndices[dataIndex]) {\n          otherDataIndices[dataIndex] = null;\n        } else {\n          (map[seriesId] || (map[seriesId] = {}))[dataIndex] = 1;\n        }\n      }\n    }\n  }\n\n  function mapToArray(map, isData) {\n    var result = [];\n\n    for (var i in map) {\n      if (map.hasOwnProperty(i) && map[i] != null) {\n        if (isData) {\n          result.push(+i);\n        } else {\n          var dataIndices = mapToArray(map[i], true);\n          dataIndices.length && result.push({\n            seriesId: i,\n            dataIndex: dataIndices\n          });\n        }\n      }\n    }\n\n    return result;\n  }\n}\n/**\n * @param {module:echarts/data/List} data\n * @param {Object} payload Contains dataIndex (means rawIndex) / dataIndexInside / name\n *                         each of which can be Array or primary type.\n * @return {number|Array.<number>} dataIndex If not found, return undefined/null.\n */\n\n\nfunction queryDataIndex(data, payload) {\n  if (payload.dataIndexInside != null) {\n    return payload.dataIndexInside;\n  } else if (payload.dataIndex != null) {\n    return zrUtil.isArray(payload.dataIndex) ? zrUtil.map(payload.dataIndex, function (value) {\n      return data.indexOfRawIndex(value);\n    }) : data.indexOfRawIndex(payload.dataIndex);\n  } else if (payload.name != null) {\n    return zrUtil.isArray(payload.name) ? zrUtil.map(payload.name, function (value) {\n      return data.indexOfName(value);\n    }) : data.indexOfName(payload.name);\n  }\n}\n/**\n * Enable property storage to any host object.\n * Notice: Serialization is not supported.\n *\n * For example:\n * var get = modelUitl.makeGetter();\n *\n * function some(hostObj) {\n *      get(hostObj)._someProperty = 1212;\n *      ...\n * }\n *\n * @return {Function}\n */\n\n\nvar makeGetter = function () {\n  var index = 0;\n  return function () {\n    var key = '\\0__ec_prop_getter_' + index++;\n    return function (hostObj) {\n      return hostObj[key] || (hostObj[key] = {});\n    };\n  };\n}();\n/**\n * @param {module:echarts/model/Global} ecModel\n * @param {string|Object} finder\n *        If string, e.g., 'geo', means {geoIndex: 0}.\n *        If Object, could contain some of these properties below:\n *        {\n *            seriesIndex, seriesId, seriesName,\n *            geoIndex, geoId, geoName,\n *            bmapIndex, bmapId, bmapName,\n *            xAxisIndex, xAxisId, xAxisName,\n *            yAxisIndex, yAxisId, yAxisName,\n *            gridIndex, gridId, gridName,\n *            ... (can be extended)\n *        }\n *        Each properties can be number|string|Array.<number>|Array.<string>\n *        For example, a finder could be\n *        {\n *            seriesIndex: 3,\n *            geoId: ['aa', 'cc'],\n *            gridName: ['xx', 'rr']\n *        }\n *        xxxIndex can be set as 'all' (means all xxx) or 'none' (means not specify)\n *        If nothing or null/undefined specified, return nothing.\n * @param {Object} [opt]\n * @param {string} [opt.defaultMainType]\n * @param {Array.<string>} [opt.includeMainTypes]\n * @return {Object} result like:\n *        {\n *            seriesModels: [seriesModel1, seriesModel2],\n *            seriesModel: seriesModel1, // The first model\n *            geoModels: [geoModel1, geoModel2],\n *            geoModel: geoModel1, // The first model\n *            ...\n *        }\n */\n\n\nfunction parseFinder(ecModel, finder, opt) {\n  if (zrUtil.isString(finder)) {\n    var obj = {};\n    obj[finder + 'Index'] = 0;\n    finder = obj;\n  }\n\n  var defaultMainType = opt && opt.defaultMainType;\n\n  if (defaultMainType && !has(finder, defaultMainType + 'Index') && !has(finder, defaultMainType + 'Id') && !has(finder, defaultMainType + 'Name')) {\n    finder[defaultMainType + 'Index'] = 0;\n  }\n\n  var result = {};\n  each(finder, function (value, key) {\n    var value = finder[key]; // Exclude 'dataIndex' and other illgal keys.\n\n    if (key === 'dataIndex' || key === 'dataIndexInside') {\n      result[key] = value;\n      return;\n    }\n\n    var parsedKey = key.match(/^(\\w+)(Index|Id|Name)$/) || [];\n    var mainType = parsedKey[1];\n    var queryType = (parsedKey[2] || '').toLowerCase();\n\n    if (!mainType || !queryType || value == null || queryType === 'index' && value === 'none' || opt && opt.includeMainTypes && zrUtil.indexOf(opt.includeMainTypes, mainType) < 0) {\n      return;\n    }\n\n    var queryParam = {\n      mainType: mainType\n    };\n\n    if (queryType !== 'index' || value !== 'all') {\n      queryParam[queryType] = value;\n    }\n\n    var models = ecModel.queryComponents(queryParam);\n    result[mainType + 'Models'] = models;\n    result[mainType + 'Model'] = models[0];\n  });\n  return result;\n}\n/**\n * @see {module:echarts/data/helper/completeDimensions}\n * @param {module:echarts/data/List} data\n * @param {string|number} dataDim\n * @return {string}\n */\n\n\nfunction dataDimToCoordDim(data, dataDim) {\n  var dimensions = data.dimensions;\n  dataDim = data.getDimension(dataDim);\n\n  for (var i = 0; i < dimensions.length; i++) {\n    var dimItem = data.getDimensionInfo(dimensions[i]);\n\n    if (dimItem.name === dataDim) {\n      return dimItem.coordDim;\n    }\n  }\n}\n/**\n * @see {module:echarts/data/helper/completeDimensions}\n * @param {module:echarts/data/List} data\n * @param {string} coordDim\n * @return {Array.<string>} data dimensions on the coordDim.\n */\n\n\nfunction coordDimToDataDim(data, coordDim) {\n  var dataDim = [];\n  each(data.dimensions, function (dimName) {\n    var dimItem = data.getDimensionInfo(dimName);\n\n    if (dimItem.coordDim === coordDim) {\n      dataDim[dimItem.coordDimIndex] = dimItem.name;\n    }\n  });\n  return dataDim;\n}\n/**\n * @see {module:echarts/data/helper/completeDimensions}\n * @param {module:echarts/data/List} data\n * @param {string} otherDim Can be `otherDims`\n *                        like 'label' or 'tooltip'.\n * @return {Array.<string>} data dimensions on the otherDim.\n */\n\n\nfunction otherDimToDataDim(data, otherDim) {\n  var dataDim = [];\n  each(data.dimensions, function (dimName) {\n    var dimItem = data.getDimensionInfo(dimName);\n    var otherDims = dimItem.otherDims;\n    var dimIndex = otherDims[otherDim];\n\n    if (dimIndex != null && dimIndex !== false) {\n      dataDim[dimIndex] = dimItem.name;\n    }\n  });\n  return dataDim;\n}\n\nfunction has(obj, prop) {\n  return obj && obj.hasOwnProperty(prop);\n}\n\nexports.normalizeToArray = normalizeToArray;\nexports.defaultEmphasis = defaultEmphasis;\nexports.TEXT_STYLE_OPTIONS = TEXT_STYLE_OPTIONS;\nexports.getDataItemValue = getDataItemValue;\nexports.isDataItemOption = isDataItemOption;\nexports.converDataValue = converDataValue;\nexports.createDataFormatModel = createDataFormatModel;\nexports.dataFormatMixin = dataFormatMixin;\nexports.mappingToExists = mappingToExists;\nexports.makeIdAndName = makeIdAndName;\nexports.isIdInner = isIdInner;\nexports.compressBatches = compressBatches;\nexports.queryDataIndex = queryDataIndex;\nexports.makeGetter = makeGetter;\nexports.parseFinder = parseFinder;\nexports.dataDimToCoordDim = dataDimToCoordDim;\nexports.coordDimToDataDim = coordDimToDataDim;\nexports.otherDimToDataDim = otherDimToDataDim;"]},"metadata":{},"sourceType":"script"}