{"ast":null,"code":"var numberUtil = require(\"../util/number\");\n\nvar formatUtil = require(\"../util/format\");\n\nvar Scale = require(\"./Scale\");\n\nvar helper = require(\"./helper\");\n/**\n * Interval scale\n * @module echarts/scale/Interval\n */\n\n\nvar roundNumber = numberUtil.round;\n/**\n * @alias module:echarts/coord/scale/Interval\n * @constructor\n */\n\nvar IntervalScale = Scale.extend({\n  type: 'interval',\n  _interval: 0,\n  _intervalPrecision: 2,\n  setExtent: function (start, end) {\n    var thisExtent = this._extent; //start,end may be a Number like '25',so...\n\n    if (!isNaN(start)) {\n      thisExtent[0] = parseFloat(start);\n    }\n\n    if (!isNaN(end)) {\n      thisExtent[1] = parseFloat(end);\n    }\n  },\n  unionExtent: function (other) {\n    var extent = this._extent;\n    other[0] < extent[0] && (extent[0] = other[0]);\n    other[1] > extent[1] && (extent[1] = other[1]); // unionExtent may called by it's sub classes\n\n    IntervalScale.prototype.setExtent.call(this, extent[0], extent[1]);\n  },\n\n  /**\n   * Get interval\n   */\n  getInterval: function () {\n    return this._interval;\n  },\n\n  /**\n   * Set interval\n   */\n  setInterval: function (interval) {\n    this._interval = interval; // Dropped auto calculated niceExtent and use user setted extent\n    // We assume user wan't to set both interval, min, max to get a better result\n\n    this._niceExtent = this._extent.slice();\n    this._intervalPrecision = helper.getIntervalPrecision(interval);\n  },\n\n  /**\n   * @return {Array.<number>}\n   */\n  getTicks: function () {\n    return helper.intervalScaleGetTicks(this._interval, this._extent, this._niceExtent, this._intervalPrecision);\n  },\n\n  /**\n   * @return {Array.<string>}\n   */\n  getTicksLabels: function () {\n    var labels = [];\n    var ticks = this.getTicks();\n\n    for (var i = 0; i < ticks.length; i++) {\n      labels.push(this.getLabel(ticks[i]));\n    }\n\n    return labels;\n  },\n\n  /**\n   * @param {number} data\n   * @param {Object} [opt]\n   * @param {number|string} [opt.precision] If 'auto', use nice presision.\n   * @param {boolean} [opt.pad] returns 1.50 but not 1.5 if precision is 2.\n   * @return {string}\n   */\n  getLabel: function (data, opt) {\n    if (data == null) {\n      return '';\n    }\n\n    var precision = opt && opt.precision;\n\n    if (precision == null) {\n      precision = numberUtil.getPrecisionSafe(data) || 0;\n    } else if (precision === 'auto') {\n      // Should be more precise then tick.\n      precision = this._intervalPrecision;\n    } // (1) If `precision` is set, 12.005 should be display as '12.00500'.\n    // (2) Use roundNumber (toFixed) to avoid scientific notation like '3.5e-7'.\n\n\n    data = roundNumber(data, precision, true);\n    return formatUtil.addCommas(data);\n  },\n\n  /**\n   * Update interval and extent of intervals for nice ticks\n   *\n   * @param {number} [splitNumber = 5] Desired number of ticks\n   * @param {number} [minInterval]\n   * @param {number} [maxInterval]\n   */\n  niceTicks: function (splitNumber, minInterval, maxInterval) {\n    splitNumber = splitNumber || 5;\n    var extent = this._extent;\n    var span = extent[1] - extent[0];\n\n    if (!isFinite(span)) {\n      return;\n    } // User may set axis min 0 and data are all negative\n    // FIXME If it needs to reverse ?\n\n\n    if (span < 0) {\n      span = -span;\n      extent.reverse();\n    }\n\n    var result = helper.intervalScaleNiceTicks(extent, splitNumber, minInterval, maxInterval);\n    this._intervalPrecision = result.intervalPrecision;\n    this._interval = result.interval;\n    this._niceExtent = result.niceTickExtent;\n  },\n\n  /**\n   * Nice extent.\n   * @param {Object} opt\n   * @param {number} [opt.splitNumber = 5] Given approx tick number\n   * @param {boolean} [opt.fixMin=false]\n   * @param {boolean} [opt.fixMax=false]\n   * @param {boolean} [opt.minInterval]\n   * @param {boolean} [opt.maxInterval]\n   */\n  niceExtent: function (opt) {\n    var extent = this._extent; // If extent start and end are same, expand them\n\n    if (extent[0] === extent[1]) {\n      if (extent[0] !== 0) {\n        // Expand extent\n        var expandSize = extent[0]; // In the fowllowing case\n        //      Axis has been fixed max 100\n        //      Plus data are all 100 and axis extent are [100, 100].\n        // Extend to the both side will cause expanded max is larger than fixed max.\n        // So only expand to the smaller side.\n\n        if (!opt.fixMax) {\n          extent[1] += expandSize / 2;\n          extent[0] -= expandSize / 2;\n        } else {\n          extent[0] -= expandSize / 2;\n        }\n      } else {\n        extent[1] = 1;\n      }\n    }\n\n    var span = extent[1] - extent[0]; // If there are no data and extent are [Infinity, -Infinity]\n\n    if (!isFinite(span)) {\n      extent[0] = 0;\n      extent[1] = 1;\n    }\n\n    this.niceTicks(opt.splitNumber, opt.minInterval, opt.maxInterval); // var extent = this._extent;\n\n    var interval = this._interval;\n\n    if (!opt.fixMin) {\n      extent[0] = roundNumber(Math.floor(extent[0] / interval) * interval);\n    }\n\n    if (!opt.fixMax) {\n      extent[1] = roundNumber(Math.ceil(extent[1] / interval) * interval);\n    }\n  }\n});\n/**\n * @return {module:echarts/scale/Time}\n */\n\nIntervalScale.create = function () {\n  return new IntervalScale();\n};\n\nvar _default = IntervalScale;\nmodule.exports = _default;","map":{"version":3,"sources":["/home/martin/Escritorio/Taller de Integracion/Tarea3-TallerDeIntegracion/node_modules/react-echarts/node_modules/echarts/lib/scale/Interval.js"],"names":["numberUtil","require","formatUtil","Scale","helper","roundNumber","round","IntervalScale","extend","type","_interval","_intervalPrecision","setExtent","start","end","thisExtent","_extent","isNaN","parseFloat","unionExtent","other","extent","prototype","call","getInterval","setInterval","interval","_niceExtent","slice","getIntervalPrecision","getTicks","intervalScaleGetTicks","getTicksLabels","labels","ticks","i","length","push","getLabel","data","opt","precision","getPrecisionSafe","addCommas","niceTicks","splitNumber","minInterval","maxInterval","span","isFinite","reverse","result","intervalScaleNiceTicks","intervalPrecision","niceTickExtent","niceExtent","expandSize","fixMax","fixMin","Math","floor","ceil","create","_default","module","exports"],"mappings":"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","sourcesContent":["var numberUtil = require(\"../util/number\");\n\nvar formatUtil = require(\"../util/format\");\n\nvar Scale = require(\"./Scale\");\n\nvar helper = require(\"./helper\");\n\n/**\n * Interval scale\n * @module echarts/scale/Interval\n */\nvar roundNumber = numberUtil.round;\n/**\n * @alias module:echarts/coord/scale/Interval\n * @constructor\n */\n\nvar IntervalScale = Scale.extend({\n  type: 'interval',\n  _interval: 0,\n  _intervalPrecision: 2,\n  setExtent: function (start, end) {\n    var thisExtent = this._extent; //start,end may be a Number like '25',so...\n\n    if (!isNaN(start)) {\n      thisExtent[0] = parseFloat(start);\n    }\n\n    if (!isNaN(end)) {\n      thisExtent[1] = parseFloat(end);\n    }\n  },\n  unionExtent: function (other) {\n    var extent = this._extent;\n    other[0] < extent[0] && (extent[0] = other[0]);\n    other[1] > extent[1] && (extent[1] = other[1]); // unionExtent may called by it's sub classes\n\n    IntervalScale.prototype.setExtent.call(this, extent[0], extent[1]);\n  },\n\n  /**\n   * Get interval\n   */\n  getInterval: function () {\n    return this._interval;\n  },\n\n  /**\n   * Set interval\n   */\n  setInterval: function (interval) {\n    this._interval = interval; // Dropped auto calculated niceExtent and use user setted extent\n    // We assume user wan't to set both interval, min, max to get a better result\n\n    this._niceExtent = this._extent.slice();\n    this._intervalPrecision = helper.getIntervalPrecision(interval);\n  },\n\n  /**\n   * @return {Array.<number>}\n   */\n  getTicks: function () {\n    return helper.intervalScaleGetTicks(this._interval, this._extent, this._niceExtent, this._intervalPrecision);\n  },\n\n  /**\n   * @return {Array.<string>}\n   */\n  getTicksLabels: function () {\n    var labels = [];\n    var ticks = this.getTicks();\n\n    for (var i = 0; i < ticks.length; i++) {\n      labels.push(this.getLabel(ticks[i]));\n    }\n\n    return labels;\n  },\n\n  /**\n   * @param {number} data\n   * @param {Object} [opt]\n   * @param {number|string} [opt.precision] If 'auto', use nice presision.\n   * @param {boolean} [opt.pad] returns 1.50 but not 1.5 if precision is 2.\n   * @return {string}\n   */\n  getLabel: function (data, opt) {\n    if (data == null) {\n      return '';\n    }\n\n    var precision = opt && opt.precision;\n\n    if (precision == null) {\n      precision = numberUtil.getPrecisionSafe(data) || 0;\n    } else if (precision === 'auto') {\n      // Should be more precise then tick.\n      precision = this._intervalPrecision;\n    } // (1) If `precision` is set, 12.005 should be display as '12.00500'.\n    // (2) Use roundNumber (toFixed) to avoid scientific notation like '3.5e-7'.\n\n\n    data = roundNumber(data, precision, true);\n    return formatUtil.addCommas(data);\n  },\n\n  /**\n   * Update interval and extent of intervals for nice ticks\n   *\n   * @param {number} [splitNumber = 5] Desired number of ticks\n   * @param {number} [minInterval]\n   * @param {number} [maxInterval]\n   */\n  niceTicks: function (splitNumber, minInterval, maxInterval) {\n    splitNumber = splitNumber || 5;\n    var extent = this._extent;\n    var span = extent[1] - extent[0];\n\n    if (!isFinite(span)) {\n      return;\n    } // User may set axis min 0 and data are all negative\n    // FIXME If it needs to reverse ?\n\n\n    if (span < 0) {\n      span = -span;\n      extent.reverse();\n    }\n\n    var result = helper.intervalScaleNiceTicks(extent, splitNumber, minInterval, maxInterval);\n    this._intervalPrecision = result.intervalPrecision;\n    this._interval = result.interval;\n    this._niceExtent = result.niceTickExtent;\n  },\n\n  /**\n   * Nice extent.\n   * @param {Object} opt\n   * @param {number} [opt.splitNumber = 5] Given approx tick number\n   * @param {boolean} [opt.fixMin=false]\n   * @param {boolean} [opt.fixMax=false]\n   * @param {boolean} [opt.minInterval]\n   * @param {boolean} [opt.maxInterval]\n   */\n  niceExtent: function (opt) {\n    var extent = this._extent; // If extent start and end are same, expand them\n\n    if (extent[0] === extent[1]) {\n      if (extent[0] !== 0) {\n        // Expand extent\n        var expandSize = extent[0]; // In the fowllowing case\n        //      Axis has been fixed max 100\n        //      Plus data are all 100 and axis extent are [100, 100].\n        // Extend to the both side will cause expanded max is larger than fixed max.\n        // So only expand to the smaller side.\n\n        if (!opt.fixMax) {\n          extent[1] += expandSize / 2;\n          extent[0] -= expandSize / 2;\n        } else {\n          extent[0] -= expandSize / 2;\n        }\n      } else {\n        extent[1] = 1;\n      }\n    }\n\n    var span = extent[1] - extent[0]; // If there are no data and extent are [Infinity, -Infinity]\n\n    if (!isFinite(span)) {\n      extent[0] = 0;\n      extent[1] = 1;\n    }\n\n    this.niceTicks(opt.splitNumber, opt.minInterval, opt.maxInterval); // var extent = this._extent;\n\n    var interval = this._interval;\n\n    if (!opt.fixMin) {\n      extent[0] = roundNumber(Math.floor(extent[0] / interval) * interval);\n    }\n\n    if (!opt.fixMax) {\n      extent[1] = roundNumber(Math.ceil(extent[1] / interval) * interval);\n    }\n  }\n});\n/**\n * @return {module:echarts/scale/Time}\n */\n\nIntervalScale.create = function () {\n  return new IntervalScale();\n};\n\nvar _default = IntervalScale;\nmodule.exports = _default;"]},"metadata":{},"sourceType":"script"}