{"ast":null,"code":"var Displayable = require(\"./Displayable\");\n\nvar zrUtil = require(\"../core/util\");\n\nvar PathProxy = require(\"../core/PathProxy\");\n\nvar pathContain = require(\"../contain/path\");\n\nvar Pattern = require(\"./Pattern\");\n\nvar getCanvasPattern = Pattern.prototype.getCanvasPattern;\nvar abs = Math.abs;\nvar pathProxyForDraw = new PathProxy(true);\n/**\n * @alias module:zrender/graphic/Path\n * @extends module:zrender/graphic/Displayable\n * @constructor\n * @param {Object} opts\n */\n\nfunction Path(opts) {\n  Displayable.call(this, opts);\n  /**\n   * @type {module:zrender/core/PathProxy}\n   * @readOnly\n   */\n\n  this.path = null;\n}\n\nPath.prototype = {\n  constructor: Path,\n  type: 'path',\n  __dirtyPath: true,\n  strokeContainThreshold: 5,\n  brush: function (ctx, prevEl) {\n    var style = this.style;\n    var path = this.path || pathProxyForDraw;\n    var hasStroke = style.hasStroke();\n    var hasFill = style.hasFill();\n    var fill = style.fill;\n    var stroke = style.stroke;\n    var hasFillGradient = hasFill && !!fill.colorStops;\n    var hasStrokeGradient = hasStroke && !!stroke.colorStops;\n    var hasFillPattern = hasFill && !!fill.image;\n    var hasStrokePattern = hasStroke && !!stroke.image;\n    style.bind(ctx, this, prevEl);\n    this.setTransform(ctx);\n\n    if (this.__dirty) {\n      var rect; // Update gradient because bounding rect may changed\n\n      if (hasFillGradient) {\n        rect = rect || this.getBoundingRect();\n        this._fillGradient = style.getGradient(ctx, fill, rect);\n      }\n\n      if (hasStrokeGradient) {\n        rect = rect || this.getBoundingRect();\n        this._strokeGradient = style.getGradient(ctx, stroke, rect);\n      }\n    } // Use the gradient or pattern\n\n\n    if (hasFillGradient) {\n      // PENDING If may have affect the state\n      ctx.fillStyle = this._fillGradient;\n    } else if (hasFillPattern) {\n      ctx.fillStyle = getCanvasPattern.call(fill, ctx);\n    }\n\n    if (hasStrokeGradient) {\n      ctx.strokeStyle = this._strokeGradient;\n    } else if (hasStrokePattern) {\n      ctx.strokeStyle = getCanvasPattern.call(stroke, ctx);\n    }\n\n    var lineDash = style.lineDash;\n    var lineDashOffset = style.lineDashOffset;\n    var ctxLineDash = !!ctx.setLineDash; // Update path sx, sy\n\n    var scale = this.getGlobalScale();\n    path.setScale(scale[0], scale[1]); // Proxy context\n    // Rebuild path in following 2 cases\n    // 1. Path is dirty\n    // 2. Path needs javascript implemented lineDash stroking.\n    //    In this case, lineDash information will not be saved in PathProxy\n\n    if (this.__dirtyPath || lineDash && !ctxLineDash && hasStroke) {\n      path.beginPath(ctx); // Setting line dash before build path\n\n      if (lineDash && !ctxLineDash) {\n        path.setLineDash(lineDash);\n        path.setLineDashOffset(lineDashOffset);\n      }\n\n      this.buildPath(path, this.shape, false); // Clear path dirty flag\n\n      if (this.path) {\n        this.__dirtyPath = false;\n      }\n    } else {\n      // Replay path building\n      ctx.beginPath();\n      this.path.rebuildPath(ctx);\n    }\n\n    hasFill && path.fill(ctx);\n\n    if (lineDash && ctxLineDash) {\n      ctx.setLineDash(lineDash);\n      ctx.lineDashOffset = lineDashOffset;\n    }\n\n    hasStroke && path.stroke(ctx);\n\n    if (lineDash && ctxLineDash) {\n      // PENDING\n      // Remove lineDash\n      ctx.setLineDash([]);\n    }\n\n    this.restoreTransform(ctx); // Draw rect text\n\n    if (style.text != null) {\n      this.drawRectText(ctx, this.getBoundingRect());\n    }\n  },\n  // When bundling path, some shape may decide if use moveTo to begin a new subpath or closePath\n  // Like in circle\n  buildPath: function (ctx, shapeCfg, inBundle) {},\n  createPathProxy: function () {\n    this.path = new PathProxy();\n  },\n  getBoundingRect: function () {\n    var rect = this._rect;\n    var style = this.style;\n    var needsUpdateRect = !rect;\n\n    if (needsUpdateRect) {\n      var path = this.path;\n\n      if (!path) {\n        // Create path on demand.\n        path = this.path = new PathProxy();\n      }\n\n      if (this.__dirtyPath) {\n        path.beginPath();\n        this.buildPath(path, this.shape, false);\n      }\n\n      rect = path.getBoundingRect();\n    }\n\n    this._rect = rect;\n\n    if (style.hasStroke()) {\n      // Needs update rect with stroke lineWidth when\n      // 1. Element changes scale or lineWidth\n      // 2. Shape is changed\n      var rectWithStroke = this._rectWithStroke || (this._rectWithStroke = rect.clone());\n\n      if (this.__dirty || needsUpdateRect) {\n        rectWithStroke.copy(rect); // FIXME Must after updateTransform\n\n        var w = style.lineWidth; // PENDING, Min line width is needed when line is horizontal or vertical\n\n        var lineScale = style.strokeNoScale ? this.getLineScale() : 1; // Only add extra hover lineWidth when there are no fill\n\n        if (!style.hasFill()) {\n          w = Math.max(w, this.strokeContainThreshold || 4);\n        } // Consider line width\n        // Line scale can't be 0;\n\n\n        if (lineScale > 1e-10) {\n          rectWithStroke.width += w / lineScale;\n          rectWithStroke.height += w / lineScale;\n          rectWithStroke.x -= w / lineScale / 2;\n          rectWithStroke.y -= w / lineScale / 2;\n        }\n      } // Return rect with stroke\n\n\n      return rectWithStroke;\n    }\n\n    return rect;\n  },\n  contain: function (x, y) {\n    var localPos = this.transformCoordToLocal(x, y);\n    var rect = this.getBoundingRect();\n    var style = this.style;\n    x = localPos[0];\n    y = localPos[1];\n\n    if (rect.contain(x, y)) {\n      var pathData = this.path.data;\n\n      if (style.hasStroke()) {\n        var lineWidth = style.lineWidth;\n        var lineScale = style.strokeNoScale ? this.getLineScale() : 1; // Line scale can't be 0;\n\n        if (lineScale > 1e-10) {\n          // Only add extra hover lineWidth when there are no fill\n          if (!style.hasFill()) {\n            lineWidth = Math.max(lineWidth, this.strokeContainThreshold);\n          }\n\n          if (pathContain.containStroke(pathData, lineWidth / lineScale, x, y)) {\n            return true;\n          }\n        }\n      }\n\n      if (style.hasFill()) {\n        return pathContain.contain(pathData, x, y);\n      }\n    }\n\n    return false;\n  },\n\n  /**\n   * @param  {boolean} dirtyPath\n   */\n  dirty: function (dirtyPath) {\n    if (dirtyPath == null) {\n      dirtyPath = true;\n    } // Only mark dirty, not mark clean\n\n\n    if (dirtyPath) {\n      this.__dirtyPath = dirtyPath;\n      this._rect = null;\n    }\n\n    this.__dirty = true;\n    this.__zr && this.__zr.refresh(); // Used as a clipping path\n\n    if (this.__clipTarget) {\n      this.__clipTarget.dirty();\n    }\n  },\n\n  /**\n   * Alias for animate('shape')\n   * @param {boolean} loop\n   */\n  animateShape: function (loop) {\n    return this.animate('shape', loop);\n  },\n  // Overwrite attrKV\n  attrKV: function (key, value) {\n    // FIXME\n    if (key === 'shape') {\n      this.setShape(value);\n      this.__dirtyPath = true;\n      this._rect = null;\n    } else {\n      Displayable.prototype.attrKV.call(this, key, value);\n    }\n  },\n\n  /**\n   * @param {Object|string} key\n   * @param {*} value\n   */\n  setShape: function (key, value) {\n    var shape = this.shape; // Path from string may not have shape\n\n    if (shape) {\n      if (zrUtil.isObject(key)) {\n        for (var name in key) {\n          if (key.hasOwnProperty(name)) {\n            shape[name] = key[name];\n          }\n        }\n      } else {\n        shape[key] = value;\n      }\n\n      this.dirty(true);\n    }\n\n    return this;\n  },\n  getLineScale: function () {\n    var m = this.transform; // Get the line scale.\n    // Determinant of `m` means how much the area is enlarged by the\n    // transformation. So its square root can be used as a scale factor\n    // for width.\n\n    return m && abs(m[0] - 1) > 1e-10 && abs(m[3] - 1) > 1e-10 ? Math.sqrt(abs(m[0] * m[3] - m[2] * m[1])) : 1;\n  }\n};\n/**\n * 扩展一个 Path element, 比如星形，圆等。\n * Extend a path element\n * @param {Object} props\n * @param {string} props.type Path type\n * @param {Function} props.init Initialize\n * @param {Function} props.buildPath Overwrite buildPath method\n * @param {Object} [props.style] Extended default style config\n * @param {Object} [props.shape] Extended default shape config\n */\n\nPath.extend = function (defaults) {\n  var Sub = function (opts) {\n    Path.call(this, opts);\n\n    if (defaults.style) {\n      // Extend default style\n      this.style.extendFrom(defaults.style, false);\n    } // Extend default shape\n\n\n    var defaultShape = defaults.shape;\n\n    if (defaultShape) {\n      this.shape = this.shape || {};\n      var thisShape = this.shape;\n\n      for (var name in defaultShape) {\n        if (!thisShape.hasOwnProperty(name) && defaultShape.hasOwnProperty(name)) {\n          thisShape[name] = defaultShape[name];\n        }\n      }\n    }\n\n    defaults.init && defaults.init.call(this, opts);\n  };\n\n  zrUtil.inherits(Sub, Path); // FIXME 不能 extend position, rotation 等引用对象\n\n  for (var name in defaults) {\n    // Extending prototype values and methods\n    if (name !== 'style' && name !== 'shape') {\n      Sub.prototype[name] = defaults[name];\n    }\n  }\n\n  return Sub;\n};\n\nzrUtil.inherits(Path, Displayable);\nvar _default = Path;\nmodule.exports = _default;","map":{"version":3,"sources":["/home/martin/Escritorio/Taller de Integracion/Tarea3-TallerDeIntegracion/node_modules/react-echarts/node_modules/zrender/lib/graphic/Path.js"],"names":["Displayable","require","zrUtil","PathProxy","pathContain","Pattern","getCanvasPattern","prototype","abs","Math","pathProxyForDraw","Path","opts","call","path","constructor","type","__dirtyPath","strokeContainThreshold","brush","ctx","prevEl","style","hasStroke","hasFill","fill","stroke","hasFillGradient","colorStops","hasStrokeGradient","hasFillPattern","image","hasStrokePattern","bind","setTransform","__dirty","rect","getBoundingRect","_fillGradient","getGradient","_strokeGradient","fillStyle","strokeStyle","lineDash","lineDashOffset","ctxLineDash","setLineDash","scale","getGlobalScale","setScale","beginPath","setLineDashOffset","buildPath","shape","rebuildPath","restoreTransform","text","drawRectText","shapeCfg","inBundle","createPathProxy","_rect","needsUpdateRect","rectWithStroke","_rectWithStroke","clone","copy","w","lineWidth","lineScale","strokeNoScale","getLineScale","max","width","height","x","y","contain","localPos","transformCoordToLocal","pathData","data","containStroke","dirty","dirtyPath","__zr","refresh","__clipTarget","animateShape","loop","animate","attrKV","key","value","setShape","isObject","name","hasOwnProperty","m","transform","sqrt","extend","defaults","Sub","extendFrom","defaultShape","thisShape","init","inherits","_default","module","exports"],"mappings":"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","sourcesContent":["var Displayable = require(\"./Displayable\");\n\nvar zrUtil = require(\"../core/util\");\n\nvar PathProxy = require(\"../core/PathProxy\");\n\nvar pathContain = require(\"../contain/path\");\n\nvar Pattern = require(\"./Pattern\");\n\nvar getCanvasPattern = Pattern.prototype.getCanvasPattern;\nvar abs = Math.abs;\nvar pathProxyForDraw = new PathProxy(true);\n/**\n * @alias module:zrender/graphic/Path\n * @extends module:zrender/graphic/Displayable\n * @constructor\n * @param {Object} opts\n */\n\nfunction Path(opts) {\n  Displayable.call(this, opts);\n  /**\n   * @type {module:zrender/core/PathProxy}\n   * @readOnly\n   */\n\n  this.path = null;\n}\n\nPath.prototype = {\n  constructor: Path,\n  type: 'path',\n  __dirtyPath: true,\n  strokeContainThreshold: 5,\n  brush: function (ctx, prevEl) {\n    var style = this.style;\n    var path = this.path || pathProxyForDraw;\n    var hasStroke = style.hasStroke();\n    var hasFill = style.hasFill();\n    var fill = style.fill;\n    var stroke = style.stroke;\n    var hasFillGradient = hasFill && !!fill.colorStops;\n    var hasStrokeGradient = hasStroke && !!stroke.colorStops;\n    var hasFillPattern = hasFill && !!fill.image;\n    var hasStrokePattern = hasStroke && !!stroke.image;\n    style.bind(ctx, this, prevEl);\n    this.setTransform(ctx);\n\n    if (this.__dirty) {\n      var rect; // Update gradient because bounding rect may changed\n\n      if (hasFillGradient) {\n        rect = rect || this.getBoundingRect();\n        this._fillGradient = style.getGradient(ctx, fill, rect);\n      }\n\n      if (hasStrokeGradient) {\n        rect = rect || this.getBoundingRect();\n        this._strokeGradient = style.getGradient(ctx, stroke, rect);\n      }\n    } // Use the gradient or pattern\n\n\n    if (hasFillGradient) {\n      // PENDING If may have affect the state\n      ctx.fillStyle = this._fillGradient;\n    } else if (hasFillPattern) {\n      ctx.fillStyle = getCanvasPattern.call(fill, ctx);\n    }\n\n    if (hasStrokeGradient) {\n      ctx.strokeStyle = this._strokeGradient;\n    } else if (hasStrokePattern) {\n      ctx.strokeStyle = getCanvasPattern.call(stroke, ctx);\n    }\n\n    var lineDash = style.lineDash;\n    var lineDashOffset = style.lineDashOffset;\n    var ctxLineDash = !!ctx.setLineDash; // Update path sx, sy\n\n    var scale = this.getGlobalScale();\n    path.setScale(scale[0], scale[1]); // Proxy context\n    // Rebuild path in following 2 cases\n    // 1. Path is dirty\n    // 2. Path needs javascript implemented lineDash stroking.\n    //    In this case, lineDash information will not be saved in PathProxy\n\n    if (this.__dirtyPath || lineDash && !ctxLineDash && hasStroke) {\n      path.beginPath(ctx); // Setting line dash before build path\n\n      if (lineDash && !ctxLineDash) {\n        path.setLineDash(lineDash);\n        path.setLineDashOffset(lineDashOffset);\n      }\n\n      this.buildPath(path, this.shape, false); // Clear path dirty flag\n\n      if (this.path) {\n        this.__dirtyPath = false;\n      }\n    } else {\n      // Replay path building\n      ctx.beginPath();\n      this.path.rebuildPath(ctx);\n    }\n\n    hasFill && path.fill(ctx);\n\n    if (lineDash && ctxLineDash) {\n      ctx.setLineDash(lineDash);\n      ctx.lineDashOffset = lineDashOffset;\n    }\n\n    hasStroke && path.stroke(ctx);\n\n    if (lineDash && ctxLineDash) {\n      // PENDING\n      // Remove lineDash\n      ctx.setLineDash([]);\n    }\n\n    this.restoreTransform(ctx); // Draw rect text\n\n    if (style.text != null) {\n      this.drawRectText(ctx, this.getBoundingRect());\n    }\n  },\n  // When bundling path, some shape may decide if use moveTo to begin a new subpath or closePath\n  // Like in circle\n  buildPath: function (ctx, shapeCfg, inBundle) {},\n  createPathProxy: function () {\n    this.path = new PathProxy();\n  },\n  getBoundingRect: function () {\n    var rect = this._rect;\n    var style = this.style;\n    var needsUpdateRect = !rect;\n\n    if (needsUpdateRect) {\n      var path = this.path;\n\n      if (!path) {\n        // Create path on demand.\n        path = this.path = new PathProxy();\n      }\n\n      if (this.__dirtyPath) {\n        path.beginPath();\n        this.buildPath(path, this.shape, false);\n      }\n\n      rect = path.getBoundingRect();\n    }\n\n    this._rect = rect;\n\n    if (style.hasStroke()) {\n      // Needs update rect with stroke lineWidth when\n      // 1. Element changes scale or lineWidth\n      // 2. Shape is changed\n      var rectWithStroke = this._rectWithStroke || (this._rectWithStroke = rect.clone());\n\n      if (this.__dirty || needsUpdateRect) {\n        rectWithStroke.copy(rect); // FIXME Must after updateTransform\n\n        var w = style.lineWidth; // PENDING, Min line width is needed when line is horizontal or vertical\n\n        var lineScale = style.strokeNoScale ? this.getLineScale() : 1; // Only add extra hover lineWidth when there are no fill\n\n        if (!style.hasFill()) {\n          w = Math.max(w, this.strokeContainThreshold || 4);\n        } // Consider line width\n        // Line scale can't be 0;\n\n\n        if (lineScale > 1e-10) {\n          rectWithStroke.width += w / lineScale;\n          rectWithStroke.height += w / lineScale;\n          rectWithStroke.x -= w / lineScale / 2;\n          rectWithStroke.y -= w / lineScale / 2;\n        }\n      } // Return rect with stroke\n\n\n      return rectWithStroke;\n    }\n\n    return rect;\n  },\n  contain: function (x, y) {\n    var localPos = this.transformCoordToLocal(x, y);\n    var rect = this.getBoundingRect();\n    var style = this.style;\n    x = localPos[0];\n    y = localPos[1];\n\n    if (rect.contain(x, y)) {\n      var pathData = this.path.data;\n\n      if (style.hasStroke()) {\n        var lineWidth = style.lineWidth;\n        var lineScale = style.strokeNoScale ? this.getLineScale() : 1; // Line scale can't be 0;\n\n        if (lineScale > 1e-10) {\n          // Only add extra hover lineWidth when there are no fill\n          if (!style.hasFill()) {\n            lineWidth = Math.max(lineWidth, this.strokeContainThreshold);\n          }\n\n          if (pathContain.containStroke(pathData, lineWidth / lineScale, x, y)) {\n            return true;\n          }\n        }\n      }\n\n      if (style.hasFill()) {\n        return pathContain.contain(pathData, x, y);\n      }\n    }\n\n    return false;\n  },\n\n  /**\n   * @param  {boolean} dirtyPath\n   */\n  dirty: function (dirtyPath) {\n    if (dirtyPath == null) {\n      dirtyPath = true;\n    } // Only mark dirty, not mark clean\n\n\n    if (dirtyPath) {\n      this.__dirtyPath = dirtyPath;\n      this._rect = null;\n    }\n\n    this.__dirty = true;\n    this.__zr && this.__zr.refresh(); // Used as a clipping path\n\n    if (this.__clipTarget) {\n      this.__clipTarget.dirty();\n    }\n  },\n\n  /**\n   * Alias for animate('shape')\n   * @param {boolean} loop\n   */\n  animateShape: function (loop) {\n    return this.animate('shape', loop);\n  },\n  // Overwrite attrKV\n  attrKV: function (key, value) {\n    // FIXME\n    if (key === 'shape') {\n      this.setShape(value);\n      this.__dirtyPath = true;\n      this._rect = null;\n    } else {\n      Displayable.prototype.attrKV.call(this, key, value);\n    }\n  },\n\n  /**\n   * @param {Object|string} key\n   * @param {*} value\n   */\n  setShape: function (key, value) {\n    var shape = this.shape; // Path from string may not have shape\n\n    if (shape) {\n      if (zrUtil.isObject(key)) {\n        for (var name in key) {\n          if (key.hasOwnProperty(name)) {\n            shape[name] = key[name];\n          }\n        }\n      } else {\n        shape[key] = value;\n      }\n\n      this.dirty(true);\n    }\n\n    return this;\n  },\n  getLineScale: function () {\n    var m = this.transform; // Get the line scale.\n    // Determinant of `m` means how much the area is enlarged by the\n    // transformation. So its square root can be used as a scale factor\n    // for width.\n\n    return m && abs(m[0] - 1) > 1e-10 && abs(m[3] - 1) > 1e-10 ? Math.sqrt(abs(m[0] * m[3] - m[2] * m[1])) : 1;\n  }\n};\n/**\n * 扩展一个 Path element, 比如星形，圆等。\n * Extend a path element\n * @param {Object} props\n * @param {string} props.type Path type\n * @param {Function} props.init Initialize\n * @param {Function} props.buildPath Overwrite buildPath method\n * @param {Object} [props.style] Extended default style config\n * @param {Object} [props.shape] Extended default shape config\n */\n\nPath.extend = function (defaults) {\n  var Sub = function (opts) {\n    Path.call(this, opts);\n\n    if (defaults.style) {\n      // Extend default style\n      this.style.extendFrom(defaults.style, false);\n    } // Extend default shape\n\n\n    var defaultShape = defaults.shape;\n\n    if (defaultShape) {\n      this.shape = this.shape || {};\n      var thisShape = this.shape;\n\n      for (var name in defaultShape) {\n        if (!thisShape.hasOwnProperty(name) && defaultShape.hasOwnProperty(name)) {\n          thisShape[name] = defaultShape[name];\n        }\n      }\n    }\n\n    defaults.init && defaults.init.call(this, opts);\n  };\n\n  zrUtil.inherits(Sub, Path); // FIXME 不能 extend position, rotation 等引用对象\n\n  for (var name in defaults) {\n    // Extending prototype values and methods\n    if (name !== 'style' && name !== 'shape') {\n      Sub.prototype[name] = defaults[name];\n    }\n  }\n\n  return Sub;\n};\n\nzrUtil.inherits(Path, Displayable);\nvar _default = Path;\nmodule.exports = _default;"]},"metadata":{},"sourceType":"script"}