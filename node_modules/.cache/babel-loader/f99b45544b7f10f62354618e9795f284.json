{"ast":null,"code":"var layout = require(\"../../util/layout\");\n\nvar _number = require(\"../../util/number\");\n\nvar parsePercent = _number.parsePercent;\nvar linearMap = _number.linearMap;\n\nfunction getViewRect(seriesModel, api) {\n  return layout.getLayoutRect(seriesModel.getBoxLayoutParams(), {\n    width: api.getWidth(),\n    height: api.getHeight()\n  });\n}\n\nfunction getSortedIndices(data, sort) {\n  var valueArr = data.mapArray('value', function (val) {\n    return val;\n  });\n  var indices = [];\n  var isAscending = sort === 'ascending';\n\n  for (var i = 0, len = data.count(); i < len; i++) {\n    indices[i] = i;\n  } // Add custom sortable function & none sortable opetion by \"options.sort\"\n\n\n  if (typeof sort === 'function') {\n    indices.sort(sort);\n  } else if (sort !== 'none') {\n    indices.sort(function (a, b) {\n      return isAscending ? valueArr[a] - valueArr[b] : valueArr[b] - valueArr[a];\n    });\n  }\n\n  return indices;\n}\n\nfunction labelLayout(data) {\n  data.each(function (idx) {\n    var itemModel = data.getItemModel(idx);\n    var labelModel = itemModel.getModel('label.normal');\n    var labelPosition = labelModel.get('position');\n    var labelLineModel = itemModel.getModel('labelLine.normal');\n    var layout = data.getItemLayout(idx);\n    var points = layout.points;\n    var isLabelInside = labelPosition === 'inner' || labelPosition === 'inside' || labelPosition === 'center';\n    var textAlign;\n    var textX;\n    var textY;\n    var linePoints;\n\n    if (isLabelInside) {\n      textX = (points[0][0] + points[1][0] + points[2][0] + points[3][0]) / 4;\n      textY = (points[0][1] + points[1][1] + points[2][1] + points[3][1]) / 4;\n      textAlign = 'center';\n      linePoints = [[textX, textY], [textX, textY]];\n    } else {\n      var x1;\n      var y1;\n      var x2;\n      var labelLineLen = labelLineModel.get('length');\n\n      if (labelPosition === 'left') {\n        // Left side\n        x1 = (points[3][0] + points[0][0]) / 2;\n        y1 = (points[3][1] + points[0][1]) / 2;\n        x2 = x1 - labelLineLen;\n        textX = x2 - 5;\n        textAlign = 'right';\n      } else {\n        // Right side\n        x1 = (points[1][0] + points[2][0]) / 2;\n        y1 = (points[1][1] + points[2][1]) / 2;\n        x2 = x1 + labelLineLen;\n        textX = x2 + 5;\n        textAlign = 'left';\n      }\n\n      var y2 = y1;\n      linePoints = [[x1, y1], [x2, y2]];\n      textY = y2;\n    }\n\n    layout.label = {\n      linePoints: linePoints,\n      x: textX,\n      y: textY,\n      verticalAlign: 'middle',\n      textAlign: textAlign,\n      inside: isLabelInside\n    };\n  });\n}\n\nfunction _default(ecModel, api, payload) {\n  ecModel.eachSeriesByType('funnel', function (seriesModel) {\n    var data = seriesModel.getData();\n    var sort = seriesModel.get('sort');\n    var viewRect = getViewRect(seriesModel, api);\n    var indices = getSortedIndices(data, sort);\n    var sizeExtent = [parsePercent(seriesModel.get('minSize'), viewRect.width), parsePercent(seriesModel.get('maxSize'), viewRect.width)];\n    var dataExtent = data.getDataExtent('value');\n    var min = seriesModel.get('min');\n    var max = seriesModel.get('max');\n\n    if (min == null) {\n      min = Math.min(dataExtent[0], 0);\n    }\n\n    if (max == null) {\n      max = dataExtent[1];\n    }\n\n    var funnelAlign = seriesModel.get('funnelAlign');\n    var gap = seriesModel.get('gap');\n    var itemHeight = (viewRect.height - gap * (data.count() - 1)) / data.count();\n    var y = viewRect.y;\n\n    var getLinePoints = function (idx, offY) {\n      // End point index is data.count() and we assign it 0\n      var val = data.get('value', idx) || 0;\n      var itemWidth = linearMap(val, [min, max], sizeExtent, true);\n      var x0;\n\n      switch (funnelAlign) {\n        case 'left':\n          x0 = viewRect.x;\n          break;\n\n        case 'center':\n          x0 = viewRect.x + (viewRect.width - itemWidth) / 2;\n          break;\n\n        case 'right':\n          x0 = viewRect.x + viewRect.width - itemWidth;\n          break;\n      }\n\n      return [[x0, offY], [x0 + itemWidth, offY]];\n    };\n\n    if (sort === 'ascending') {\n      // From bottom to top\n      itemHeight = -itemHeight;\n      gap = -gap;\n      y += viewRect.height;\n      indices = indices.reverse();\n    }\n\n    for (var i = 0; i < indices.length; i++) {\n      var idx = indices[i];\n      var nextIdx = indices[i + 1];\n      var start = getLinePoints(idx, y);\n      var end = getLinePoints(nextIdx, y + itemHeight);\n      y += itemHeight + gap;\n      data.setItemLayout(idx, {\n        points: start.concat(end.slice().reverse())\n      });\n    }\n\n    labelLayout(data);\n  });\n}\n\nmodule.exports = _default;","map":{"version":3,"sources":["/home/martin/Escritorio/Taller de Integracion/Tarea3-TallerDeIntegracion/node_modules/react-echarts/node_modules/echarts/lib/chart/funnel/funnelLayout.js"],"names":["layout","require","_number","parsePercent","linearMap","getViewRect","seriesModel","api","getLayoutRect","getBoxLayoutParams","width","getWidth","height","getHeight","getSortedIndices","data","sort","valueArr","mapArray","val","indices","isAscending","i","len","count","a","b","labelLayout","each","idx","itemModel","getItemModel","labelModel","getModel","labelPosition","get","labelLineModel","getItemLayout","points","isLabelInside","textAlign","textX","textY","linePoints","x1","y1","x2","labelLineLen","y2","label","x","y","verticalAlign","inside","_default","ecModel","payload","eachSeriesByType","getData","viewRect","sizeExtent","dataExtent","getDataExtent","min","max","Math","funnelAlign","gap","itemHeight","getLinePoints","offY","itemWidth","x0","reverse","length","nextIdx","start","end","setItemLayout","concat","slice","module","exports"],"mappings":"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","sourcesContent":["var layout = require(\"../../util/layout\");\n\nvar _number = require(\"../../util/number\");\n\nvar parsePercent = _number.parsePercent;\nvar linearMap = _number.linearMap;\n\nfunction getViewRect(seriesModel, api) {\n  return layout.getLayoutRect(seriesModel.getBoxLayoutParams(), {\n    width: api.getWidth(),\n    height: api.getHeight()\n  });\n}\n\nfunction getSortedIndices(data, sort) {\n  var valueArr = data.mapArray('value', function (val) {\n    return val;\n  });\n  var indices = [];\n  var isAscending = sort === 'ascending';\n\n  for (var i = 0, len = data.count(); i < len; i++) {\n    indices[i] = i;\n  } // Add custom sortable function & none sortable opetion by \"options.sort\"\n\n\n  if (typeof sort === 'function') {\n    indices.sort(sort);\n  } else if (sort !== 'none') {\n    indices.sort(function (a, b) {\n      return isAscending ? valueArr[a] - valueArr[b] : valueArr[b] - valueArr[a];\n    });\n  }\n\n  return indices;\n}\n\nfunction labelLayout(data) {\n  data.each(function (idx) {\n    var itemModel = data.getItemModel(idx);\n    var labelModel = itemModel.getModel('label.normal');\n    var labelPosition = labelModel.get('position');\n    var labelLineModel = itemModel.getModel('labelLine.normal');\n    var layout = data.getItemLayout(idx);\n    var points = layout.points;\n    var isLabelInside = labelPosition === 'inner' || labelPosition === 'inside' || labelPosition === 'center';\n    var textAlign;\n    var textX;\n    var textY;\n    var linePoints;\n\n    if (isLabelInside) {\n      textX = (points[0][0] + points[1][0] + points[2][0] + points[3][0]) / 4;\n      textY = (points[0][1] + points[1][1] + points[2][1] + points[3][1]) / 4;\n      textAlign = 'center';\n      linePoints = [[textX, textY], [textX, textY]];\n    } else {\n      var x1;\n      var y1;\n      var x2;\n      var labelLineLen = labelLineModel.get('length');\n\n      if (labelPosition === 'left') {\n        // Left side\n        x1 = (points[3][0] + points[0][0]) / 2;\n        y1 = (points[3][1] + points[0][1]) / 2;\n        x2 = x1 - labelLineLen;\n        textX = x2 - 5;\n        textAlign = 'right';\n      } else {\n        // Right side\n        x1 = (points[1][0] + points[2][0]) / 2;\n        y1 = (points[1][1] + points[2][1]) / 2;\n        x2 = x1 + labelLineLen;\n        textX = x2 + 5;\n        textAlign = 'left';\n      }\n\n      var y2 = y1;\n      linePoints = [[x1, y1], [x2, y2]];\n      textY = y2;\n    }\n\n    layout.label = {\n      linePoints: linePoints,\n      x: textX,\n      y: textY,\n      verticalAlign: 'middle',\n      textAlign: textAlign,\n      inside: isLabelInside\n    };\n  });\n}\n\nfunction _default(ecModel, api, payload) {\n  ecModel.eachSeriesByType('funnel', function (seriesModel) {\n    var data = seriesModel.getData();\n    var sort = seriesModel.get('sort');\n    var viewRect = getViewRect(seriesModel, api);\n    var indices = getSortedIndices(data, sort);\n    var sizeExtent = [parsePercent(seriesModel.get('minSize'), viewRect.width), parsePercent(seriesModel.get('maxSize'), viewRect.width)];\n    var dataExtent = data.getDataExtent('value');\n    var min = seriesModel.get('min');\n    var max = seriesModel.get('max');\n\n    if (min == null) {\n      min = Math.min(dataExtent[0], 0);\n    }\n\n    if (max == null) {\n      max = dataExtent[1];\n    }\n\n    var funnelAlign = seriesModel.get('funnelAlign');\n    var gap = seriesModel.get('gap');\n    var itemHeight = (viewRect.height - gap * (data.count() - 1)) / data.count();\n    var y = viewRect.y;\n\n    var getLinePoints = function (idx, offY) {\n      // End point index is data.count() and we assign it 0\n      var val = data.get('value', idx) || 0;\n      var itemWidth = linearMap(val, [min, max], sizeExtent, true);\n      var x0;\n\n      switch (funnelAlign) {\n        case 'left':\n          x0 = viewRect.x;\n          break;\n\n        case 'center':\n          x0 = viewRect.x + (viewRect.width - itemWidth) / 2;\n          break;\n\n        case 'right':\n          x0 = viewRect.x + viewRect.width - itemWidth;\n          break;\n      }\n\n      return [[x0, offY], [x0 + itemWidth, offY]];\n    };\n\n    if (sort === 'ascending') {\n      // From bottom to top\n      itemHeight = -itemHeight;\n      gap = -gap;\n      y += viewRect.height;\n      indices = indices.reverse();\n    }\n\n    for (var i = 0; i < indices.length; i++) {\n      var idx = indices[i];\n      var nextIdx = indices[i + 1];\n      var start = getLinePoints(idx, y);\n      var end = getLinePoints(nextIdx, y + itemHeight);\n      y += itemHeight + gap;\n      data.setItemLayout(idx, {\n        points: start.concat(end.slice().reverse())\n      });\n    }\n\n    labelLayout(data);\n  });\n}\n\nmodule.exports = _default;"]},"metadata":{},"sourceType":"script"}