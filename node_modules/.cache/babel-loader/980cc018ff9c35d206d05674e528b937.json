{"ast":null,"code":"var _config = require(\"../config\");\n\nvar __DEV__ = _config.__DEV__;\n\nvar zrUtil = require(\"zrender/lib/core/util\");\n\nvar textContain = require(\"zrender/lib/contain/text\");\n\nvar OrdinalScale = require(\"../scale/Ordinal\");\n\nvar IntervalScale = require(\"../scale/Interval\");\n\nvar Scale = require(\"../scale/Scale\");\n\nvar numberUtil = require(\"../util/number\");\n\nrequire(\"../scale/Time\");\n\nrequire(\"../scale/Log\");\n/**\n * Get axis scale extent before niced.\n * Item of returned array can only be number (including Infinity and NaN).\n */\n\n\nfunction getScaleExtent(scale, model) {\n  var scaleType = scale.type;\n  var min = model.getMin();\n  var max = model.getMax();\n  var fixMin = min != null;\n  var fixMax = max != null;\n  var originalExtent = scale.getExtent();\n  var axisDataLen;\n  var boundaryGap;\n  var span;\n\n  if (scaleType === 'ordinal') {\n    axisDataLen = (model.get('data') || []).length;\n  } else {\n    boundaryGap = model.get('boundaryGap');\n\n    if (!zrUtil.isArray(boundaryGap)) {\n      boundaryGap = [boundaryGap || 0, boundaryGap || 0];\n    }\n\n    if (typeof boundaryGap[0] === 'boolean') {\n      boundaryGap = [0, 0];\n    }\n\n    boundaryGap[0] = numberUtil.parsePercent(boundaryGap[0], 1);\n    boundaryGap[1] = numberUtil.parsePercent(boundaryGap[1], 1);\n    span = originalExtent[1] - originalExtent[0] || Math.abs(originalExtent[0]);\n  } // Notice: When min/max is not set (that is, when there are null/undefined,\n  // which is the most common case), these cases should be ensured:\n  // (1) For 'ordinal', show all axis.data.\n  // (2) For others:\n  //      + `boundaryGap` is applied (if min/max set, boundaryGap is\n  //      disabled).\n  //      + If `needCrossZero`, min/max should be zero, otherwise, min/max should\n  //      be the result that originalExtent enlarged by boundaryGap.\n  // (3) If no data, it should be ensured that `scale.setBlank` is set.\n  // FIXME\n  // (1) When min/max is 'dataMin' or 'dataMax', should boundaryGap be able to used?\n  // (2) When `needCrossZero` and all data is positive/negative, should it be ensured\n  // that the results processed by boundaryGap are positive/negative?\n\n\n  if (min == null) {\n    min = scaleType === 'ordinal' ? axisDataLen ? 0 : NaN : originalExtent[0] - boundaryGap[0] * span;\n  }\n\n  if (max == null) {\n    max = scaleType === 'ordinal' ? axisDataLen ? axisDataLen - 1 : NaN : originalExtent[1] + boundaryGap[1] * span;\n  }\n\n  if (min === 'dataMin') {\n    min = originalExtent[0];\n  } else if (typeof min === 'function') {\n    min = min({\n      min: originalExtent[0],\n      max: originalExtent[1]\n    });\n  }\n\n  if (max === 'dataMax') {\n    max = originalExtent[1];\n  } else if (typeof max === 'function') {\n    max = max({\n      min: originalExtent[0],\n      max: originalExtent[1]\n    });\n  }\n\n  (min == null || !isFinite(min)) && (min = NaN);\n  (max == null || !isFinite(max)) && (max = NaN);\n  scale.setBlank(zrUtil.eqNaN(min) || zrUtil.eqNaN(max)); // Evaluate if axis needs cross zero\n\n  if (model.getNeedCrossZero()) {\n    // Axis is over zero and min is not set\n    if (min > 0 && max > 0 && !fixMin) {\n      min = 0;\n    } // Axis is under zero and max is not set\n\n\n    if (min < 0 && max < 0 && !fixMax) {\n      max = 0;\n    }\n  }\n\n  return [min, max];\n}\n\nfunction niceScaleExtent(scale, model) {\n  var extent = getScaleExtent(scale, model);\n  var fixMin = model.getMin() != null;\n  var fixMax = model.getMax() != null;\n  var splitNumber = model.get('splitNumber');\n\n  if (scale.type === 'log') {\n    scale.base = model.get('logBase');\n  }\n\n  var scaleType = scale.type;\n  scale.setExtent(extent[0], extent[1]);\n  scale.niceExtent({\n    splitNumber: splitNumber,\n    fixMin: fixMin,\n    fixMax: fixMax,\n    minInterval: scaleType === 'interval' || scaleType === 'time' ? model.get('minInterval') : null,\n    maxInterval: scaleType === 'interval' || scaleType === 'time' ? model.get('maxInterval') : null\n  }); // If some one specified the min, max. And the default calculated interval\n  // is not good enough. He can specify the interval. It is often appeared\n  // in angle axis with angle 0 - 360. Interval calculated in interval scale is hard\n  // to be 60.\n  // FIXME\n\n  var interval = model.get('interval');\n\n  if (interval != null) {\n    scale.setInterval && scale.setInterval(interval);\n  }\n}\n/**\n * @param {module:echarts/model/Model} model\n * @param {string} [axisType] Default retrieve from model.type\n * @return {module:echarts/scale/*}\n */\n\n\nfunction createScaleByModel(model, axisType) {\n  axisType = axisType || model.get('type');\n\n  if (axisType) {\n    switch (axisType) {\n      // Buildin scale\n      case 'category':\n        return new OrdinalScale(model.getCategories(), [Infinity, -Infinity]);\n\n      case 'value':\n        return new IntervalScale();\n      // Extended scale, like time and log\n\n      default:\n        return (Scale.getClass(axisType) || IntervalScale).create(model);\n    }\n  }\n}\n/**\n * Check if the axis corss 0\n */\n\n\nfunction ifAxisCrossZero(axis) {\n  var dataExtent = axis.scale.getExtent();\n  var min = dataExtent[0];\n  var max = dataExtent[1];\n  return !(min > 0 && max > 0 || min < 0 && max < 0);\n}\n/**\n * @param {Array.<number>} tickCoords In axis self coordinate.\n * @param {Array.<string>} labels\n * @param {string} font\n * @param {number} axisRotate 0: towards right horizontally, clock-wise is negative.\n * @param {number} [labelRotate=0] 0: towards right horizontally, clock-wise is negative.\n * @return {number}\n */\n\n\nfunction getAxisLabelInterval(tickCoords, labels, font, axisRotate, labelRotate) {\n  var textSpaceTakenRect;\n  var autoLabelInterval = 0;\n  var accumulatedLabelInterval = 0;\n  var rotation = (axisRotate - labelRotate) / 180 * Math.PI;\n  var step = 1;\n\n  if (labels.length > 40) {\n    // Simple optimization for large amount of labels\n    step = Math.floor(labels.length / 40);\n  }\n\n  for (var i = 0; i < tickCoords.length; i += step) {\n    var tickCoord = tickCoords[i]; // Not precise, do not consider align and vertical align\n    // and each distance from axis line yet.\n\n    var rect = textContain.getBoundingRect(labels[i], font, 'center', 'top');\n    rect.x += tickCoord * Math.cos(rotation);\n    rect.y += tickCoord * Math.sin(rotation); // Magic number\n\n    rect.width *= 1.3;\n    rect.height *= 1.3;\n\n    if (!textSpaceTakenRect) {\n      textSpaceTakenRect = rect.clone();\n    } // There is no space for current label;\n    else if (textSpaceTakenRect.intersect(rect)) {\n        accumulatedLabelInterval++;\n        autoLabelInterval = Math.max(autoLabelInterval, accumulatedLabelInterval);\n      } else {\n        textSpaceTakenRect.union(rect); // Reset\n\n        accumulatedLabelInterval = 0;\n      }\n  }\n\n  if (autoLabelInterval === 0 && step > 1) {\n    return step;\n  }\n\n  return (autoLabelInterval + 1) * step - 1;\n}\n/**\n * @param {Object} axis\n * @param {Function} labelFormatter\n * @return {Array.<string>}\n */\n\n\nfunction getFormattedLabels(axis, labelFormatter) {\n  var scale = axis.scale;\n  var labels = scale.getTicksLabels();\n  var ticks = scale.getTicks();\n\n  if (typeof labelFormatter === 'string') {\n    labelFormatter = function (tpl) {\n      return function (val) {\n        return tpl.replace('{value}', val != null ? val : '');\n      };\n    }(labelFormatter); // Consider empty array\n\n\n    return zrUtil.map(labels, labelFormatter);\n  } else if (typeof labelFormatter === 'function') {\n    return zrUtil.map(ticks, function (tick, idx) {\n      return labelFormatter(getAxisRawValue(axis, tick), idx);\n    }, this);\n  } else {\n    return labels;\n  }\n}\n\nfunction getAxisRawValue(axis, value) {\n  // In category axis with data zoom, tick is not the original\n  // index of axis.data. So tick should not be exposed to user\n  // in category axis.\n  return axis.type === 'category' ? axis.scale.getLabel(value) : value;\n}\n\nexports.getScaleExtent = getScaleExtent;\nexports.niceScaleExtent = niceScaleExtent;\nexports.createScaleByModel = createScaleByModel;\nexports.ifAxisCrossZero = ifAxisCrossZero;\nexports.getAxisLabelInterval = getAxisLabelInterval;\nexports.getFormattedLabels = getFormattedLabels;\nexports.getAxisRawValue = getAxisRawValue;","map":{"version":3,"sources":["/home/martin/Escritorio/Taller de Integracion/Tarea3-TallerDeIntegracion/node_modules/react-echarts/node_modules/echarts/lib/coord/axisHelper.js"],"names":["_config","require","__DEV__","zrUtil","textContain","OrdinalScale","IntervalScale","Scale","numberUtil","getScaleExtent","scale","model","scaleType","type","min","getMin","max","getMax","fixMin","fixMax","originalExtent","getExtent","axisDataLen","boundaryGap","span","get","length","isArray","parsePercent","Math","abs","NaN","isFinite","setBlank","eqNaN","getNeedCrossZero","niceScaleExtent","extent","splitNumber","base","setExtent","niceExtent","minInterval","maxInterval","interval","setInterval","createScaleByModel","axisType","getCategories","Infinity","getClass","create","ifAxisCrossZero","axis","dataExtent","getAxisLabelInterval","tickCoords","labels","font","axisRotate","labelRotate","textSpaceTakenRect","autoLabelInterval","accumulatedLabelInterval","rotation","PI","step","floor","i","tickCoord","rect","getBoundingRect","x","cos","y","sin","width","height","clone","intersect","union","getFormattedLabels","labelFormatter","getTicksLabels","ticks","getTicks","tpl","val","replace","map","tick","idx","getAxisRawValue","value","getLabel","exports"],"mappings":"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","sourcesContent":["var _config = require(\"../config\");\n\nvar __DEV__ = _config.__DEV__;\n\nvar zrUtil = require(\"zrender/lib/core/util\");\n\nvar textContain = require(\"zrender/lib/contain/text\");\n\nvar OrdinalScale = require(\"../scale/Ordinal\");\n\nvar IntervalScale = require(\"../scale/Interval\");\n\nvar Scale = require(\"../scale/Scale\");\n\nvar numberUtil = require(\"../util/number\");\n\nrequire(\"../scale/Time\");\n\nrequire(\"../scale/Log\");\n\n/**\n * Get axis scale extent before niced.\n * Item of returned array can only be number (including Infinity and NaN).\n */\nfunction getScaleExtent(scale, model) {\n  var scaleType = scale.type;\n  var min = model.getMin();\n  var max = model.getMax();\n  var fixMin = min != null;\n  var fixMax = max != null;\n  var originalExtent = scale.getExtent();\n  var axisDataLen;\n  var boundaryGap;\n  var span;\n\n  if (scaleType === 'ordinal') {\n    axisDataLen = (model.get('data') || []).length;\n  } else {\n    boundaryGap = model.get('boundaryGap');\n\n    if (!zrUtil.isArray(boundaryGap)) {\n      boundaryGap = [boundaryGap || 0, boundaryGap || 0];\n    }\n\n    if (typeof boundaryGap[0] === 'boolean') {\n      boundaryGap = [0, 0];\n    }\n\n    boundaryGap[0] = numberUtil.parsePercent(boundaryGap[0], 1);\n    boundaryGap[1] = numberUtil.parsePercent(boundaryGap[1], 1);\n    span = originalExtent[1] - originalExtent[0] || Math.abs(originalExtent[0]);\n  } // Notice: When min/max is not set (that is, when there are null/undefined,\n  // which is the most common case), these cases should be ensured:\n  // (1) For 'ordinal', show all axis.data.\n  // (2) For others:\n  //      + `boundaryGap` is applied (if min/max set, boundaryGap is\n  //      disabled).\n  //      + If `needCrossZero`, min/max should be zero, otherwise, min/max should\n  //      be the result that originalExtent enlarged by boundaryGap.\n  // (3) If no data, it should be ensured that `scale.setBlank` is set.\n  // FIXME\n  // (1) When min/max is 'dataMin' or 'dataMax', should boundaryGap be able to used?\n  // (2) When `needCrossZero` and all data is positive/negative, should it be ensured\n  // that the results processed by boundaryGap are positive/negative?\n\n\n  if (min == null) {\n    min = scaleType === 'ordinal' ? axisDataLen ? 0 : NaN : originalExtent[0] - boundaryGap[0] * span;\n  }\n\n  if (max == null) {\n    max = scaleType === 'ordinal' ? axisDataLen ? axisDataLen - 1 : NaN : originalExtent[1] + boundaryGap[1] * span;\n  }\n\n  if (min === 'dataMin') {\n    min = originalExtent[0];\n  } else if (typeof min === 'function') {\n    min = min({\n      min: originalExtent[0],\n      max: originalExtent[1]\n    });\n  }\n\n  if (max === 'dataMax') {\n    max = originalExtent[1];\n  } else if (typeof max === 'function') {\n    max = max({\n      min: originalExtent[0],\n      max: originalExtent[1]\n    });\n  }\n\n  (min == null || !isFinite(min)) && (min = NaN);\n  (max == null || !isFinite(max)) && (max = NaN);\n  scale.setBlank(zrUtil.eqNaN(min) || zrUtil.eqNaN(max)); // Evaluate if axis needs cross zero\n\n  if (model.getNeedCrossZero()) {\n    // Axis is over zero and min is not set\n    if (min > 0 && max > 0 && !fixMin) {\n      min = 0;\n    } // Axis is under zero and max is not set\n\n\n    if (min < 0 && max < 0 && !fixMax) {\n      max = 0;\n    }\n  }\n\n  return [min, max];\n}\n\nfunction niceScaleExtent(scale, model) {\n  var extent = getScaleExtent(scale, model);\n  var fixMin = model.getMin() != null;\n  var fixMax = model.getMax() != null;\n  var splitNumber = model.get('splitNumber');\n\n  if (scale.type === 'log') {\n    scale.base = model.get('logBase');\n  }\n\n  var scaleType = scale.type;\n  scale.setExtent(extent[0], extent[1]);\n  scale.niceExtent({\n    splitNumber: splitNumber,\n    fixMin: fixMin,\n    fixMax: fixMax,\n    minInterval: scaleType === 'interval' || scaleType === 'time' ? model.get('minInterval') : null,\n    maxInterval: scaleType === 'interval' || scaleType === 'time' ? model.get('maxInterval') : null\n  }); // If some one specified the min, max. And the default calculated interval\n  // is not good enough. He can specify the interval. It is often appeared\n  // in angle axis with angle 0 - 360. Interval calculated in interval scale is hard\n  // to be 60.\n  // FIXME\n\n  var interval = model.get('interval');\n\n  if (interval != null) {\n    scale.setInterval && scale.setInterval(interval);\n  }\n}\n/**\n * @param {module:echarts/model/Model} model\n * @param {string} [axisType] Default retrieve from model.type\n * @return {module:echarts/scale/*}\n */\n\n\nfunction createScaleByModel(model, axisType) {\n  axisType = axisType || model.get('type');\n\n  if (axisType) {\n    switch (axisType) {\n      // Buildin scale\n      case 'category':\n        return new OrdinalScale(model.getCategories(), [Infinity, -Infinity]);\n\n      case 'value':\n        return new IntervalScale();\n      // Extended scale, like time and log\n\n      default:\n        return (Scale.getClass(axisType) || IntervalScale).create(model);\n    }\n  }\n}\n/**\n * Check if the axis corss 0\n */\n\n\nfunction ifAxisCrossZero(axis) {\n  var dataExtent = axis.scale.getExtent();\n  var min = dataExtent[0];\n  var max = dataExtent[1];\n  return !(min > 0 && max > 0 || min < 0 && max < 0);\n}\n/**\n * @param {Array.<number>} tickCoords In axis self coordinate.\n * @param {Array.<string>} labels\n * @param {string} font\n * @param {number} axisRotate 0: towards right horizontally, clock-wise is negative.\n * @param {number} [labelRotate=0] 0: towards right horizontally, clock-wise is negative.\n * @return {number}\n */\n\n\nfunction getAxisLabelInterval(tickCoords, labels, font, axisRotate, labelRotate) {\n  var textSpaceTakenRect;\n  var autoLabelInterval = 0;\n  var accumulatedLabelInterval = 0;\n  var rotation = (axisRotate - labelRotate) / 180 * Math.PI;\n  var step = 1;\n\n  if (labels.length > 40) {\n    // Simple optimization for large amount of labels\n    step = Math.floor(labels.length / 40);\n  }\n\n  for (var i = 0; i < tickCoords.length; i += step) {\n    var tickCoord = tickCoords[i]; // Not precise, do not consider align and vertical align\n    // and each distance from axis line yet.\n\n    var rect = textContain.getBoundingRect(labels[i], font, 'center', 'top');\n    rect.x += tickCoord * Math.cos(rotation);\n    rect.y += tickCoord * Math.sin(rotation); // Magic number\n\n    rect.width *= 1.3;\n    rect.height *= 1.3;\n\n    if (!textSpaceTakenRect) {\n      textSpaceTakenRect = rect.clone();\n    } // There is no space for current label;\n    else if (textSpaceTakenRect.intersect(rect)) {\n        accumulatedLabelInterval++;\n        autoLabelInterval = Math.max(autoLabelInterval, accumulatedLabelInterval);\n      } else {\n        textSpaceTakenRect.union(rect); // Reset\n\n        accumulatedLabelInterval = 0;\n      }\n  }\n\n  if (autoLabelInterval === 0 && step > 1) {\n    return step;\n  }\n\n  return (autoLabelInterval + 1) * step - 1;\n}\n/**\n * @param {Object} axis\n * @param {Function} labelFormatter\n * @return {Array.<string>}\n */\n\n\nfunction getFormattedLabels(axis, labelFormatter) {\n  var scale = axis.scale;\n  var labels = scale.getTicksLabels();\n  var ticks = scale.getTicks();\n\n  if (typeof labelFormatter === 'string') {\n    labelFormatter = function (tpl) {\n      return function (val) {\n        return tpl.replace('{value}', val != null ? val : '');\n      };\n    }(labelFormatter); // Consider empty array\n\n\n    return zrUtil.map(labels, labelFormatter);\n  } else if (typeof labelFormatter === 'function') {\n    return zrUtil.map(ticks, function (tick, idx) {\n      return labelFormatter(getAxisRawValue(axis, tick), idx);\n    }, this);\n  } else {\n    return labels;\n  }\n}\n\nfunction getAxisRawValue(axis, value) {\n  // In category axis with data zoom, tick is not the original\n  // index of axis.data. So tick should not be exposed to user\n  // in category axis.\n  return axis.type === 'category' ? axis.scale.getLabel(value) : value;\n}\n\nexports.getScaleExtent = getScaleExtent;\nexports.niceScaleExtent = niceScaleExtent;\nexports.createScaleByModel = createScaleByModel;\nexports.ifAxisCrossZero = ifAxisCrossZero;\nexports.getAxisLabelInterval = getAxisLabelInterval;\nexports.getFormattedLabels = getFormattedLabels;\nexports.getAxisRawValue = getAxisRawValue;"]},"metadata":{},"sourceType":"script"}