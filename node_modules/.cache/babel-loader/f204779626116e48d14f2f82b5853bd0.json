{"ast":null,"code":"var _config = require(\"../../config\");\n\nvar __DEV__ = _config.__DEV__;\n\nvar zrUtil = require(\"zrender/lib/core/util\");\n\nvar BoundingRect = require(\"zrender/lib/core/BoundingRect\");\n\nvar _layout = require(\"../../util/layout\");\n\nvar getLayoutRect = _layout.getLayoutRect;\n\nvar axisHelper = require(\"../../coord/axisHelper\");\n\nvar Cartesian2D = require(\"./Cartesian2D\");\n\nvar Axis2D = require(\"./Axis2D\");\n\nvar CoordinateSystem = require(\"../../CoordinateSystem\");\n\nrequire(\"./GridModel\");\n/**\n * Grid is a region which contains at most 4 cartesian systems\n *\n * TODO Default cartesian\n */\n// Depends on GridModel, AxisModel, which performs preprocess.\n\n\nvar each = zrUtil.each;\nvar ifAxisCrossZero = axisHelper.ifAxisCrossZero;\nvar niceScaleExtent = axisHelper.niceScaleExtent;\n/**\n * Check if the axis is used in the specified grid\n * @inner\n */\n\nfunction isAxisUsedInTheGrid(axisModel, gridModel, ecModel) {\n  return axisModel.getCoordSysModel() === gridModel;\n}\n\nfunction rotateTextRect(textRect, rotate) {\n  var rotateRadians = rotate * Math.PI / 180;\n  var boundingBox = textRect.plain();\n  var beforeWidth = boundingBox.width;\n  var beforeHeight = boundingBox.height;\n  var afterWidth = beforeWidth * Math.cos(rotateRadians) + beforeHeight * Math.sin(rotateRadians);\n  var afterHeight = beforeWidth * Math.sin(rotateRadians) + beforeHeight * Math.cos(rotateRadians);\n  var rotatedRect = new BoundingRect(boundingBox.x, boundingBox.y, afterWidth, afterHeight);\n  return rotatedRect;\n}\n\nfunction getLabelUnionRect(axis) {\n  var axisModel = axis.model;\n  var labels = axisModel.getFormattedLabels();\n  var axisLabelModel = axisModel.getModel('axisLabel');\n  var rect;\n  var step = 1;\n  var labelCount = labels.length;\n\n  if (labelCount > 40) {\n    // Simple optimization for large amount of labels\n    step = Math.ceil(labelCount / 40);\n  }\n\n  for (var i = 0; i < labelCount; i += step) {\n    if (!axis.isLabelIgnored(i)) {\n      var unrotatedSingleRect = axisLabelModel.getTextRect(labels[i]);\n      var singleRect = rotateTextRect(unrotatedSingleRect, axisLabelModel.get('rotate') || 0);\n      rect ? rect.union(singleRect) : rect = singleRect;\n    }\n  }\n\n  return rect;\n}\n\nfunction Grid(gridModel, ecModel, api) {\n  /**\n   * @type {Object.<string, module:echarts/coord/cartesian/Cartesian2D>}\n   * @private\n   */\n  this._coordsMap = {};\n  /**\n   * @type {Array.<module:echarts/coord/cartesian/Cartesian>}\n   * @private\n   */\n\n  this._coordsList = [];\n  /**\n   * @type {Object.<string, module:echarts/coord/cartesian/Axis2D>}\n   * @private\n   */\n\n  this._axesMap = {};\n  /**\n   * @type {Array.<module:echarts/coord/cartesian/Axis2D>}\n   * @private\n   */\n\n  this._axesList = [];\n\n  this._initCartesian(gridModel, ecModel, api);\n\n  this.model = gridModel;\n}\n\nvar gridProto = Grid.prototype;\ngridProto.type = 'grid';\ngridProto.axisPointerEnabled = true;\n\ngridProto.getRect = function () {\n  return this._rect;\n};\n\ngridProto.update = function (ecModel, api) {\n  var axesMap = this._axesMap;\n\n  this._updateScale(ecModel, this.model);\n\n  each(axesMap.x, function (xAxis) {\n    niceScaleExtent(xAxis.scale, xAxis.model);\n  });\n  each(axesMap.y, function (yAxis) {\n    niceScaleExtent(yAxis.scale, yAxis.model);\n  });\n  each(axesMap.x, function (xAxis) {\n    fixAxisOnZero(axesMap, 'y', xAxis);\n  });\n  each(axesMap.y, function (yAxis) {\n    fixAxisOnZero(axesMap, 'x', yAxis);\n  }); // Resize again if containLabel is enabled\n  // FIXME It may cause getting wrong grid size in data processing stage\n\n  this.resize(this.model, api);\n};\n\nfunction fixAxisOnZero(axesMap, otherAxisDim, axis) {\n  // onZero can not be enabled in these two situations:\n  // 1. When any other axis is a category axis.\n  // 2. When no axis is cross 0 point.\n  var axes = axesMap[otherAxisDim];\n\n  if (!axis.onZero) {\n    return;\n  }\n\n  var onZeroAxisIndex = axis.onZeroAxisIndex; // If target axis is specified.\n\n  if (onZeroAxisIndex != null) {\n    var otherAxis = axes[onZeroAxisIndex];\n\n    if (otherAxis && canNotOnZeroToAxis(otherAxis)) {\n      axis.onZero = false;\n    }\n\n    return;\n  }\n\n  for (var idx in axes) {\n    if (axes.hasOwnProperty(idx)) {\n      var otherAxis = axes[idx];\n\n      if (otherAxis && !canNotOnZeroToAxis(otherAxis)) {\n        onZeroAxisIndex = +idx;\n        break;\n      }\n    }\n  }\n\n  if (onZeroAxisIndex == null) {\n    axis.onZero = false;\n  }\n\n  axis.onZeroAxisIndex = onZeroAxisIndex;\n}\n\nfunction canNotOnZeroToAxis(axis) {\n  return axis.type === 'category' || axis.type === 'time' || !ifAxisCrossZero(axis);\n}\n/**\n * Resize the grid\n * @param {module:echarts/coord/cartesian/GridModel} gridModel\n * @param {module:echarts/ExtensionAPI} api\n */\n\n\ngridProto.resize = function (gridModel, api, ignoreContainLabel) {\n  var gridRect = getLayoutRect(gridModel.getBoxLayoutParams(), {\n    width: api.getWidth(),\n    height: api.getHeight()\n  });\n  this._rect = gridRect;\n  var axesList = this._axesList;\n  adjustAxes(); // Minus label size\n\n  if (!ignoreContainLabel && gridModel.get('containLabel')) {\n    each(axesList, function (axis) {\n      if (!axis.model.get('axisLabel.inside')) {\n        var labelUnionRect = getLabelUnionRect(axis);\n\n        if (labelUnionRect) {\n          var dim = axis.isHorizontal() ? 'height' : 'width';\n          var margin = axis.model.get('axisLabel.margin');\n          gridRect[dim] -= labelUnionRect[dim] + margin;\n\n          if (axis.position === 'top') {\n            gridRect.y += labelUnionRect.height + margin;\n          } else if (axis.position === 'left') {\n            gridRect.x += labelUnionRect.width + margin;\n          }\n        }\n      }\n    });\n    adjustAxes();\n  }\n\n  function adjustAxes() {\n    each(axesList, function (axis) {\n      var isHorizontal = axis.isHorizontal();\n      var extent = isHorizontal ? [0, gridRect.width] : [0, gridRect.height];\n      var idx = axis.inverse ? 1 : 0;\n      axis.setExtent(extent[idx], extent[1 - idx]);\n      updateAxisTransfrom(axis, isHorizontal ? gridRect.x : gridRect.y);\n    });\n  }\n};\n/**\n * @param {string} axisType\n * @param {number} [axisIndex]\n */\n\n\ngridProto.getAxis = function (axisType, axisIndex) {\n  var axesMapOnDim = this._axesMap[axisType];\n\n  if (axesMapOnDim != null) {\n    if (axisIndex == null) {\n      // Find first axis\n      for (var name in axesMapOnDim) {\n        if (axesMapOnDim.hasOwnProperty(name)) {\n          return axesMapOnDim[name];\n        }\n      }\n    }\n\n    return axesMapOnDim[axisIndex];\n  }\n};\n/**\n * @return {Array.<module:echarts/coord/Axis>}\n */\n\n\ngridProto.getAxes = function () {\n  return this._axesList.slice();\n};\n/**\n * Usage:\n *      grid.getCartesian(xAxisIndex, yAxisIndex);\n *      grid.getCartesian(xAxisIndex);\n *      grid.getCartesian(null, yAxisIndex);\n *      grid.getCartesian({xAxisIndex: ..., yAxisIndex: ...});\n *\n * @param {number|Object} [xAxisIndex]\n * @param {number} [yAxisIndex]\n */\n\n\ngridProto.getCartesian = function (xAxisIndex, yAxisIndex) {\n  if (xAxisIndex != null && yAxisIndex != null) {\n    var key = 'x' + xAxisIndex + 'y' + yAxisIndex;\n    return this._coordsMap[key];\n  }\n\n  if (zrUtil.isObject(xAxisIndex)) {\n    yAxisIndex = xAxisIndex.yAxisIndex;\n    xAxisIndex = xAxisIndex.xAxisIndex;\n  } // When only xAxisIndex or yAxisIndex given, find its first cartesian.\n\n\n  for (var i = 0, coordList = this._coordsList; i < coordList.length; i++) {\n    if (coordList[i].getAxis('x').index === xAxisIndex || coordList[i].getAxis('y').index === yAxisIndex) {\n      return coordList[i];\n    }\n  }\n};\n\ngridProto.getCartesians = function () {\n  return this._coordsList.slice();\n};\n/**\n * @implements\n * see {module:echarts/CoodinateSystem}\n */\n\n\ngridProto.convertToPixel = function (ecModel, finder, value) {\n  var target = this._findConvertTarget(ecModel, finder);\n\n  return target.cartesian ? target.cartesian.dataToPoint(value) : target.axis ? target.axis.toGlobalCoord(target.axis.dataToCoord(value)) : null;\n};\n/**\n * @implements\n * see {module:echarts/CoodinateSystem}\n */\n\n\ngridProto.convertFromPixel = function (ecModel, finder, value) {\n  var target = this._findConvertTarget(ecModel, finder);\n\n  return target.cartesian ? target.cartesian.pointToData(value) : target.axis ? target.axis.coordToData(target.axis.toLocalCoord(value)) : null;\n};\n/**\n * @inner\n */\n\n\ngridProto._findConvertTarget = function (ecModel, finder) {\n  var seriesModel = finder.seriesModel;\n  var xAxisModel = finder.xAxisModel || seriesModel && seriesModel.getReferringComponents('xAxis')[0];\n  var yAxisModel = finder.yAxisModel || seriesModel && seriesModel.getReferringComponents('yAxis')[0];\n  var gridModel = finder.gridModel;\n  var coordsList = this._coordsList;\n  var cartesian;\n  var axis;\n\n  if (seriesModel) {\n    cartesian = seriesModel.coordinateSystem;\n    zrUtil.indexOf(coordsList, cartesian) < 0 && (cartesian = null);\n  } else if (xAxisModel && yAxisModel) {\n    cartesian = this.getCartesian(xAxisModel.componentIndex, yAxisModel.componentIndex);\n  } else if (xAxisModel) {\n    axis = this.getAxis('x', xAxisModel.componentIndex);\n  } else if (yAxisModel) {\n    axis = this.getAxis('y', yAxisModel.componentIndex);\n  } // Lowest priority.\n  else if (gridModel) {\n      var grid = gridModel.coordinateSystem;\n\n      if (grid === this) {\n        cartesian = this._coordsList[0];\n      }\n    }\n\n  return {\n    cartesian: cartesian,\n    axis: axis\n  };\n};\n/**\n * @implements\n * see {module:echarts/CoodinateSystem}\n */\n\n\ngridProto.containPoint = function (point) {\n  var coord = this._coordsList[0];\n\n  if (coord) {\n    return coord.containPoint(point);\n  }\n};\n/**\n * Initialize cartesian coordinate systems\n * @private\n */\n\n\ngridProto._initCartesian = function (gridModel, ecModel, api) {\n  var axisPositionUsed = {\n    left: false,\n    right: false,\n    top: false,\n    bottom: false\n  };\n  var axesMap = {\n    x: {},\n    y: {}\n  };\n  var axesCount = {\n    x: 0,\n    y: 0\n  }; /// Create axis\n\n  ecModel.eachComponent('xAxis', createAxisCreator('x'), this);\n  ecModel.eachComponent('yAxis', createAxisCreator('y'), this);\n\n  if (!axesCount.x || !axesCount.y) {\n    // Roll back when there no either x or y axis\n    this._axesMap = {};\n    this._axesList = [];\n    return;\n  }\n\n  this._axesMap = axesMap; /// Create cartesian2d\n\n  each(axesMap.x, function (xAxis, xAxisIndex) {\n    each(axesMap.y, function (yAxis, yAxisIndex) {\n      var key = 'x' + xAxisIndex + 'y' + yAxisIndex;\n      var cartesian = new Cartesian2D(key);\n      cartesian.grid = this;\n      cartesian.model = gridModel;\n      this._coordsMap[key] = cartesian;\n\n      this._coordsList.push(cartesian);\n\n      cartesian.addAxis(xAxis);\n      cartesian.addAxis(yAxis);\n    }, this);\n  }, this);\n\n  function createAxisCreator(axisType) {\n    return function (axisModel, idx) {\n      if (!isAxisUsedInTheGrid(axisModel, gridModel, ecModel)) {\n        return;\n      }\n\n      var axisPosition = axisModel.get('position');\n\n      if (axisType === 'x') {\n        // Fix position\n        if (axisPosition !== 'top' && axisPosition !== 'bottom') {\n          // Default bottom of X\n          axisPosition = 'bottom';\n\n          if (axisPositionUsed[axisPosition]) {\n            axisPosition = axisPosition === 'top' ? 'bottom' : 'top';\n          }\n        }\n      } else {\n        // Fix position\n        if (axisPosition !== 'left' && axisPosition !== 'right') {\n          // Default left of Y\n          axisPosition = 'left';\n\n          if (axisPositionUsed[axisPosition]) {\n            axisPosition = axisPosition === 'left' ? 'right' : 'left';\n          }\n        }\n      }\n\n      axisPositionUsed[axisPosition] = true;\n      var axis = new Axis2D(axisType, axisHelper.createScaleByModel(axisModel), [0, 0], axisModel.get('type'), axisPosition);\n      var isCategory = axis.type === 'category';\n      axis.onBand = isCategory && axisModel.get('boundaryGap');\n      axis.inverse = axisModel.get('inverse');\n      axis.onZero = axisModel.get('axisLine.onZero');\n      axis.onZeroAxisIndex = axisModel.get('axisLine.onZeroAxisIndex'); // Inject axis into axisModel\n\n      axisModel.axis = axis; // Inject axisModel into axis\n\n      axis.model = axisModel; // Inject grid info axis\n\n      axis.grid = this; // Index of axis, can be used as key\n\n      axis.index = idx;\n\n      this._axesList.push(axis);\n\n      axesMap[axisType][idx] = axis;\n      axesCount[axisType]++;\n    };\n  }\n};\n/**\n * Update cartesian properties from series\n * @param  {module:echarts/model/Option} option\n * @private\n */\n\n\ngridProto._updateScale = function (ecModel, gridModel) {\n  // Reset scale\n  zrUtil.each(this._axesList, function (axis) {\n    axis.scale.setExtent(Infinity, -Infinity);\n  });\n  ecModel.eachSeries(function (seriesModel) {\n    if (isCartesian2D(seriesModel)) {\n      var axesModels = findAxesModels(seriesModel, ecModel);\n      var xAxisModel = axesModels[0];\n      var yAxisModel = axesModels[1];\n\n      if (!isAxisUsedInTheGrid(xAxisModel, gridModel, ecModel) || !isAxisUsedInTheGrid(yAxisModel, gridModel, ecModel)) {\n        return;\n      }\n\n      var cartesian = this.getCartesian(xAxisModel.componentIndex, yAxisModel.componentIndex);\n      var data = seriesModel.getData();\n      var xAxis = cartesian.getAxis('x');\n      var yAxis = cartesian.getAxis('y');\n\n      if (data.type === 'list') {\n        unionExtent(data, xAxis, seriesModel);\n        unionExtent(data, yAxis, seriesModel);\n      }\n    }\n  }, this);\n\n  function unionExtent(data, axis, seriesModel) {\n    each(seriesModel.coordDimToDataDim(axis.dim), function (dim) {\n      axis.scale.unionExtentFromData(data, dim);\n    });\n  }\n};\n/**\n * @param {string} [dim] 'x' or 'y' or 'auto' or null/undefined\n * @return {Object} {baseAxes: [], otherAxes: []}\n */\n\n\ngridProto.getTooltipAxes = function (dim) {\n  var baseAxes = [];\n  var otherAxes = [];\n  each(this.getCartesians(), function (cartesian) {\n    var baseAxis = dim != null && dim !== 'auto' ? cartesian.getAxis(dim) : cartesian.getBaseAxis();\n    var otherAxis = cartesian.getOtherAxis(baseAxis);\n    zrUtil.indexOf(baseAxes, baseAxis) < 0 && baseAxes.push(baseAxis);\n    zrUtil.indexOf(otherAxes, otherAxis) < 0 && otherAxes.push(otherAxis);\n  });\n  return {\n    baseAxes: baseAxes,\n    otherAxes: otherAxes\n  };\n};\n/**\n * @inner\n */\n\n\nfunction updateAxisTransfrom(axis, coordBase) {\n  var axisExtent = axis.getExtent();\n  var axisExtentSum = axisExtent[0] + axisExtent[1]; // Fast transform\n\n  axis.toGlobalCoord = axis.dim === 'x' ? function (coord) {\n    return coord + coordBase;\n  } : function (coord) {\n    return axisExtentSum - coord + coordBase;\n  };\n  axis.toLocalCoord = axis.dim === 'x' ? function (coord) {\n    return coord - coordBase;\n  } : function (coord) {\n    return axisExtentSum - coord + coordBase;\n  };\n}\n\nvar axesTypes = ['xAxis', 'yAxis'];\n/**\n * @inner\n */\n\nfunction findAxesModels(seriesModel, ecModel) {\n  return zrUtil.map(axesTypes, function (axisType) {\n    var axisModel = seriesModel.getReferringComponents(axisType)[0];\n    return axisModel;\n  });\n}\n/**\n * @inner\n */\n\n\nfunction isCartesian2D(seriesModel) {\n  return seriesModel.get('coordinateSystem') === 'cartesian2d';\n}\n\nGrid.create = function (ecModel, api) {\n  var grids = [];\n  ecModel.eachComponent('grid', function (gridModel, idx) {\n    var grid = new Grid(gridModel, ecModel, api);\n    grid.name = 'grid_' + idx; // dataSampling requires axis extent, so resize\n    // should be performed in create stage.\n\n    grid.resize(gridModel, api, true);\n    gridModel.coordinateSystem = grid;\n    grids.push(grid);\n  }); // Inject the coordinateSystems into seriesModel\n\n  ecModel.eachSeries(function (seriesModel) {\n    if (!isCartesian2D(seriesModel)) {\n      return;\n    }\n\n    var axesModels = findAxesModels(seriesModel, ecModel);\n    var xAxisModel = axesModels[0];\n    var yAxisModel = axesModels[1];\n    var gridModel = xAxisModel.getCoordSysModel();\n    var grid = gridModel.coordinateSystem;\n    seriesModel.coordinateSystem = grid.getCartesian(xAxisModel.componentIndex, yAxisModel.componentIndex);\n  });\n  return grids;\n}; // For deciding which dimensions to use when creating list data\n\n\nGrid.dimensions = Grid.prototype.dimensions = Cartesian2D.prototype.dimensions;\nCoordinateSystem.register('cartesian2d', Grid);\nvar _default = Grid;\nmodule.exports = _default;","map":{"version":3,"sources":["/home/martin/Escritorio/Taller de Integracion/Tarea3-TallerDeIntegracion/node_modules/react-echarts/node_modules/echarts/lib/coord/cartesian/Grid.js"],"names":["_config","require","__DEV__","zrUtil","BoundingRect","_layout","getLayoutRect","axisHelper","Cartesian2D","Axis2D","CoordinateSystem","each","ifAxisCrossZero","niceScaleExtent","isAxisUsedInTheGrid","axisModel","gridModel","ecModel","getCoordSysModel","rotateTextRect","textRect","rotate","rotateRadians","Math","PI","boundingBox","plain","beforeWidth","width","beforeHeight","height","afterWidth","cos","sin","afterHeight","rotatedRect","x","y","getLabelUnionRect","axis","model","labels","getFormattedLabels","axisLabelModel","getModel","rect","step","labelCount","length","ceil","i","isLabelIgnored","unrotatedSingleRect","getTextRect","singleRect","get","union","Grid","api","_coordsMap","_coordsList","_axesMap","_axesList","_initCartesian","gridProto","prototype","type","axisPointerEnabled","getRect","_rect","update","axesMap","_updateScale","xAxis","scale","yAxis","fixAxisOnZero","resize","otherAxisDim","axes","onZero","onZeroAxisIndex","otherAxis","canNotOnZeroToAxis","idx","hasOwnProperty","ignoreContainLabel","gridRect","getBoxLayoutParams","getWidth","getHeight","axesList","adjustAxes","labelUnionRect","dim","isHorizontal","margin","position","extent","inverse","setExtent","updateAxisTransfrom","getAxis","axisType","axisIndex","axesMapOnDim","name","getAxes","slice","getCartesian","xAxisIndex","yAxisIndex","key","isObject","coordList","index","getCartesians","convertToPixel","finder","value","target","_findConvertTarget","cartesian","dataToPoint","toGlobalCoord","dataToCoord","convertFromPixel","pointToData","coordToData","toLocalCoord","seriesModel","xAxisModel","getReferringComponents","yAxisModel","coordsList","coordinateSystem","indexOf","componentIndex","grid","containPoint","point","coord","axisPositionUsed","left","right","top","bottom","axesCount","eachComponent","createAxisCreator","push","addAxis","axisPosition","createScaleByModel","isCategory","onBand","Infinity","eachSeries","isCartesian2D","axesModels","findAxesModels","data","getData","unionExtent","coordDimToDataDim","unionExtentFromData","getTooltipAxes","baseAxes","otherAxes","baseAxis","getBaseAxis","getOtherAxis","coordBase","axisExtent","getExtent","axisExtentSum","axesTypes","map","create","grids","dimensions","register","_default","module","exports"],"mappings":"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","sourcesContent":["var _config = require(\"../../config\");\n\nvar __DEV__ = _config.__DEV__;\n\nvar zrUtil = require(\"zrender/lib/core/util\");\n\nvar BoundingRect = require(\"zrender/lib/core/BoundingRect\");\n\nvar _layout = require(\"../../util/layout\");\n\nvar getLayoutRect = _layout.getLayoutRect;\n\nvar axisHelper = require(\"../../coord/axisHelper\");\n\nvar Cartesian2D = require(\"./Cartesian2D\");\n\nvar Axis2D = require(\"./Axis2D\");\n\nvar CoordinateSystem = require(\"../../CoordinateSystem\");\n\nrequire(\"./GridModel\");\n\n/**\n * Grid is a region which contains at most 4 cartesian systems\n *\n * TODO Default cartesian\n */\n// Depends on GridModel, AxisModel, which performs preprocess.\nvar each = zrUtil.each;\nvar ifAxisCrossZero = axisHelper.ifAxisCrossZero;\nvar niceScaleExtent = axisHelper.niceScaleExtent;\n/**\n * Check if the axis is used in the specified grid\n * @inner\n */\n\nfunction isAxisUsedInTheGrid(axisModel, gridModel, ecModel) {\n  return axisModel.getCoordSysModel() === gridModel;\n}\n\nfunction rotateTextRect(textRect, rotate) {\n  var rotateRadians = rotate * Math.PI / 180;\n  var boundingBox = textRect.plain();\n  var beforeWidth = boundingBox.width;\n  var beforeHeight = boundingBox.height;\n  var afterWidth = beforeWidth * Math.cos(rotateRadians) + beforeHeight * Math.sin(rotateRadians);\n  var afterHeight = beforeWidth * Math.sin(rotateRadians) + beforeHeight * Math.cos(rotateRadians);\n  var rotatedRect = new BoundingRect(boundingBox.x, boundingBox.y, afterWidth, afterHeight);\n  return rotatedRect;\n}\n\nfunction getLabelUnionRect(axis) {\n  var axisModel = axis.model;\n  var labels = axisModel.getFormattedLabels();\n  var axisLabelModel = axisModel.getModel('axisLabel');\n  var rect;\n  var step = 1;\n  var labelCount = labels.length;\n\n  if (labelCount > 40) {\n    // Simple optimization for large amount of labels\n    step = Math.ceil(labelCount / 40);\n  }\n\n  for (var i = 0; i < labelCount; i += step) {\n    if (!axis.isLabelIgnored(i)) {\n      var unrotatedSingleRect = axisLabelModel.getTextRect(labels[i]);\n      var singleRect = rotateTextRect(unrotatedSingleRect, axisLabelModel.get('rotate') || 0);\n      rect ? rect.union(singleRect) : rect = singleRect;\n    }\n  }\n\n  return rect;\n}\n\nfunction Grid(gridModel, ecModel, api) {\n  /**\n   * @type {Object.<string, module:echarts/coord/cartesian/Cartesian2D>}\n   * @private\n   */\n  this._coordsMap = {};\n  /**\n   * @type {Array.<module:echarts/coord/cartesian/Cartesian>}\n   * @private\n   */\n\n  this._coordsList = [];\n  /**\n   * @type {Object.<string, module:echarts/coord/cartesian/Axis2D>}\n   * @private\n   */\n\n  this._axesMap = {};\n  /**\n   * @type {Array.<module:echarts/coord/cartesian/Axis2D>}\n   * @private\n   */\n\n  this._axesList = [];\n\n  this._initCartesian(gridModel, ecModel, api);\n\n  this.model = gridModel;\n}\n\nvar gridProto = Grid.prototype;\ngridProto.type = 'grid';\ngridProto.axisPointerEnabled = true;\n\ngridProto.getRect = function () {\n  return this._rect;\n};\n\ngridProto.update = function (ecModel, api) {\n  var axesMap = this._axesMap;\n\n  this._updateScale(ecModel, this.model);\n\n  each(axesMap.x, function (xAxis) {\n    niceScaleExtent(xAxis.scale, xAxis.model);\n  });\n  each(axesMap.y, function (yAxis) {\n    niceScaleExtent(yAxis.scale, yAxis.model);\n  });\n  each(axesMap.x, function (xAxis) {\n    fixAxisOnZero(axesMap, 'y', xAxis);\n  });\n  each(axesMap.y, function (yAxis) {\n    fixAxisOnZero(axesMap, 'x', yAxis);\n  }); // Resize again if containLabel is enabled\n  // FIXME It may cause getting wrong grid size in data processing stage\n\n  this.resize(this.model, api);\n};\n\nfunction fixAxisOnZero(axesMap, otherAxisDim, axis) {\n  // onZero can not be enabled in these two situations:\n  // 1. When any other axis is a category axis.\n  // 2. When no axis is cross 0 point.\n  var axes = axesMap[otherAxisDim];\n\n  if (!axis.onZero) {\n    return;\n  }\n\n  var onZeroAxisIndex = axis.onZeroAxisIndex; // If target axis is specified.\n\n  if (onZeroAxisIndex != null) {\n    var otherAxis = axes[onZeroAxisIndex];\n\n    if (otherAxis && canNotOnZeroToAxis(otherAxis)) {\n      axis.onZero = false;\n    }\n\n    return;\n  }\n\n  for (var idx in axes) {\n    if (axes.hasOwnProperty(idx)) {\n      var otherAxis = axes[idx];\n\n      if (otherAxis && !canNotOnZeroToAxis(otherAxis)) {\n        onZeroAxisIndex = +idx;\n        break;\n      }\n    }\n  }\n\n  if (onZeroAxisIndex == null) {\n    axis.onZero = false;\n  }\n\n  axis.onZeroAxisIndex = onZeroAxisIndex;\n}\n\nfunction canNotOnZeroToAxis(axis) {\n  return axis.type === 'category' || axis.type === 'time' || !ifAxisCrossZero(axis);\n}\n/**\n * Resize the grid\n * @param {module:echarts/coord/cartesian/GridModel} gridModel\n * @param {module:echarts/ExtensionAPI} api\n */\n\n\ngridProto.resize = function (gridModel, api, ignoreContainLabel) {\n  var gridRect = getLayoutRect(gridModel.getBoxLayoutParams(), {\n    width: api.getWidth(),\n    height: api.getHeight()\n  });\n  this._rect = gridRect;\n  var axesList = this._axesList;\n  adjustAxes(); // Minus label size\n\n  if (!ignoreContainLabel && gridModel.get('containLabel')) {\n    each(axesList, function (axis) {\n      if (!axis.model.get('axisLabel.inside')) {\n        var labelUnionRect = getLabelUnionRect(axis);\n\n        if (labelUnionRect) {\n          var dim = axis.isHorizontal() ? 'height' : 'width';\n          var margin = axis.model.get('axisLabel.margin');\n          gridRect[dim] -= labelUnionRect[dim] + margin;\n\n          if (axis.position === 'top') {\n            gridRect.y += labelUnionRect.height + margin;\n          } else if (axis.position === 'left') {\n            gridRect.x += labelUnionRect.width + margin;\n          }\n        }\n      }\n    });\n    adjustAxes();\n  }\n\n  function adjustAxes() {\n    each(axesList, function (axis) {\n      var isHorizontal = axis.isHorizontal();\n      var extent = isHorizontal ? [0, gridRect.width] : [0, gridRect.height];\n      var idx = axis.inverse ? 1 : 0;\n      axis.setExtent(extent[idx], extent[1 - idx]);\n      updateAxisTransfrom(axis, isHorizontal ? gridRect.x : gridRect.y);\n    });\n  }\n};\n/**\n * @param {string} axisType\n * @param {number} [axisIndex]\n */\n\n\ngridProto.getAxis = function (axisType, axisIndex) {\n  var axesMapOnDim = this._axesMap[axisType];\n\n  if (axesMapOnDim != null) {\n    if (axisIndex == null) {\n      // Find first axis\n      for (var name in axesMapOnDim) {\n        if (axesMapOnDim.hasOwnProperty(name)) {\n          return axesMapOnDim[name];\n        }\n      }\n    }\n\n    return axesMapOnDim[axisIndex];\n  }\n};\n/**\n * @return {Array.<module:echarts/coord/Axis>}\n */\n\n\ngridProto.getAxes = function () {\n  return this._axesList.slice();\n};\n/**\n * Usage:\n *      grid.getCartesian(xAxisIndex, yAxisIndex);\n *      grid.getCartesian(xAxisIndex);\n *      grid.getCartesian(null, yAxisIndex);\n *      grid.getCartesian({xAxisIndex: ..., yAxisIndex: ...});\n *\n * @param {number|Object} [xAxisIndex]\n * @param {number} [yAxisIndex]\n */\n\n\ngridProto.getCartesian = function (xAxisIndex, yAxisIndex) {\n  if (xAxisIndex != null && yAxisIndex != null) {\n    var key = 'x' + xAxisIndex + 'y' + yAxisIndex;\n    return this._coordsMap[key];\n  }\n\n  if (zrUtil.isObject(xAxisIndex)) {\n    yAxisIndex = xAxisIndex.yAxisIndex;\n    xAxisIndex = xAxisIndex.xAxisIndex;\n  } // When only xAxisIndex or yAxisIndex given, find its first cartesian.\n\n\n  for (var i = 0, coordList = this._coordsList; i < coordList.length; i++) {\n    if (coordList[i].getAxis('x').index === xAxisIndex || coordList[i].getAxis('y').index === yAxisIndex) {\n      return coordList[i];\n    }\n  }\n};\n\ngridProto.getCartesians = function () {\n  return this._coordsList.slice();\n};\n/**\n * @implements\n * see {module:echarts/CoodinateSystem}\n */\n\n\ngridProto.convertToPixel = function (ecModel, finder, value) {\n  var target = this._findConvertTarget(ecModel, finder);\n\n  return target.cartesian ? target.cartesian.dataToPoint(value) : target.axis ? target.axis.toGlobalCoord(target.axis.dataToCoord(value)) : null;\n};\n/**\n * @implements\n * see {module:echarts/CoodinateSystem}\n */\n\n\ngridProto.convertFromPixel = function (ecModel, finder, value) {\n  var target = this._findConvertTarget(ecModel, finder);\n\n  return target.cartesian ? target.cartesian.pointToData(value) : target.axis ? target.axis.coordToData(target.axis.toLocalCoord(value)) : null;\n};\n/**\n * @inner\n */\n\n\ngridProto._findConvertTarget = function (ecModel, finder) {\n  var seriesModel = finder.seriesModel;\n  var xAxisModel = finder.xAxisModel || seriesModel && seriesModel.getReferringComponents('xAxis')[0];\n  var yAxisModel = finder.yAxisModel || seriesModel && seriesModel.getReferringComponents('yAxis')[0];\n  var gridModel = finder.gridModel;\n  var coordsList = this._coordsList;\n  var cartesian;\n  var axis;\n\n  if (seriesModel) {\n    cartesian = seriesModel.coordinateSystem;\n    zrUtil.indexOf(coordsList, cartesian) < 0 && (cartesian = null);\n  } else if (xAxisModel && yAxisModel) {\n    cartesian = this.getCartesian(xAxisModel.componentIndex, yAxisModel.componentIndex);\n  } else if (xAxisModel) {\n    axis = this.getAxis('x', xAxisModel.componentIndex);\n  } else if (yAxisModel) {\n    axis = this.getAxis('y', yAxisModel.componentIndex);\n  } // Lowest priority.\n  else if (gridModel) {\n      var grid = gridModel.coordinateSystem;\n\n      if (grid === this) {\n        cartesian = this._coordsList[0];\n      }\n    }\n\n  return {\n    cartesian: cartesian,\n    axis: axis\n  };\n};\n/**\n * @implements\n * see {module:echarts/CoodinateSystem}\n */\n\n\ngridProto.containPoint = function (point) {\n  var coord = this._coordsList[0];\n\n  if (coord) {\n    return coord.containPoint(point);\n  }\n};\n/**\n * Initialize cartesian coordinate systems\n * @private\n */\n\n\ngridProto._initCartesian = function (gridModel, ecModel, api) {\n  var axisPositionUsed = {\n    left: false,\n    right: false,\n    top: false,\n    bottom: false\n  };\n  var axesMap = {\n    x: {},\n    y: {}\n  };\n  var axesCount = {\n    x: 0,\n    y: 0\n  }; /// Create axis\n\n  ecModel.eachComponent('xAxis', createAxisCreator('x'), this);\n  ecModel.eachComponent('yAxis', createAxisCreator('y'), this);\n\n  if (!axesCount.x || !axesCount.y) {\n    // Roll back when there no either x or y axis\n    this._axesMap = {};\n    this._axesList = [];\n    return;\n  }\n\n  this._axesMap = axesMap; /// Create cartesian2d\n\n  each(axesMap.x, function (xAxis, xAxisIndex) {\n    each(axesMap.y, function (yAxis, yAxisIndex) {\n      var key = 'x' + xAxisIndex + 'y' + yAxisIndex;\n      var cartesian = new Cartesian2D(key);\n      cartesian.grid = this;\n      cartesian.model = gridModel;\n      this._coordsMap[key] = cartesian;\n\n      this._coordsList.push(cartesian);\n\n      cartesian.addAxis(xAxis);\n      cartesian.addAxis(yAxis);\n    }, this);\n  }, this);\n\n  function createAxisCreator(axisType) {\n    return function (axisModel, idx) {\n      if (!isAxisUsedInTheGrid(axisModel, gridModel, ecModel)) {\n        return;\n      }\n\n      var axisPosition = axisModel.get('position');\n\n      if (axisType === 'x') {\n        // Fix position\n        if (axisPosition !== 'top' && axisPosition !== 'bottom') {\n          // Default bottom of X\n          axisPosition = 'bottom';\n\n          if (axisPositionUsed[axisPosition]) {\n            axisPosition = axisPosition === 'top' ? 'bottom' : 'top';\n          }\n        }\n      } else {\n        // Fix position\n        if (axisPosition !== 'left' && axisPosition !== 'right') {\n          // Default left of Y\n          axisPosition = 'left';\n\n          if (axisPositionUsed[axisPosition]) {\n            axisPosition = axisPosition === 'left' ? 'right' : 'left';\n          }\n        }\n      }\n\n      axisPositionUsed[axisPosition] = true;\n      var axis = new Axis2D(axisType, axisHelper.createScaleByModel(axisModel), [0, 0], axisModel.get('type'), axisPosition);\n      var isCategory = axis.type === 'category';\n      axis.onBand = isCategory && axisModel.get('boundaryGap');\n      axis.inverse = axisModel.get('inverse');\n      axis.onZero = axisModel.get('axisLine.onZero');\n      axis.onZeroAxisIndex = axisModel.get('axisLine.onZeroAxisIndex'); // Inject axis into axisModel\n\n      axisModel.axis = axis; // Inject axisModel into axis\n\n      axis.model = axisModel; // Inject grid info axis\n\n      axis.grid = this; // Index of axis, can be used as key\n\n      axis.index = idx;\n\n      this._axesList.push(axis);\n\n      axesMap[axisType][idx] = axis;\n      axesCount[axisType]++;\n    };\n  }\n};\n/**\n * Update cartesian properties from series\n * @param  {module:echarts/model/Option} option\n * @private\n */\n\n\ngridProto._updateScale = function (ecModel, gridModel) {\n  // Reset scale\n  zrUtil.each(this._axesList, function (axis) {\n    axis.scale.setExtent(Infinity, -Infinity);\n  });\n  ecModel.eachSeries(function (seriesModel) {\n    if (isCartesian2D(seriesModel)) {\n      var axesModels = findAxesModels(seriesModel, ecModel);\n      var xAxisModel = axesModels[0];\n      var yAxisModel = axesModels[1];\n\n      if (!isAxisUsedInTheGrid(xAxisModel, gridModel, ecModel) || !isAxisUsedInTheGrid(yAxisModel, gridModel, ecModel)) {\n        return;\n      }\n\n      var cartesian = this.getCartesian(xAxisModel.componentIndex, yAxisModel.componentIndex);\n      var data = seriesModel.getData();\n      var xAxis = cartesian.getAxis('x');\n      var yAxis = cartesian.getAxis('y');\n\n      if (data.type === 'list') {\n        unionExtent(data, xAxis, seriesModel);\n        unionExtent(data, yAxis, seriesModel);\n      }\n    }\n  }, this);\n\n  function unionExtent(data, axis, seriesModel) {\n    each(seriesModel.coordDimToDataDim(axis.dim), function (dim) {\n      axis.scale.unionExtentFromData(data, dim);\n    });\n  }\n};\n/**\n * @param {string} [dim] 'x' or 'y' or 'auto' or null/undefined\n * @return {Object} {baseAxes: [], otherAxes: []}\n */\n\n\ngridProto.getTooltipAxes = function (dim) {\n  var baseAxes = [];\n  var otherAxes = [];\n  each(this.getCartesians(), function (cartesian) {\n    var baseAxis = dim != null && dim !== 'auto' ? cartesian.getAxis(dim) : cartesian.getBaseAxis();\n    var otherAxis = cartesian.getOtherAxis(baseAxis);\n    zrUtil.indexOf(baseAxes, baseAxis) < 0 && baseAxes.push(baseAxis);\n    zrUtil.indexOf(otherAxes, otherAxis) < 0 && otherAxes.push(otherAxis);\n  });\n  return {\n    baseAxes: baseAxes,\n    otherAxes: otherAxes\n  };\n};\n/**\n * @inner\n */\n\n\nfunction updateAxisTransfrom(axis, coordBase) {\n  var axisExtent = axis.getExtent();\n  var axisExtentSum = axisExtent[0] + axisExtent[1]; // Fast transform\n\n  axis.toGlobalCoord = axis.dim === 'x' ? function (coord) {\n    return coord + coordBase;\n  } : function (coord) {\n    return axisExtentSum - coord + coordBase;\n  };\n  axis.toLocalCoord = axis.dim === 'x' ? function (coord) {\n    return coord - coordBase;\n  } : function (coord) {\n    return axisExtentSum - coord + coordBase;\n  };\n}\n\nvar axesTypes = ['xAxis', 'yAxis'];\n/**\n * @inner\n */\n\nfunction findAxesModels(seriesModel, ecModel) {\n  return zrUtil.map(axesTypes, function (axisType) {\n    var axisModel = seriesModel.getReferringComponents(axisType)[0];\n    return axisModel;\n  });\n}\n/**\n * @inner\n */\n\n\nfunction isCartesian2D(seriesModel) {\n  return seriesModel.get('coordinateSystem') === 'cartesian2d';\n}\n\nGrid.create = function (ecModel, api) {\n  var grids = [];\n  ecModel.eachComponent('grid', function (gridModel, idx) {\n    var grid = new Grid(gridModel, ecModel, api);\n    grid.name = 'grid_' + idx; // dataSampling requires axis extent, so resize\n    // should be performed in create stage.\n\n    grid.resize(gridModel, api, true);\n    gridModel.coordinateSystem = grid;\n    grids.push(grid);\n  }); // Inject the coordinateSystems into seriesModel\n\n  ecModel.eachSeries(function (seriesModel) {\n    if (!isCartesian2D(seriesModel)) {\n      return;\n    }\n\n    var axesModels = findAxesModels(seriesModel, ecModel);\n    var xAxisModel = axesModels[0];\n    var yAxisModel = axesModels[1];\n    var gridModel = xAxisModel.getCoordSysModel();\n    var grid = gridModel.coordinateSystem;\n    seriesModel.coordinateSystem = grid.getCartesian(xAxisModel.componentIndex, yAxisModel.componentIndex);\n  });\n  return grids;\n}; // For deciding which dimensions to use when creating list data\n\n\nGrid.dimensions = Grid.prototype.dimensions = Cartesian2D.prototype.dimensions;\nCoordinateSystem.register('cartesian2d', Grid);\nvar _default = Grid;\nmodule.exports = _default;"]},"metadata":{},"sourceType":"script"}