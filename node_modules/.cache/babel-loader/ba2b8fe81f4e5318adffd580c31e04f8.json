{"ast":null,"code":"var zrUtil = require(\"zrender/lib/core/util\");\n\nvar numberUtil = require(\"../util/number\");\n\nvar axisHelper = require(\"./axisHelper\");\n\nvar linearMap = numberUtil.linearMap;\n\nfunction fixExtentWithBands(extent, nTick) {\n  var size = extent[1] - extent[0];\n  var len = nTick;\n  var margin = size / len / 2;\n  extent[0] += margin;\n  extent[1] -= margin;\n}\n\nvar normalizedExtent = [0, 1];\n/**\n * @name module:echarts/coord/CartesianAxis\n * @constructor\n */\n\nvar Axis = function (dim, scale, extent) {\n  /**\n   * Axis dimension. Such as 'x', 'y', 'z', 'angle', 'radius'\n   * @type {string}\n   */\n  this.dim = dim;\n  /**\n   * Axis scale\n   * @type {module:echarts/coord/scale/*}\n   */\n\n  this.scale = scale;\n  /**\n   * @type {Array.<number>}\n   * @private\n   */\n\n  this._extent = extent || [0, 0];\n  /**\n   * @type {boolean}\n   */\n\n  this.inverse = false;\n  /**\n   * Usually true when axis has a ordinal scale\n   * @type {boolean}\n   */\n\n  this.onBand = false;\n  /**\n   * @private\n   * @type {number}\n   */\n\n  this._labelInterval;\n};\n\nAxis.prototype = {\n  constructor: Axis,\n\n  /**\n   * If axis extent contain given coord\n   * @param {number} coord\n   * @return {boolean}\n   */\n  contain: function (coord) {\n    var extent = this._extent;\n    var min = Math.min(extent[0], extent[1]);\n    var max = Math.max(extent[0], extent[1]);\n    return coord >= min && coord <= max;\n  },\n\n  /**\n   * If axis extent contain given data\n   * @param {number} data\n   * @return {boolean}\n   */\n  containData: function (data) {\n    return this.contain(this.dataToCoord(data));\n  },\n\n  /**\n   * Get coord extent.\n   * @return {Array.<number>}\n   */\n  getExtent: function () {\n    return this._extent.slice();\n  },\n\n  /**\n   * Get precision used for formatting\n   * @param {Array.<number>} [dataExtent]\n   * @return {number}\n   */\n  getPixelPrecision: function (dataExtent) {\n    return numberUtil.getPixelPrecision(dataExtent || this.scale.getExtent(), this._extent);\n  },\n\n  /**\n   * Set coord extent\n   * @param {number} start\n   * @param {number} end\n   */\n  setExtent: function (start, end) {\n    var extent = this._extent;\n    extent[0] = start;\n    extent[1] = end;\n  },\n\n  /**\n   * Convert data to coord. Data is the rank if it has a ordinal scale\n   * @param {number} data\n   * @param  {boolean} clamp\n   * @return {number}\n   */\n  dataToCoord: function (data, clamp) {\n    var extent = this._extent;\n    var scale = this.scale;\n    data = scale.normalize(data);\n\n    if (this.onBand && scale.type === 'ordinal') {\n      extent = extent.slice();\n      fixExtentWithBands(extent, scale.count());\n    }\n\n    return linearMap(data, normalizedExtent, extent, clamp);\n  },\n\n  /**\n   * Convert coord to data. Data is the rank if it has a ordinal scale\n   * @param {number} coord\n   * @param  {boolean} clamp\n   * @return {number}\n   */\n  coordToData: function (coord, clamp) {\n    var extent = this._extent;\n    var scale = this.scale;\n\n    if (this.onBand && scale.type === 'ordinal') {\n      extent = extent.slice();\n      fixExtentWithBands(extent, scale.count());\n    }\n\n    var t = linearMap(coord, extent, normalizedExtent, clamp);\n    return this.scale.scale(t);\n  },\n\n  /**\n   * Convert pixel point to data in axis\n   * @param {Array.<number>} point\n   * @param  {boolean} clamp\n   * @return {number} data\n   */\n  pointToData: function (point, clamp) {// Should be implemented in derived class if necessary.\n  },\n\n  /**\n   * @return {Array.<number>}\n   */\n  getTicksCoords: function (alignWithLabel) {\n    if (this.onBand && !alignWithLabel) {\n      var bands = this.getBands();\n      var coords = [];\n\n      for (var i = 0; i < bands.length; i++) {\n        coords.push(bands[i][0]);\n      }\n\n      if (bands[i - 1]) {\n        coords.push(bands[i - 1][1]);\n      }\n\n      return coords;\n    } else {\n      return zrUtil.map(this.scale.getTicks(), this.dataToCoord, this);\n    }\n  },\n\n  /**\n   * Coords of labels are on the ticks or on the middle of bands\n   * @return {Array.<number>}\n   */\n  getLabelsCoords: function () {\n    return zrUtil.map(this.scale.getTicks(), this.dataToCoord, this);\n  },\n\n  /**\n   * Get bands.\n   *\n   * If axis has labels [1, 2, 3, 4]. Bands on the axis are\n   * |---1---|---2---|---3---|---4---|.\n   *\n   * @return {Array}\n   */\n  // FIXME Situation when labels is on ticks\n  getBands: function () {\n    var extent = this.getExtent();\n    var bands = [];\n    var len = this.scale.count();\n    var start = extent[0];\n    var end = extent[1];\n    var span = end - start;\n\n    for (var i = 0; i < len; i++) {\n      bands.push([span * i / len + start, span * (i + 1) / len + start]);\n    }\n\n    return bands;\n  },\n\n  /**\n   * Get width of band\n   * @return {number}\n   */\n  getBandWidth: function () {\n    var axisExtent = this._extent;\n    var dataExtent = this.scale.getExtent();\n    var len = dataExtent[1] - dataExtent[0] + (this.onBand ? 1 : 0); // Fix #2728, avoid NaN when only one data.\n\n    len === 0 && (len = 1);\n    var size = Math.abs(axisExtent[1] - axisExtent[0]);\n    return Math.abs(size) / len;\n  },\n\n  /**\n   * @abstract\n   * @return {boolean} Is horizontal\n   */\n  isHorizontal: null,\n\n  /**\n   * @abstract\n   * @return {number} Get axis rotate, by degree.\n   */\n  getRotate: null,\n\n  /**\n   * Get interval of the axis label.\n   * To get precise result, at least one of `getRotate` and `isHorizontal`\n   * should be implemented.\n   * @return {number}\n   */\n  getLabelInterval: function () {\n    var labelInterval = this._labelInterval;\n\n    if (!labelInterval) {\n      var axisModel = this.model;\n      var labelModel = axisModel.getModel('axisLabel');\n      labelInterval = labelModel.get('interval');\n\n      if (this.type === 'category' && (labelInterval == null || labelInterval === 'auto')) {\n        labelInterval = axisHelper.getAxisLabelInterval(zrUtil.map(this.scale.getTicks(), this.dataToCoord, this), axisModel.getFormattedLabels(), labelModel.getFont(), this.getRotate ? this.getRotate() : this.isHorizontal && !this.isHorizontal() ? 90 : 0, labelModel.get('rotate'));\n      }\n\n      this._labelInterval = labelInterval;\n    }\n\n    return labelInterval;\n  }\n};\nvar _default = Axis;\nmodule.exports = _default;","map":{"version":3,"sources":["/home/martin/Escritorio/Taller de Integracion/Tarea3-TallerDeIntegracion/node_modules/react-echarts/node_modules/echarts/lib/coord/Axis.js"],"names":["zrUtil","require","numberUtil","axisHelper","linearMap","fixExtentWithBands","extent","nTick","size","len","margin","normalizedExtent","Axis","dim","scale","_extent","inverse","onBand","_labelInterval","prototype","constructor","contain","coord","min","Math","max","containData","data","dataToCoord","getExtent","slice","getPixelPrecision","dataExtent","setExtent","start","end","clamp","normalize","type","count","coordToData","t","pointToData","point","getTicksCoords","alignWithLabel","bands","getBands","coords","i","length","push","map","getTicks","getLabelsCoords","span","getBandWidth","axisExtent","abs","isHorizontal","getRotate","getLabelInterval","labelInterval","axisModel","model","labelModel","getModel","get","getAxisLabelInterval","getFormattedLabels","getFont","_default","module","exports"],"mappings":"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","sourcesContent":["var zrUtil = require(\"zrender/lib/core/util\");\n\nvar numberUtil = require(\"../util/number\");\n\nvar axisHelper = require(\"./axisHelper\");\n\nvar linearMap = numberUtil.linearMap;\n\nfunction fixExtentWithBands(extent, nTick) {\n  var size = extent[1] - extent[0];\n  var len = nTick;\n  var margin = size / len / 2;\n  extent[0] += margin;\n  extent[1] -= margin;\n}\n\nvar normalizedExtent = [0, 1];\n/**\n * @name module:echarts/coord/CartesianAxis\n * @constructor\n */\n\nvar Axis = function (dim, scale, extent) {\n  /**\n   * Axis dimension. Such as 'x', 'y', 'z', 'angle', 'radius'\n   * @type {string}\n   */\n  this.dim = dim;\n  /**\n   * Axis scale\n   * @type {module:echarts/coord/scale/*}\n   */\n\n  this.scale = scale;\n  /**\n   * @type {Array.<number>}\n   * @private\n   */\n\n  this._extent = extent || [0, 0];\n  /**\n   * @type {boolean}\n   */\n\n  this.inverse = false;\n  /**\n   * Usually true when axis has a ordinal scale\n   * @type {boolean}\n   */\n\n  this.onBand = false;\n  /**\n   * @private\n   * @type {number}\n   */\n\n  this._labelInterval;\n};\n\nAxis.prototype = {\n  constructor: Axis,\n\n  /**\n   * If axis extent contain given coord\n   * @param {number} coord\n   * @return {boolean}\n   */\n  contain: function (coord) {\n    var extent = this._extent;\n    var min = Math.min(extent[0], extent[1]);\n    var max = Math.max(extent[0], extent[1]);\n    return coord >= min && coord <= max;\n  },\n\n  /**\n   * If axis extent contain given data\n   * @param {number} data\n   * @return {boolean}\n   */\n  containData: function (data) {\n    return this.contain(this.dataToCoord(data));\n  },\n\n  /**\n   * Get coord extent.\n   * @return {Array.<number>}\n   */\n  getExtent: function () {\n    return this._extent.slice();\n  },\n\n  /**\n   * Get precision used for formatting\n   * @param {Array.<number>} [dataExtent]\n   * @return {number}\n   */\n  getPixelPrecision: function (dataExtent) {\n    return numberUtil.getPixelPrecision(dataExtent || this.scale.getExtent(), this._extent);\n  },\n\n  /**\n   * Set coord extent\n   * @param {number} start\n   * @param {number} end\n   */\n  setExtent: function (start, end) {\n    var extent = this._extent;\n    extent[0] = start;\n    extent[1] = end;\n  },\n\n  /**\n   * Convert data to coord. Data is the rank if it has a ordinal scale\n   * @param {number} data\n   * @param  {boolean} clamp\n   * @return {number}\n   */\n  dataToCoord: function (data, clamp) {\n    var extent = this._extent;\n    var scale = this.scale;\n    data = scale.normalize(data);\n\n    if (this.onBand && scale.type === 'ordinal') {\n      extent = extent.slice();\n      fixExtentWithBands(extent, scale.count());\n    }\n\n    return linearMap(data, normalizedExtent, extent, clamp);\n  },\n\n  /**\n   * Convert coord to data. Data is the rank if it has a ordinal scale\n   * @param {number} coord\n   * @param  {boolean} clamp\n   * @return {number}\n   */\n  coordToData: function (coord, clamp) {\n    var extent = this._extent;\n    var scale = this.scale;\n\n    if (this.onBand && scale.type === 'ordinal') {\n      extent = extent.slice();\n      fixExtentWithBands(extent, scale.count());\n    }\n\n    var t = linearMap(coord, extent, normalizedExtent, clamp);\n    return this.scale.scale(t);\n  },\n\n  /**\n   * Convert pixel point to data in axis\n   * @param {Array.<number>} point\n   * @param  {boolean} clamp\n   * @return {number} data\n   */\n  pointToData: function (point, clamp) {// Should be implemented in derived class if necessary.\n  },\n\n  /**\n   * @return {Array.<number>}\n   */\n  getTicksCoords: function (alignWithLabel) {\n    if (this.onBand && !alignWithLabel) {\n      var bands = this.getBands();\n      var coords = [];\n\n      for (var i = 0; i < bands.length; i++) {\n        coords.push(bands[i][0]);\n      }\n\n      if (bands[i - 1]) {\n        coords.push(bands[i - 1][1]);\n      }\n\n      return coords;\n    } else {\n      return zrUtil.map(this.scale.getTicks(), this.dataToCoord, this);\n    }\n  },\n\n  /**\n   * Coords of labels are on the ticks or on the middle of bands\n   * @return {Array.<number>}\n   */\n  getLabelsCoords: function () {\n    return zrUtil.map(this.scale.getTicks(), this.dataToCoord, this);\n  },\n\n  /**\n   * Get bands.\n   *\n   * If axis has labels [1, 2, 3, 4]. Bands on the axis are\n   * |---1---|---2---|---3---|---4---|.\n   *\n   * @return {Array}\n   */\n  // FIXME Situation when labels is on ticks\n  getBands: function () {\n    var extent = this.getExtent();\n    var bands = [];\n    var len = this.scale.count();\n    var start = extent[0];\n    var end = extent[1];\n    var span = end - start;\n\n    for (var i = 0; i < len; i++) {\n      bands.push([span * i / len + start, span * (i + 1) / len + start]);\n    }\n\n    return bands;\n  },\n\n  /**\n   * Get width of band\n   * @return {number}\n   */\n  getBandWidth: function () {\n    var axisExtent = this._extent;\n    var dataExtent = this.scale.getExtent();\n    var len = dataExtent[1] - dataExtent[0] + (this.onBand ? 1 : 0); // Fix #2728, avoid NaN when only one data.\n\n    len === 0 && (len = 1);\n    var size = Math.abs(axisExtent[1] - axisExtent[0]);\n    return Math.abs(size) / len;\n  },\n\n  /**\n   * @abstract\n   * @return {boolean} Is horizontal\n   */\n  isHorizontal: null,\n\n  /**\n   * @abstract\n   * @return {number} Get axis rotate, by degree.\n   */\n  getRotate: null,\n\n  /**\n   * Get interval of the axis label.\n   * To get precise result, at least one of `getRotate` and `isHorizontal`\n   * should be implemented.\n   * @return {number}\n   */\n  getLabelInterval: function () {\n    var labelInterval = this._labelInterval;\n\n    if (!labelInterval) {\n      var axisModel = this.model;\n      var labelModel = axisModel.getModel('axisLabel');\n      labelInterval = labelModel.get('interval');\n\n      if (this.type === 'category' && (labelInterval == null || labelInterval === 'auto')) {\n        labelInterval = axisHelper.getAxisLabelInterval(zrUtil.map(this.scale.getTicks(), this.dataToCoord, this), axisModel.getFormattedLabels(), labelModel.getFont(), this.getRotate ? this.getRotate() : this.isHorizontal && !this.isHorizontal() ? 90 : 0, labelModel.get('rotate'));\n      }\n\n      this._labelInterval = labelInterval;\n    }\n\n    return labelInterval;\n  }\n};\nvar _default = Axis;\nmodule.exports = _default;"]},"metadata":{},"sourceType":"script"}