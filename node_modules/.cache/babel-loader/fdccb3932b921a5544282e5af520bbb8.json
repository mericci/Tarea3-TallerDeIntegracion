{"ast":null,"code":"// var arrayDiff = require('zrender/src/core/arrayDiff');\n// 'zrender/src/core/arrayDiff' has been used before, but it did\n// not do well in performance when roam with fixed dataZoom window.\nfunction sign(val) {\n  return val >= 0 ? 1 : -1;\n}\n\nfunction getStackedOnPoint(coordSys, data, idx) {\n  var baseAxis = coordSys.getBaseAxis();\n  var valueAxis = coordSys.getOtherAxis(baseAxis);\n  var valueStart = baseAxis.onZero ? 0 : valueAxis.scale.getExtent()[0];\n  var valueDim = valueAxis.dim;\n  var baseDataOffset = valueDim === 'x' || valueDim === 'radius' ? 1 : 0;\n  var stackedOnSameSign;\n  var stackedOn = data.stackedOn;\n  var val = data.get(valueDim, idx); // Find first stacked value with same sign\n\n  while (stackedOn && sign(stackedOn.get(valueDim, idx)) === sign(val)) {\n    stackedOnSameSign = stackedOn;\n    break;\n  }\n\n  var stackedData = [];\n  stackedData[baseDataOffset] = data.get(baseAxis.dim, idx);\n  stackedData[1 - baseDataOffset] = stackedOnSameSign ? stackedOnSameSign.get(valueDim, idx, true) : valueStart;\n  return coordSys.dataToPoint(stackedData);\n} // function convertToIntId(newIdList, oldIdList) {\n//     // Generate int id instead of string id.\n//     // Compare string maybe slow in score function of arrDiff\n//     // Assume id in idList are all unique\n//     var idIndicesMap = {};\n//     var idx = 0;\n//     for (var i = 0; i < newIdList.length; i++) {\n//         idIndicesMap[newIdList[i]] = idx;\n//         newIdList[i] = idx++;\n//     }\n//     for (var i = 0; i < oldIdList.length; i++) {\n//         var oldId = oldIdList[i];\n//         // Same with newIdList\n//         if (idIndicesMap[oldId]) {\n//             oldIdList[i] = idIndicesMap[oldId];\n//         }\n//         else {\n//             oldIdList[i] = idx++;\n//         }\n//     }\n// }\n\n\nfunction diffData(oldData, newData) {\n  var diffResult = [];\n  newData.diff(oldData).add(function (idx) {\n    diffResult.push({\n      cmd: '+',\n      idx: idx\n    });\n  }).update(function (newIdx, oldIdx) {\n    diffResult.push({\n      cmd: '=',\n      idx: oldIdx,\n      idx1: newIdx\n    });\n  }).remove(function (idx) {\n    diffResult.push({\n      cmd: '-',\n      idx: idx\n    });\n  }).execute();\n  return diffResult;\n}\n\nfunction _default(oldData, newData, oldStackedOnPoints, newStackedOnPoints, oldCoordSys, newCoordSys) {\n  var diff = diffData(oldData, newData); // var newIdList = newData.mapArray(newData.getId);\n  // var oldIdList = oldData.mapArray(oldData.getId);\n  // convertToIntId(newIdList, oldIdList);\n  // // FIXME One data ?\n  // diff = arrayDiff(oldIdList, newIdList);\n\n  var currPoints = [];\n  var nextPoints = []; // Points for stacking base line\n\n  var currStackedPoints = [];\n  var nextStackedPoints = [];\n  var status = [];\n  var sortedIndices = [];\n  var rawIndices = [];\n  var dims = newCoordSys.dimensions;\n\n  for (var i = 0; i < diff.length; i++) {\n    var diffItem = diff[i];\n    var pointAdded = true; // FIXME, animation is not so perfect when dataZoom window moves fast\n    // Which is in case remvoing or add more than one data in the tail or head\n\n    switch (diffItem.cmd) {\n      case '=':\n        var currentPt = oldData.getItemLayout(diffItem.idx);\n        var nextPt = newData.getItemLayout(diffItem.idx1); // If previous data is NaN, use next point directly\n\n        if (isNaN(currentPt[0]) || isNaN(currentPt[1])) {\n          currentPt = nextPt.slice();\n        }\n\n        currPoints.push(currentPt);\n        nextPoints.push(nextPt);\n        currStackedPoints.push(oldStackedOnPoints[diffItem.idx]);\n        nextStackedPoints.push(newStackedOnPoints[diffItem.idx1]);\n        rawIndices.push(newData.getRawIndex(diffItem.idx1));\n        break;\n\n      case '+':\n        var idx = diffItem.idx;\n        currPoints.push(oldCoordSys.dataToPoint([newData.get(dims[0], idx, true), newData.get(dims[1], idx, true)]));\n        nextPoints.push(newData.getItemLayout(idx).slice());\n        currStackedPoints.push(getStackedOnPoint(oldCoordSys, newData, idx));\n        nextStackedPoints.push(newStackedOnPoints[idx]);\n        rawIndices.push(newData.getRawIndex(idx));\n        break;\n\n      case '-':\n        var idx = diffItem.idx;\n        var rawIndex = oldData.getRawIndex(idx); // Data is replaced. In the case of dynamic data queue\n        // FIXME FIXME FIXME\n\n        if (rawIndex !== idx) {\n          currPoints.push(oldData.getItemLayout(idx));\n          nextPoints.push(newCoordSys.dataToPoint([oldData.get(dims[0], idx, true), oldData.get(dims[1], idx, true)]));\n          currStackedPoints.push(oldStackedOnPoints[idx]);\n          nextStackedPoints.push(getStackedOnPoint(newCoordSys, oldData, idx));\n          rawIndices.push(rawIndex);\n        } else {\n          pointAdded = false;\n        }\n\n    } // Original indices\n\n\n    if (pointAdded) {\n      status.push(diffItem);\n      sortedIndices.push(sortedIndices.length);\n    }\n  } // Diff result may be crossed if all items are changed\n  // Sort by data index\n\n\n  sortedIndices.sort(function (a, b) {\n    return rawIndices[a] - rawIndices[b];\n  });\n  var sortedCurrPoints = [];\n  var sortedNextPoints = [];\n  var sortedCurrStackedPoints = [];\n  var sortedNextStackedPoints = [];\n  var sortedStatus = [];\n\n  for (var i = 0; i < sortedIndices.length; i++) {\n    var idx = sortedIndices[i];\n    sortedCurrPoints[i] = currPoints[idx];\n    sortedNextPoints[i] = nextPoints[idx];\n    sortedCurrStackedPoints[i] = currStackedPoints[idx];\n    sortedNextStackedPoints[i] = nextStackedPoints[idx];\n    sortedStatus[i] = status[idx];\n  }\n\n  return {\n    current: sortedCurrPoints,\n    next: sortedNextPoints,\n    stackedOnCurrent: sortedCurrStackedPoints,\n    stackedOnNext: sortedNextStackedPoints,\n    status: sortedStatus\n  };\n}\n\nmodule.exports = _default;","map":{"version":3,"sources":["/home/martin/Escritorio/Taller de Integracion/Tarea3-TallerDeIntegracion/node_modules/react-echarts/node_modules/echarts/lib/chart/line/lineAnimationDiff.js"],"names":["sign","val","getStackedOnPoint","coordSys","data","idx","baseAxis","getBaseAxis","valueAxis","getOtherAxis","valueStart","onZero","scale","getExtent","valueDim","dim","baseDataOffset","stackedOnSameSign","stackedOn","get","stackedData","dataToPoint","diffData","oldData","newData","diffResult","diff","add","push","cmd","update","newIdx","oldIdx","idx1","remove","execute","_default","oldStackedOnPoints","newStackedOnPoints","oldCoordSys","newCoordSys","currPoints","nextPoints","currStackedPoints","nextStackedPoints","status","sortedIndices","rawIndices","dims","dimensions","i","length","diffItem","pointAdded","currentPt","getItemLayout","nextPt","isNaN","slice","getRawIndex","rawIndex","sort","a","b","sortedCurrPoints","sortedNextPoints","sortedCurrStackedPoints","sortedNextStackedPoints","sortedStatus","current","next","stackedOnCurrent","stackedOnNext","module","exports"],"mappings":"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","sourcesContent":["// var arrayDiff = require('zrender/src/core/arrayDiff');\n// 'zrender/src/core/arrayDiff' has been used before, but it did\n// not do well in performance when roam with fixed dataZoom window.\nfunction sign(val) {\n  return val >= 0 ? 1 : -1;\n}\n\nfunction getStackedOnPoint(coordSys, data, idx) {\n  var baseAxis = coordSys.getBaseAxis();\n  var valueAxis = coordSys.getOtherAxis(baseAxis);\n  var valueStart = baseAxis.onZero ? 0 : valueAxis.scale.getExtent()[0];\n  var valueDim = valueAxis.dim;\n  var baseDataOffset = valueDim === 'x' || valueDim === 'radius' ? 1 : 0;\n  var stackedOnSameSign;\n  var stackedOn = data.stackedOn;\n  var val = data.get(valueDim, idx); // Find first stacked value with same sign\n\n  while (stackedOn && sign(stackedOn.get(valueDim, idx)) === sign(val)) {\n    stackedOnSameSign = stackedOn;\n    break;\n  }\n\n  var stackedData = [];\n  stackedData[baseDataOffset] = data.get(baseAxis.dim, idx);\n  stackedData[1 - baseDataOffset] = stackedOnSameSign ? stackedOnSameSign.get(valueDim, idx, true) : valueStart;\n  return coordSys.dataToPoint(stackedData);\n} // function convertToIntId(newIdList, oldIdList) {\n//     // Generate int id instead of string id.\n//     // Compare string maybe slow in score function of arrDiff\n//     // Assume id in idList are all unique\n//     var idIndicesMap = {};\n//     var idx = 0;\n//     for (var i = 0; i < newIdList.length; i++) {\n//         idIndicesMap[newIdList[i]] = idx;\n//         newIdList[i] = idx++;\n//     }\n//     for (var i = 0; i < oldIdList.length; i++) {\n//         var oldId = oldIdList[i];\n//         // Same with newIdList\n//         if (idIndicesMap[oldId]) {\n//             oldIdList[i] = idIndicesMap[oldId];\n//         }\n//         else {\n//             oldIdList[i] = idx++;\n//         }\n//     }\n// }\n\n\nfunction diffData(oldData, newData) {\n  var diffResult = [];\n  newData.diff(oldData).add(function (idx) {\n    diffResult.push({\n      cmd: '+',\n      idx: idx\n    });\n  }).update(function (newIdx, oldIdx) {\n    diffResult.push({\n      cmd: '=',\n      idx: oldIdx,\n      idx1: newIdx\n    });\n  }).remove(function (idx) {\n    diffResult.push({\n      cmd: '-',\n      idx: idx\n    });\n  }).execute();\n  return diffResult;\n}\n\nfunction _default(oldData, newData, oldStackedOnPoints, newStackedOnPoints, oldCoordSys, newCoordSys) {\n  var diff = diffData(oldData, newData); // var newIdList = newData.mapArray(newData.getId);\n  // var oldIdList = oldData.mapArray(oldData.getId);\n  // convertToIntId(newIdList, oldIdList);\n  // // FIXME One data ?\n  // diff = arrayDiff(oldIdList, newIdList);\n\n  var currPoints = [];\n  var nextPoints = []; // Points for stacking base line\n\n  var currStackedPoints = [];\n  var nextStackedPoints = [];\n  var status = [];\n  var sortedIndices = [];\n  var rawIndices = [];\n  var dims = newCoordSys.dimensions;\n\n  for (var i = 0; i < diff.length; i++) {\n    var diffItem = diff[i];\n    var pointAdded = true; // FIXME, animation is not so perfect when dataZoom window moves fast\n    // Which is in case remvoing or add more than one data in the tail or head\n\n    switch (diffItem.cmd) {\n      case '=':\n        var currentPt = oldData.getItemLayout(diffItem.idx);\n        var nextPt = newData.getItemLayout(diffItem.idx1); // If previous data is NaN, use next point directly\n\n        if (isNaN(currentPt[0]) || isNaN(currentPt[1])) {\n          currentPt = nextPt.slice();\n        }\n\n        currPoints.push(currentPt);\n        nextPoints.push(nextPt);\n        currStackedPoints.push(oldStackedOnPoints[diffItem.idx]);\n        nextStackedPoints.push(newStackedOnPoints[diffItem.idx1]);\n        rawIndices.push(newData.getRawIndex(diffItem.idx1));\n        break;\n\n      case '+':\n        var idx = diffItem.idx;\n        currPoints.push(oldCoordSys.dataToPoint([newData.get(dims[0], idx, true), newData.get(dims[1], idx, true)]));\n        nextPoints.push(newData.getItemLayout(idx).slice());\n        currStackedPoints.push(getStackedOnPoint(oldCoordSys, newData, idx));\n        nextStackedPoints.push(newStackedOnPoints[idx]);\n        rawIndices.push(newData.getRawIndex(idx));\n        break;\n\n      case '-':\n        var idx = diffItem.idx;\n        var rawIndex = oldData.getRawIndex(idx); // Data is replaced. In the case of dynamic data queue\n        // FIXME FIXME FIXME\n\n        if (rawIndex !== idx) {\n          currPoints.push(oldData.getItemLayout(idx));\n          nextPoints.push(newCoordSys.dataToPoint([oldData.get(dims[0], idx, true), oldData.get(dims[1], idx, true)]));\n          currStackedPoints.push(oldStackedOnPoints[idx]);\n          nextStackedPoints.push(getStackedOnPoint(newCoordSys, oldData, idx));\n          rawIndices.push(rawIndex);\n        } else {\n          pointAdded = false;\n        }\n\n    } // Original indices\n\n\n    if (pointAdded) {\n      status.push(diffItem);\n      sortedIndices.push(sortedIndices.length);\n    }\n  } // Diff result may be crossed if all items are changed\n  // Sort by data index\n\n\n  sortedIndices.sort(function (a, b) {\n    return rawIndices[a] - rawIndices[b];\n  });\n  var sortedCurrPoints = [];\n  var sortedNextPoints = [];\n  var sortedCurrStackedPoints = [];\n  var sortedNextStackedPoints = [];\n  var sortedStatus = [];\n\n  for (var i = 0; i < sortedIndices.length; i++) {\n    var idx = sortedIndices[i];\n    sortedCurrPoints[i] = currPoints[idx];\n    sortedNextPoints[i] = nextPoints[idx];\n    sortedCurrStackedPoints[i] = currStackedPoints[idx];\n    sortedNextStackedPoints[i] = nextStackedPoints[idx];\n    sortedStatus[i] = status[idx];\n  }\n\n  return {\n    current: sortedCurrPoints,\n    next: sortedNextPoints,\n    stackedOnCurrent: sortedCurrStackedPoints,\n    stackedOnNext: sortedNextStackedPoints,\n    status: sortedStatus\n  };\n}\n\nmodule.exports = _default;"]},"metadata":{},"sourceType":"script"}