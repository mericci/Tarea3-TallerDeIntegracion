{"ast":null,"code":"var zrUtil = require(\"zrender/lib/core/util\");\n\nvar Scale = require(\"./Scale\");\n\nvar numberUtil = require(\"../util/number\");\n\nvar IntervalScale = require(\"./Interval\");\n/**\n * Log scale\n * @module echarts/scale/Log\n */\n// Use some method of IntervalScale\n\n\nvar scaleProto = Scale.prototype;\nvar intervalScaleProto = IntervalScale.prototype;\nvar getPrecisionSafe = numberUtil.getPrecisionSafe;\nvar roundingErrorFix = numberUtil.round;\nvar mathFloor = Math.floor;\nvar mathCeil = Math.ceil;\nvar mathPow = Math.pow;\nvar mathLog = Math.log;\nvar LogScale = Scale.extend({\n  type: 'log',\n  base: 10,\n  $constructor: function () {\n    Scale.apply(this, arguments);\n    this._originalScale = new IntervalScale();\n  },\n\n  /**\n   * @return {Array.<number>}\n   */\n  getTicks: function () {\n    var originalScale = this._originalScale;\n    var extent = this._extent;\n    var originalExtent = originalScale.getExtent();\n    return zrUtil.map(intervalScaleProto.getTicks.call(this), function (val) {\n      var powVal = numberUtil.round(mathPow(this.base, val)); // Fix #4158\n\n      powVal = val === extent[0] && originalScale.__fixMin ? fixRoundingError(powVal, originalExtent[0]) : powVal;\n      powVal = val === extent[1] && originalScale.__fixMax ? fixRoundingError(powVal, originalExtent[1]) : powVal;\n      return powVal;\n    }, this);\n  },\n\n  /**\n   * @param {number} val\n   * @return {string}\n   */\n  getLabel: intervalScaleProto.getLabel,\n\n  /**\n   * @param  {number} val\n   * @return {number}\n   */\n  scale: function (val) {\n    val = scaleProto.scale.call(this, val);\n    return mathPow(this.base, val);\n  },\n\n  /**\n   * @param {number} start\n   * @param {number} end\n   */\n  setExtent: function (start, end) {\n    var base = this.base;\n    start = mathLog(start) / mathLog(base);\n    end = mathLog(end) / mathLog(base);\n    intervalScaleProto.setExtent.call(this, start, end);\n  },\n\n  /**\n   * @return {number} end\n   */\n  getExtent: function () {\n    var base = this.base;\n    var extent = scaleProto.getExtent.call(this);\n    extent[0] = mathPow(base, extent[0]);\n    extent[1] = mathPow(base, extent[1]); // Fix #4158\n\n    var originalScale = this._originalScale;\n    var originalExtent = originalScale.getExtent();\n    originalScale.__fixMin && (extent[0] = fixRoundingError(extent[0], originalExtent[0]));\n    originalScale.__fixMax && (extent[1] = fixRoundingError(extent[1], originalExtent[1]));\n    return extent;\n  },\n\n  /**\n   * @param  {Array.<number>} extent\n   */\n  unionExtent: function (extent) {\n    this._originalScale.unionExtent(extent);\n\n    var base = this.base;\n    extent[0] = mathLog(extent[0]) / mathLog(base);\n    extent[1] = mathLog(extent[1]) / mathLog(base);\n    scaleProto.unionExtent.call(this, extent);\n  },\n\n  /**\n   * @override\n   */\n  unionExtentFromData: function (data, dim) {\n    this.unionExtent(data.getDataExtent(dim, true, function (val) {\n      return val > 0;\n    }));\n  },\n\n  /**\n   * Update interval and extent of intervals for nice ticks\n   * @param  {number} [approxTickNum = 10] Given approx tick number\n   */\n  niceTicks: function (approxTickNum) {\n    approxTickNum = approxTickNum || 10;\n    var extent = this._extent;\n    var span = extent[1] - extent[0];\n\n    if (span === Infinity || span <= 0) {\n      return;\n    }\n\n    var interval = numberUtil.quantity(span);\n    var err = approxTickNum / span * interval; // Filter ticks to get closer to the desired count.\n\n    if (err <= 0.5) {\n      interval *= 10;\n    } // Interval should be integer\n\n\n    while (!isNaN(interval) && Math.abs(interval) < 1 && Math.abs(interval) > 0) {\n      interval *= 10;\n    }\n\n    var niceExtent = [numberUtil.round(mathCeil(extent[0] / interval) * interval), numberUtil.round(mathFloor(extent[1] / interval) * interval)];\n    this._interval = interval;\n    this._niceExtent = niceExtent;\n  },\n\n  /**\n   * Nice extent.\n   * @override\n   */\n  niceExtent: function (opt) {\n    intervalScaleProto.niceExtent.call(this, opt);\n    var originalScale = this._originalScale;\n    originalScale.__fixMin = opt.fixMin;\n    originalScale.__fixMax = opt.fixMax;\n  }\n});\nzrUtil.each(['contain', 'normalize'], function (methodName) {\n  LogScale.prototype[methodName] = function (val) {\n    val = mathLog(val) / mathLog(this.base);\n    return scaleProto[methodName].call(this, val);\n  };\n});\n\nLogScale.create = function () {\n  return new LogScale();\n};\n\nfunction fixRoundingError(val, originalVal) {\n  return roundingErrorFix(val, getPrecisionSafe(originalVal));\n}\n\nvar _default = LogScale;\nmodule.exports = _default;","map":{"version":3,"sources":["/home/martin/Escritorio/Taller de Integracion/Tarea3-TallerDeIntegracion/node_modules/react-echarts/node_modules/echarts/lib/scale/Log.js"],"names":["zrUtil","require","Scale","numberUtil","IntervalScale","scaleProto","prototype","intervalScaleProto","getPrecisionSafe","roundingErrorFix","round","mathFloor","Math","floor","mathCeil","ceil","mathPow","pow","mathLog","log","LogScale","extend","type","base","$constructor","apply","arguments","_originalScale","getTicks","originalScale","extent","_extent","originalExtent","getExtent","map","call","val","powVal","__fixMin","fixRoundingError","__fixMax","getLabel","scale","setExtent","start","end","unionExtent","unionExtentFromData","data","dim","getDataExtent","niceTicks","approxTickNum","span","Infinity","interval","quantity","err","isNaN","abs","niceExtent","_interval","_niceExtent","opt","fixMin","fixMax","each","methodName","create","originalVal","_default","module","exports"],"mappings":"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","sourcesContent":["var zrUtil = require(\"zrender/lib/core/util\");\n\nvar Scale = require(\"./Scale\");\n\nvar numberUtil = require(\"../util/number\");\n\nvar IntervalScale = require(\"./Interval\");\n\n/**\n * Log scale\n * @module echarts/scale/Log\n */\n// Use some method of IntervalScale\nvar scaleProto = Scale.prototype;\nvar intervalScaleProto = IntervalScale.prototype;\nvar getPrecisionSafe = numberUtil.getPrecisionSafe;\nvar roundingErrorFix = numberUtil.round;\nvar mathFloor = Math.floor;\nvar mathCeil = Math.ceil;\nvar mathPow = Math.pow;\nvar mathLog = Math.log;\nvar LogScale = Scale.extend({\n  type: 'log',\n  base: 10,\n  $constructor: function () {\n    Scale.apply(this, arguments);\n    this._originalScale = new IntervalScale();\n  },\n\n  /**\n   * @return {Array.<number>}\n   */\n  getTicks: function () {\n    var originalScale = this._originalScale;\n    var extent = this._extent;\n    var originalExtent = originalScale.getExtent();\n    return zrUtil.map(intervalScaleProto.getTicks.call(this), function (val) {\n      var powVal = numberUtil.round(mathPow(this.base, val)); // Fix #4158\n\n      powVal = val === extent[0] && originalScale.__fixMin ? fixRoundingError(powVal, originalExtent[0]) : powVal;\n      powVal = val === extent[1] && originalScale.__fixMax ? fixRoundingError(powVal, originalExtent[1]) : powVal;\n      return powVal;\n    }, this);\n  },\n\n  /**\n   * @param {number} val\n   * @return {string}\n   */\n  getLabel: intervalScaleProto.getLabel,\n\n  /**\n   * @param  {number} val\n   * @return {number}\n   */\n  scale: function (val) {\n    val = scaleProto.scale.call(this, val);\n    return mathPow(this.base, val);\n  },\n\n  /**\n   * @param {number} start\n   * @param {number} end\n   */\n  setExtent: function (start, end) {\n    var base = this.base;\n    start = mathLog(start) / mathLog(base);\n    end = mathLog(end) / mathLog(base);\n    intervalScaleProto.setExtent.call(this, start, end);\n  },\n\n  /**\n   * @return {number} end\n   */\n  getExtent: function () {\n    var base = this.base;\n    var extent = scaleProto.getExtent.call(this);\n    extent[0] = mathPow(base, extent[0]);\n    extent[1] = mathPow(base, extent[1]); // Fix #4158\n\n    var originalScale = this._originalScale;\n    var originalExtent = originalScale.getExtent();\n    originalScale.__fixMin && (extent[0] = fixRoundingError(extent[0], originalExtent[0]));\n    originalScale.__fixMax && (extent[1] = fixRoundingError(extent[1], originalExtent[1]));\n    return extent;\n  },\n\n  /**\n   * @param  {Array.<number>} extent\n   */\n  unionExtent: function (extent) {\n    this._originalScale.unionExtent(extent);\n\n    var base = this.base;\n    extent[0] = mathLog(extent[0]) / mathLog(base);\n    extent[1] = mathLog(extent[1]) / mathLog(base);\n    scaleProto.unionExtent.call(this, extent);\n  },\n\n  /**\n   * @override\n   */\n  unionExtentFromData: function (data, dim) {\n    this.unionExtent(data.getDataExtent(dim, true, function (val) {\n      return val > 0;\n    }));\n  },\n\n  /**\n   * Update interval and extent of intervals for nice ticks\n   * @param  {number} [approxTickNum = 10] Given approx tick number\n   */\n  niceTicks: function (approxTickNum) {\n    approxTickNum = approxTickNum || 10;\n    var extent = this._extent;\n    var span = extent[1] - extent[0];\n\n    if (span === Infinity || span <= 0) {\n      return;\n    }\n\n    var interval = numberUtil.quantity(span);\n    var err = approxTickNum / span * interval; // Filter ticks to get closer to the desired count.\n\n    if (err <= 0.5) {\n      interval *= 10;\n    } // Interval should be integer\n\n\n    while (!isNaN(interval) && Math.abs(interval) < 1 && Math.abs(interval) > 0) {\n      interval *= 10;\n    }\n\n    var niceExtent = [numberUtil.round(mathCeil(extent[0] / interval) * interval), numberUtil.round(mathFloor(extent[1] / interval) * interval)];\n    this._interval = interval;\n    this._niceExtent = niceExtent;\n  },\n\n  /**\n   * Nice extent.\n   * @override\n   */\n  niceExtent: function (opt) {\n    intervalScaleProto.niceExtent.call(this, opt);\n    var originalScale = this._originalScale;\n    originalScale.__fixMin = opt.fixMin;\n    originalScale.__fixMax = opt.fixMax;\n  }\n});\nzrUtil.each(['contain', 'normalize'], function (methodName) {\n  LogScale.prototype[methodName] = function (val) {\n    val = mathLog(val) / mathLog(this.base);\n    return scaleProto[methodName].call(this, val);\n  };\n});\n\nLogScale.create = function () {\n  return new LogScale();\n};\n\nfunction fixRoundingError(val, originalVal) {\n  return roundingErrorFix(val, getPrecisionSafe(originalVal));\n}\n\nvar _default = LogScale;\nmodule.exports = _default;"]},"metadata":{},"sourceType":"script"}