{"ast":null,"code":"var util = require(\"./core/util\");\n\nvar vec2 = require(\"./core/vector\");\n\nvar Draggable = require(\"./mixin/Draggable\");\n\nvar Eventful = require(\"./mixin/Eventful\");\n/**\n * Handler\n * @module zrender/Handler\n * @author Kener (@Kener-林峰, kener.linfeng@gmail.com)\n *         errorrik (errorrik@gmail.com)\n *         pissang (shenyi.914@gmail.com)\n */\n\n\nvar SILENT = 'silent';\n\nfunction makeEventPacket(eveType, targetInfo, event) {\n  return {\n    type: eveType,\n    event: event,\n    // target can only be an element that is not silent.\n    target: targetInfo.target,\n    // topTarget can be a silent element.\n    topTarget: targetInfo.topTarget,\n    cancelBubble: false,\n    offsetX: event.zrX,\n    offsetY: event.zrY,\n    gestureEvent: event.gestureEvent,\n    pinchX: event.pinchX,\n    pinchY: event.pinchY,\n    pinchScale: event.pinchScale,\n    wheelDelta: event.zrDelta,\n    zrByTouch: event.zrByTouch,\n    which: event.which\n  };\n}\n\nfunction EmptyProxy() {}\n\nEmptyProxy.prototype.dispose = function () {};\n\nvar handlerNames = ['click', 'dblclick', 'mousewheel', 'mouseout', 'mouseup', 'mousedown', 'mousemove', 'contextmenu'];\n/**\n * @alias module:zrender/Handler\n * @constructor\n * @extends module:zrender/mixin/Eventful\n * @param {module:zrender/Storage} storage Storage instance.\n * @param {module:zrender/Painter} painter Painter instance.\n * @param {module:zrender/dom/HandlerProxy} proxy HandlerProxy instance.\n * @param {HTMLElement} painterRoot painter.root (not painter.getViewportRoot()).\n */\n\nvar Handler = function (storage, painter, proxy, painterRoot) {\n  Eventful.call(this);\n  this.storage = storage;\n  this.painter = painter;\n  this.painterRoot = painterRoot;\n  proxy = proxy || new EmptyProxy();\n  /**\n   * Proxy of event. can be Dom, WebGLSurface, etc.\n   */\n\n  this.proxy = proxy; // Attach handler\n\n  proxy.handler = this;\n  /**\n   * {target, topTarget, x, y}\n   * @private\n   * @type {Object}\n   */\n\n  this._hovered = {};\n  /**\n   * @private\n   * @type {Date}\n   */\n\n  this._lastTouchMoment;\n  /**\n   * @private\n   * @type {number}\n   */\n\n  this._lastX;\n  /**\n   * @private\n   * @type {number}\n   */\n\n  this._lastY;\n  Draggable.call(this);\n  util.each(handlerNames, function (name) {\n    proxy.on && proxy.on(name, this[name], this);\n  }, this);\n};\n\nHandler.prototype = {\n  constructor: Handler,\n  mousemove: function (event) {\n    var x = event.zrX;\n    var y = event.zrY;\n    var lastHovered = this._hovered;\n    var lastHoveredTarget = lastHovered.target; // If lastHoveredTarget is removed from zr (detected by '__zr') by some API call\n    // (like 'setOption' or 'dispatchAction') in event handlers, we should find\n    // lastHovered again here. Otherwise 'mouseout' can not be triggered normally.\n    // See #6198.\n\n    if (lastHoveredTarget && !lastHoveredTarget.__zr) {\n      lastHovered = this.findHover(lastHovered.x, lastHovered.y);\n      lastHoveredTarget = lastHovered.target;\n    }\n\n    var hovered = this._hovered = this.findHover(x, y);\n    var hoveredTarget = hovered.target;\n    var proxy = this.proxy;\n    proxy.setCursor && proxy.setCursor(hoveredTarget ? hoveredTarget.cursor : 'default'); // Mouse out on previous hovered element\n\n    if (lastHoveredTarget && hoveredTarget !== lastHoveredTarget) {\n      this.dispatchToElement(lastHovered, 'mouseout', event);\n    } // Mouse moving on one element\n\n\n    this.dispatchToElement(hovered, 'mousemove', event); // Mouse over on a new element\n\n    if (hoveredTarget && hoveredTarget !== lastHoveredTarget) {\n      this.dispatchToElement(hovered, 'mouseover', event);\n    }\n  },\n  mouseout: function (event) {\n    this.dispatchToElement(this._hovered, 'mouseout', event); // There might be some doms created by upper layer application\n    // at the same level of painter.getViewportRoot() (e.g., tooltip\n    // dom created by echarts), where 'globalout' event should not\n    // be triggered when mouse enters these doms. (But 'mouseout'\n    // should be triggered at the original hovered element as usual).\n\n    var element = event.toElement || event.relatedTarget;\n    var innerDom;\n\n    do {\n      element = element && element.parentNode;\n    } while (element && element.nodeType != 9 && !(innerDom = element === this.painterRoot));\n\n    !innerDom && this.trigger('globalout', {\n      event: event\n    });\n  },\n\n  /**\n   * Resize\n   */\n  resize: function (event) {\n    this._hovered = {};\n  },\n\n  /**\n   * Dispatch event\n   * @param {string} eventName\n   * @param {event=} eventArgs\n   */\n  dispatch: function (eventName, eventArgs) {\n    var handler = this[eventName];\n    handler && handler.call(this, eventArgs);\n  },\n\n  /**\n   * Dispose\n   */\n  dispose: function () {\n    this.proxy.dispose();\n    this.storage = this.proxy = this.painter = null;\n  },\n\n  /**\n   * 设置默认的cursor style\n   * @param {string} [cursorStyle='default'] 例如 crosshair\n   */\n  setCursorStyle: function (cursorStyle) {\n    var proxy = this.proxy;\n    proxy.setCursor && proxy.setCursor(cursorStyle);\n  },\n\n  /**\n   * 事件分发代理\n   *\n   * @private\n   * @param {Object} targetInfo {target, topTarget} 目标图形元素\n   * @param {string} eventName 事件名称\n   * @param {Object} event 事件对象\n   */\n  dispatchToElement: function (targetInfo, eventName, event) {\n    targetInfo = targetInfo || {};\n    var el = targetInfo.target;\n\n    if (el && el.silent) {\n      return;\n    }\n\n    var eventHandler = 'on' + eventName;\n    var eventPacket = makeEventPacket(eventName, targetInfo, event);\n\n    while (el) {\n      el[eventHandler] && (eventPacket.cancelBubble = el[eventHandler].call(el, eventPacket));\n      el.trigger(eventName, eventPacket);\n      el = el.parent;\n\n      if (eventPacket.cancelBubble) {\n        break;\n      }\n    }\n\n    if (!eventPacket.cancelBubble) {\n      // 冒泡到顶级 zrender 对象\n      this.trigger(eventName, eventPacket); // 分发事件到用户自定义层\n      // 用户有可能在全局 click 事件中 dispose，所以需要判断下 painter 是否存在\n\n      this.painter && this.painter.eachOtherLayer(function (layer) {\n        if (typeof layer[eventHandler] == 'function') {\n          layer[eventHandler].call(layer, eventPacket);\n        }\n\n        if (layer.trigger) {\n          layer.trigger(eventName, eventPacket);\n        }\n      });\n    }\n  },\n\n  /**\n   * @private\n   * @param {number} x\n   * @param {number} y\n   * @param {module:zrender/graphic/Displayable} exclude\n   * @return {model:zrender/Element}\n   * @method\n   */\n  findHover: function (x, y, exclude) {\n    var list = this.storage.getDisplayList();\n    var out = {\n      x: x,\n      y: y\n    };\n\n    for (var i = list.length - 1; i >= 0; i--) {\n      var hoverCheckResult;\n\n      if (list[i] !== exclude // getDisplayList may include ignored item in VML mode\n      && !list[i].ignore && (hoverCheckResult = isHover(list[i], x, y))) {\n        !out.topTarget && (out.topTarget = list[i]);\n\n        if (hoverCheckResult !== SILENT) {\n          out.target = list[i];\n          break;\n        }\n      }\n    }\n\n    return out;\n  }\n}; // Common handlers\n\nutil.each(['click', 'mousedown', 'mouseup', 'mousewheel', 'dblclick', 'contextmenu'], function (name) {\n  Handler.prototype[name] = function (event) {\n    // Find hover again to avoid click event is dispatched manually. Or click is triggered without mouseover\n    var hovered = this.findHover(event.zrX, event.zrY);\n    var hoveredTarget = hovered.target;\n\n    if (name === 'mousedown') {\n      this._downEl = hoveredTarget;\n      this._downPoint = [event.zrX, event.zrY]; // In case click triggered before mouseup\n\n      this._upEl = hoveredTarget;\n    } else if (name === 'mosueup') {\n      this._upEl = hoveredTarget;\n    } else if (name === 'click') {\n      if (this._downEl !== this._upEl // Original click event is triggered on the whole canvas element,\n      // including the case that `mousedown` - `mousemove` - `mouseup`,\n      // which should be filtered, otherwise it will bring trouble to\n      // pan and zoom.\n      || !this._downPoint // Arbitrary value\n      || vec2.dist(this._downPoint, [event.zrX, event.zrY]) > 4) {\n        return;\n      }\n\n      this._downPoint = null;\n    }\n\n    this.dispatchToElement(hovered, name, event);\n  };\n});\n\nfunction isHover(displayable, x, y) {\n  if (displayable[displayable.rectHover ? 'rectContain' : 'contain'](x, y)) {\n    var el = displayable;\n    var isSilent;\n\n    while (el) {\n      // If clipped by ancestor.\n      // FIXME: If clipPath has neither stroke nor fill,\n      // el.clipPath.contain(x, y) will always return false.\n      if (el.clipPath && !el.clipPath.contain(x, y)) {\n        return false;\n      }\n\n      if (el.silent) {\n        isSilent = true;\n      }\n\n      el = el.parent;\n    }\n\n    return isSilent ? SILENT : true;\n  }\n\n  return false;\n}\n\nutil.mixin(Handler, Eventful);\nutil.mixin(Handler, Draggable);\nvar _default = Handler;\nmodule.exports = _default;","map":{"version":3,"sources":["/home/martin/Escritorio/Taller de Integracion/Tarea3-TallerDeIntegracion/node_modules/react-echarts/node_modules/zrender/lib/Handler.js"],"names":["util","require","vec2","Draggable","Eventful","SILENT","makeEventPacket","eveType","targetInfo","event","type","target","topTarget","cancelBubble","offsetX","zrX","offsetY","zrY","gestureEvent","pinchX","pinchY","pinchScale","wheelDelta","zrDelta","zrByTouch","which","EmptyProxy","prototype","dispose","handlerNames","Handler","storage","painter","proxy","painterRoot","call","handler","_hovered","_lastTouchMoment","_lastX","_lastY","each","name","on","constructor","mousemove","x","y","lastHovered","lastHoveredTarget","__zr","findHover","hovered","hoveredTarget","setCursor","cursor","dispatchToElement","mouseout","element","toElement","relatedTarget","innerDom","parentNode","nodeType","trigger","resize","dispatch","eventName","eventArgs","setCursorStyle","cursorStyle","el","silent","eventHandler","eventPacket","parent","eachOtherLayer","layer","exclude","list","getDisplayList","out","i","length","hoverCheckResult","ignore","isHover","_downEl","_downPoint","_upEl","dist","displayable","rectHover","isSilent","clipPath","contain","mixin","_default","module","exports"],"mappings":"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","sourcesContent":["var util = require(\"./core/util\");\n\nvar vec2 = require(\"./core/vector\");\n\nvar Draggable = require(\"./mixin/Draggable\");\n\nvar Eventful = require(\"./mixin/Eventful\");\n\n/**\n * Handler\n * @module zrender/Handler\n * @author Kener (@Kener-林峰, kener.linfeng@gmail.com)\n *         errorrik (errorrik@gmail.com)\n *         pissang (shenyi.914@gmail.com)\n */\nvar SILENT = 'silent';\n\nfunction makeEventPacket(eveType, targetInfo, event) {\n  return {\n    type: eveType,\n    event: event,\n    // target can only be an element that is not silent.\n    target: targetInfo.target,\n    // topTarget can be a silent element.\n    topTarget: targetInfo.topTarget,\n    cancelBubble: false,\n    offsetX: event.zrX,\n    offsetY: event.zrY,\n    gestureEvent: event.gestureEvent,\n    pinchX: event.pinchX,\n    pinchY: event.pinchY,\n    pinchScale: event.pinchScale,\n    wheelDelta: event.zrDelta,\n    zrByTouch: event.zrByTouch,\n    which: event.which\n  };\n}\n\nfunction EmptyProxy() {}\n\nEmptyProxy.prototype.dispose = function () {};\n\nvar handlerNames = ['click', 'dblclick', 'mousewheel', 'mouseout', 'mouseup', 'mousedown', 'mousemove', 'contextmenu'];\n/**\n * @alias module:zrender/Handler\n * @constructor\n * @extends module:zrender/mixin/Eventful\n * @param {module:zrender/Storage} storage Storage instance.\n * @param {module:zrender/Painter} painter Painter instance.\n * @param {module:zrender/dom/HandlerProxy} proxy HandlerProxy instance.\n * @param {HTMLElement} painterRoot painter.root (not painter.getViewportRoot()).\n */\n\nvar Handler = function (storage, painter, proxy, painterRoot) {\n  Eventful.call(this);\n  this.storage = storage;\n  this.painter = painter;\n  this.painterRoot = painterRoot;\n  proxy = proxy || new EmptyProxy();\n  /**\n   * Proxy of event. can be Dom, WebGLSurface, etc.\n   */\n\n  this.proxy = proxy; // Attach handler\n\n  proxy.handler = this;\n  /**\n   * {target, topTarget, x, y}\n   * @private\n   * @type {Object}\n   */\n\n  this._hovered = {};\n  /**\n   * @private\n   * @type {Date}\n   */\n\n  this._lastTouchMoment;\n  /**\n   * @private\n   * @type {number}\n   */\n\n  this._lastX;\n  /**\n   * @private\n   * @type {number}\n   */\n\n  this._lastY;\n  Draggable.call(this);\n  util.each(handlerNames, function (name) {\n    proxy.on && proxy.on(name, this[name], this);\n  }, this);\n};\n\nHandler.prototype = {\n  constructor: Handler,\n  mousemove: function (event) {\n    var x = event.zrX;\n    var y = event.zrY;\n    var lastHovered = this._hovered;\n    var lastHoveredTarget = lastHovered.target; // If lastHoveredTarget is removed from zr (detected by '__zr') by some API call\n    // (like 'setOption' or 'dispatchAction') in event handlers, we should find\n    // lastHovered again here. Otherwise 'mouseout' can not be triggered normally.\n    // See #6198.\n\n    if (lastHoveredTarget && !lastHoveredTarget.__zr) {\n      lastHovered = this.findHover(lastHovered.x, lastHovered.y);\n      lastHoveredTarget = lastHovered.target;\n    }\n\n    var hovered = this._hovered = this.findHover(x, y);\n    var hoveredTarget = hovered.target;\n    var proxy = this.proxy;\n    proxy.setCursor && proxy.setCursor(hoveredTarget ? hoveredTarget.cursor : 'default'); // Mouse out on previous hovered element\n\n    if (lastHoveredTarget && hoveredTarget !== lastHoveredTarget) {\n      this.dispatchToElement(lastHovered, 'mouseout', event);\n    } // Mouse moving on one element\n\n\n    this.dispatchToElement(hovered, 'mousemove', event); // Mouse over on a new element\n\n    if (hoveredTarget && hoveredTarget !== lastHoveredTarget) {\n      this.dispatchToElement(hovered, 'mouseover', event);\n    }\n  },\n  mouseout: function (event) {\n    this.dispatchToElement(this._hovered, 'mouseout', event); // There might be some doms created by upper layer application\n    // at the same level of painter.getViewportRoot() (e.g., tooltip\n    // dom created by echarts), where 'globalout' event should not\n    // be triggered when mouse enters these doms. (But 'mouseout'\n    // should be triggered at the original hovered element as usual).\n\n    var element = event.toElement || event.relatedTarget;\n    var innerDom;\n\n    do {\n      element = element && element.parentNode;\n    } while (element && element.nodeType != 9 && !(innerDom = element === this.painterRoot));\n\n    !innerDom && this.trigger('globalout', {\n      event: event\n    });\n  },\n\n  /**\n   * Resize\n   */\n  resize: function (event) {\n    this._hovered = {};\n  },\n\n  /**\n   * Dispatch event\n   * @param {string} eventName\n   * @param {event=} eventArgs\n   */\n  dispatch: function (eventName, eventArgs) {\n    var handler = this[eventName];\n    handler && handler.call(this, eventArgs);\n  },\n\n  /**\n   * Dispose\n   */\n  dispose: function () {\n    this.proxy.dispose();\n    this.storage = this.proxy = this.painter = null;\n  },\n\n  /**\n   * 设置默认的cursor style\n   * @param {string} [cursorStyle='default'] 例如 crosshair\n   */\n  setCursorStyle: function (cursorStyle) {\n    var proxy = this.proxy;\n    proxy.setCursor && proxy.setCursor(cursorStyle);\n  },\n\n  /**\n   * 事件分发代理\n   *\n   * @private\n   * @param {Object} targetInfo {target, topTarget} 目标图形元素\n   * @param {string} eventName 事件名称\n   * @param {Object} event 事件对象\n   */\n  dispatchToElement: function (targetInfo, eventName, event) {\n    targetInfo = targetInfo || {};\n    var el = targetInfo.target;\n\n    if (el && el.silent) {\n      return;\n    }\n\n    var eventHandler = 'on' + eventName;\n    var eventPacket = makeEventPacket(eventName, targetInfo, event);\n\n    while (el) {\n      el[eventHandler] && (eventPacket.cancelBubble = el[eventHandler].call(el, eventPacket));\n      el.trigger(eventName, eventPacket);\n      el = el.parent;\n\n      if (eventPacket.cancelBubble) {\n        break;\n      }\n    }\n\n    if (!eventPacket.cancelBubble) {\n      // 冒泡到顶级 zrender 对象\n      this.trigger(eventName, eventPacket); // 分发事件到用户自定义层\n      // 用户有可能在全局 click 事件中 dispose，所以需要判断下 painter 是否存在\n\n      this.painter && this.painter.eachOtherLayer(function (layer) {\n        if (typeof layer[eventHandler] == 'function') {\n          layer[eventHandler].call(layer, eventPacket);\n        }\n\n        if (layer.trigger) {\n          layer.trigger(eventName, eventPacket);\n        }\n      });\n    }\n  },\n\n  /**\n   * @private\n   * @param {number} x\n   * @param {number} y\n   * @param {module:zrender/graphic/Displayable} exclude\n   * @return {model:zrender/Element}\n   * @method\n   */\n  findHover: function (x, y, exclude) {\n    var list = this.storage.getDisplayList();\n    var out = {\n      x: x,\n      y: y\n    };\n\n    for (var i = list.length - 1; i >= 0; i--) {\n      var hoverCheckResult;\n\n      if (list[i] !== exclude // getDisplayList may include ignored item in VML mode\n      && !list[i].ignore && (hoverCheckResult = isHover(list[i], x, y))) {\n        !out.topTarget && (out.topTarget = list[i]);\n\n        if (hoverCheckResult !== SILENT) {\n          out.target = list[i];\n          break;\n        }\n      }\n    }\n\n    return out;\n  }\n}; // Common handlers\n\nutil.each(['click', 'mousedown', 'mouseup', 'mousewheel', 'dblclick', 'contextmenu'], function (name) {\n  Handler.prototype[name] = function (event) {\n    // Find hover again to avoid click event is dispatched manually. Or click is triggered without mouseover\n    var hovered = this.findHover(event.zrX, event.zrY);\n    var hoveredTarget = hovered.target;\n\n    if (name === 'mousedown') {\n      this._downEl = hoveredTarget;\n      this._downPoint = [event.zrX, event.zrY]; // In case click triggered before mouseup\n\n      this._upEl = hoveredTarget;\n    } else if (name === 'mosueup') {\n      this._upEl = hoveredTarget;\n    } else if (name === 'click') {\n      if (this._downEl !== this._upEl // Original click event is triggered on the whole canvas element,\n      // including the case that `mousedown` - `mousemove` - `mouseup`,\n      // which should be filtered, otherwise it will bring trouble to\n      // pan and zoom.\n      || !this._downPoint // Arbitrary value\n      || vec2.dist(this._downPoint, [event.zrX, event.zrY]) > 4) {\n        return;\n      }\n\n      this._downPoint = null;\n    }\n\n    this.dispatchToElement(hovered, name, event);\n  };\n});\n\nfunction isHover(displayable, x, y) {\n  if (displayable[displayable.rectHover ? 'rectContain' : 'contain'](x, y)) {\n    var el = displayable;\n    var isSilent;\n\n    while (el) {\n      // If clipped by ancestor.\n      // FIXME: If clipPath has neither stroke nor fill,\n      // el.clipPath.contain(x, y) will always return false.\n      if (el.clipPath && !el.clipPath.contain(x, y)) {\n        return false;\n      }\n\n      if (el.silent) {\n        isSilent = true;\n      }\n\n      el = el.parent;\n    }\n\n    return isSilent ? SILENT : true;\n  }\n\n  return false;\n}\n\nutil.mixin(Handler, Eventful);\nutil.mixin(Handler, Draggable);\nvar _default = Handler;\nmodule.exports = _default;"]},"metadata":{},"sourceType":"script"}