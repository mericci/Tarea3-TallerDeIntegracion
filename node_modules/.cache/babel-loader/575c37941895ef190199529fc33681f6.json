{"ast":null,"code":"var zrUtil = require(\"zrender/lib/core/util\");\n\nvar _number = require(\"../util/number\");\n\nvar parsePercent = _number.parsePercent;\nvar STACK_PREFIX = '__ec_stack_';\n\nfunction getSeriesStackId(seriesModel) {\n  return seriesModel.get('stack') || STACK_PREFIX + seriesModel.seriesIndex;\n}\n\nfunction getAxisKey(axis) {\n  return axis.dim + axis.index;\n}\n/**\n * @param {Object} opt\n * @param {module:echarts/coord/Axis} opt.axis Only support category axis currently.\n * @param {number} opt.count Positive interger.\n * @param {number} [opt.barWidth]\n * @param {number} [opt.barMaxWidth]\n * @param {number} [opt.barGap]\n * @param {number} [opt.barCategoryGap]\n * @return {Object} {width, offset, offsetCenter} If axis.type is not 'category', return undefined.\n */\n\n\nfunction getLayoutOnAxis(opt, api) {\n  var params = [];\n  var baseAxis = opt.axis;\n  var axisKey = 'axis0';\n\n  if (baseAxis.type !== 'category') {\n    return;\n  }\n\n  var bandWidth = baseAxis.getBandWidth();\n\n  for (var i = 0; i < opt.count || 0; i++) {\n    params.push(zrUtil.defaults({\n      bandWidth: bandWidth,\n      axisKey: axisKey,\n      stackId: STACK_PREFIX + i\n    }, opt));\n  }\n\n  var widthAndOffsets = doCalBarWidthAndOffset(params, api);\n  var result = [];\n\n  for (var i = 0; i < opt.count; i++) {\n    var item = widthAndOffsets[axisKey][STACK_PREFIX + i];\n    item.offsetCenter = item.offset + item.width / 2;\n    result.push(item);\n  }\n\n  return result;\n}\n\nfunction calBarWidthAndOffset(barSeries, api) {\n  var seriesInfoList = zrUtil.map(barSeries, function (seriesModel) {\n    var data = seriesModel.getData();\n    var cartesian = seriesModel.coordinateSystem;\n    var baseAxis = cartesian.getBaseAxis();\n    var axisExtent = baseAxis.getExtent();\n    var bandWidth = baseAxis.type === 'category' ? baseAxis.getBandWidth() : Math.abs(axisExtent[1] - axisExtent[0]) / data.count();\n    var barWidth = parsePercent(seriesModel.get('barWidth'), bandWidth);\n    var barMaxWidth = parsePercent(seriesModel.get('barMaxWidth'), bandWidth);\n    var barGap = seriesModel.get('barGap');\n    var barCategoryGap = seriesModel.get('barCategoryGap');\n    return {\n      bandWidth: bandWidth,\n      barWidth: barWidth,\n      barMaxWidth: barMaxWidth,\n      barGap: barGap,\n      barCategoryGap: barCategoryGap,\n      axisKey: getAxisKey(baseAxis),\n      stackId: getSeriesStackId(seriesModel)\n    };\n  });\n  return doCalBarWidthAndOffset(seriesInfoList, api);\n}\n\nfunction doCalBarWidthAndOffset(seriesInfoList, api) {\n  // Columns info on each category axis. Key is cartesian name\n  var columnsMap = {};\n  zrUtil.each(seriesInfoList, function (seriesInfo, idx) {\n    var axisKey = seriesInfo.axisKey;\n    var bandWidth = seriesInfo.bandWidth;\n    var columnsOnAxis = columnsMap[axisKey] || {\n      bandWidth: bandWidth,\n      remainedWidth: bandWidth,\n      autoWidthCount: 0,\n      categoryGap: '20%',\n      gap: '30%',\n      stacks: {}\n    };\n    var stacks = columnsOnAxis.stacks;\n    columnsMap[axisKey] = columnsOnAxis;\n    var stackId = seriesInfo.stackId;\n\n    if (!stacks[stackId]) {\n      columnsOnAxis.autoWidthCount++;\n    }\n\n    stacks[stackId] = stacks[stackId] || {\n      width: 0,\n      maxWidth: 0\n    }; // Caution: In a single coordinate system, these barGrid attributes\n    // will be shared by series. Consider that they have default values,\n    // only the attributes set on the last series will work.\n    // Do not change this fact unless there will be a break change.\n    // TODO\n\n    var barWidth = seriesInfo.barWidth;\n\n    if (barWidth && !stacks[stackId].width) {\n      // See #6312, do not restrict width.\n      stacks[stackId].width = barWidth;\n      barWidth = Math.min(columnsOnAxis.remainedWidth, barWidth);\n      columnsOnAxis.remainedWidth -= barWidth;\n    }\n\n    var barMaxWidth = seriesInfo.barMaxWidth;\n    barMaxWidth && (stacks[stackId].maxWidth = barMaxWidth);\n    var barGap = seriesInfo.barGap;\n    barGap != null && (columnsOnAxis.gap = barGap);\n    var barCategoryGap = seriesInfo.barCategoryGap;\n    barCategoryGap != null && (columnsOnAxis.categoryGap = barCategoryGap);\n  });\n  var result = {};\n  zrUtil.each(columnsMap, function (columnsOnAxis, coordSysName) {\n    result[coordSysName] = {};\n    var stacks = columnsOnAxis.stacks;\n    var bandWidth = columnsOnAxis.bandWidth;\n    var categoryGap = parsePercent(columnsOnAxis.categoryGap, bandWidth);\n    var barGapPercent = parsePercent(columnsOnAxis.gap, 1);\n    var remainedWidth = columnsOnAxis.remainedWidth;\n    var autoWidthCount = columnsOnAxis.autoWidthCount;\n    var autoWidth = (remainedWidth - categoryGap) / (autoWidthCount + (autoWidthCount - 1) * barGapPercent);\n    autoWidth = Math.max(autoWidth, 0); // Find if any auto calculated bar exceeded maxBarWidth\n\n    zrUtil.each(stacks, function (column, stack) {\n      var maxWidth = column.maxWidth;\n\n      if (maxWidth && maxWidth < autoWidth) {\n        maxWidth = Math.min(maxWidth, remainedWidth);\n\n        if (column.width) {\n          maxWidth = Math.min(maxWidth, column.width);\n        }\n\n        remainedWidth -= maxWidth;\n        column.width = maxWidth;\n        autoWidthCount--;\n      }\n    }); // Recalculate width again\n\n    autoWidth = (remainedWidth - categoryGap) / (autoWidthCount + (autoWidthCount - 1) * barGapPercent);\n    autoWidth = Math.max(autoWidth, 0);\n    var widthSum = 0;\n    var lastColumn;\n    zrUtil.each(stacks, function (column, idx) {\n      if (!column.width) {\n        column.width = autoWidth;\n      }\n\n      lastColumn = column;\n      widthSum += column.width * (1 + barGapPercent);\n    });\n\n    if (lastColumn) {\n      widthSum -= lastColumn.width * barGapPercent;\n    }\n\n    var offset = -widthSum / 2;\n    zrUtil.each(stacks, function (column, stackId) {\n      result[coordSysName][stackId] = result[coordSysName][stackId] || {\n        offset: offset,\n        width: column.width\n      };\n      offset += column.width * (1 + barGapPercent);\n    });\n  });\n  return result;\n}\n/**\n * @param {string} seriesType\n * @param {module:echarts/model/Global} ecModel\n * @param {module:echarts/ExtensionAPI} api\n */\n\n\nfunction barLayoutGrid(seriesType, ecModel, api) {\n  var barWidthAndOffset = calBarWidthAndOffset(zrUtil.filter(ecModel.getSeriesByType(seriesType), function (seriesModel) {\n    return !ecModel.isSeriesFiltered(seriesModel) && seriesModel.coordinateSystem && seriesModel.coordinateSystem.type === 'cartesian2d';\n  }));\n  var lastStackCoords = {};\n  var lastStackCoordsOrigin = {};\n  ecModel.eachSeriesByType(seriesType, function (seriesModel) {\n    // Check series coordinate, do layout for cartesian2d only\n    if (seriesModel.coordinateSystem.type !== 'cartesian2d') {\n      return;\n    }\n\n    var data = seriesModel.getData();\n    var cartesian = seriesModel.coordinateSystem;\n    var baseAxis = cartesian.getBaseAxis();\n    var stackId = getSeriesStackId(seriesModel);\n    var columnLayoutInfo = barWidthAndOffset[getAxisKey(baseAxis)][stackId];\n    var columnOffset = columnLayoutInfo.offset;\n    var columnWidth = columnLayoutInfo.width;\n    var valueAxis = cartesian.getOtherAxis(baseAxis);\n    var barMinHeight = seriesModel.get('barMinHeight') || 0;\n    var valueAxisStart = baseAxis.onZero ? valueAxis.toGlobalCoord(valueAxis.dataToCoord(0)) : valueAxis.getGlobalExtent()[0];\n    var coordDims = [seriesModel.coordDimToDataDim('x')[0], seriesModel.coordDimToDataDim('y')[0]];\n    var coords = data.mapArray(coordDims, function (x, y) {\n      return cartesian.dataToPoint([x, y]);\n    }, true);\n    lastStackCoords[stackId] = lastStackCoords[stackId] || [];\n    lastStackCoordsOrigin[stackId] = lastStackCoordsOrigin[stackId] || []; // Fix #4243\n\n    data.setLayout({\n      offset: columnOffset,\n      size: columnWidth\n    });\n    data.each(seriesModel.coordDimToDataDim(valueAxis.dim)[0], function (value, idx) {\n      if (isNaN(value)) {\n        return;\n      }\n\n      if (!lastStackCoords[stackId][idx]) {\n        lastStackCoords[stackId][idx] = {\n          p: valueAxisStart,\n          // Positive stack\n          n: valueAxisStart // Negative stack\n\n        };\n        lastStackCoordsOrigin[stackId][idx] = {\n          p: valueAxisStart,\n          // Positive stack\n          n: valueAxisStart // Negative stack\n\n        };\n      }\n\n      var sign = value >= 0 ? 'p' : 'n';\n      var coord = coords[idx];\n      var lastCoord = lastStackCoords[stackId][idx][sign];\n      var lastCoordOrigin = lastStackCoordsOrigin[stackId][idx][sign];\n      var x;\n      var y;\n      var width;\n      var height;\n\n      if (valueAxis.isHorizontal()) {\n        x = lastCoord;\n        y = coord[1] + columnOffset;\n        width = coord[0] - lastCoordOrigin;\n        height = columnWidth;\n        lastStackCoordsOrigin[stackId][idx][sign] += width;\n\n        if (Math.abs(width) < barMinHeight) {\n          width = (width < 0 ? -1 : 1) * barMinHeight;\n        }\n\n        lastStackCoords[stackId][idx][sign] += width;\n      } else {\n        x = coord[0] + columnOffset;\n        y = lastCoord;\n        width = columnWidth;\n        height = coord[1] - lastCoordOrigin;\n        lastStackCoordsOrigin[stackId][idx][sign] += height;\n\n        if (Math.abs(height) < barMinHeight) {\n          // Include zero to has a positive bar\n          height = (height <= 0 ? -1 : 1) * barMinHeight;\n        }\n\n        lastStackCoords[stackId][idx][sign] += height;\n      }\n\n      data.setItemLayout(idx, {\n        x: x,\n        y: y,\n        width: width,\n        height: height\n      });\n    }, true);\n  }, this);\n}\n\nbarLayoutGrid.getLayoutOnAxis = getLayoutOnAxis;\nvar _default = barLayoutGrid;\nmodule.exports = _default;","map":{"version":3,"sources":["/home/martin/Escritorio/Taller de Integracion/Tarea3-TallerDeIntegracion/node_modules/react-echarts/node_modules/echarts/lib/layout/barGrid.js"],"names":["zrUtil","require","_number","parsePercent","STACK_PREFIX","getSeriesStackId","seriesModel","get","seriesIndex","getAxisKey","axis","dim","index","getLayoutOnAxis","opt","api","params","baseAxis","axisKey","type","bandWidth","getBandWidth","i","count","push","defaults","stackId","widthAndOffsets","doCalBarWidthAndOffset","result","item","offsetCenter","offset","width","calBarWidthAndOffset","barSeries","seriesInfoList","map","data","getData","cartesian","coordinateSystem","getBaseAxis","axisExtent","getExtent","Math","abs","barWidth","barMaxWidth","barGap","barCategoryGap","columnsMap","each","seriesInfo","idx","columnsOnAxis","remainedWidth","autoWidthCount","categoryGap","gap","stacks","maxWidth","min","coordSysName","barGapPercent","autoWidth","max","column","stack","widthSum","lastColumn","barLayoutGrid","seriesType","ecModel","barWidthAndOffset","filter","getSeriesByType","isSeriesFiltered","lastStackCoords","lastStackCoordsOrigin","eachSeriesByType","columnLayoutInfo","columnOffset","columnWidth","valueAxis","getOtherAxis","barMinHeight","valueAxisStart","onZero","toGlobalCoord","dataToCoord","getGlobalExtent","coordDims","coordDimToDataDim","coords","mapArray","x","y","dataToPoint","setLayout","size","value","isNaN","p","n","sign","coord","lastCoord","lastCoordOrigin","height","isHorizontal","setItemLayout","_default","module","exports"],"mappings":"AAAA,IAAIA,MAAM,GAAGC,OAAO,CAAC,uBAAD,CAApB;;AAEA,IAAIC,OAAO,GAAGD,OAAO,CAAC,gBAAD,CAArB;;AAEA,IAAIE,YAAY,GAAGD,OAAO,CAACC,YAA3B;AACA,IAAIC,YAAY,GAAG,aAAnB;;AAEA,SAASC,gBAAT,CAA0BC,WAA1B,EAAuC;AACrC,SAAOA,WAAW,CAACC,GAAZ,CAAgB,OAAhB,KAA4BH,YAAY,GAAGE,WAAW,CAACE,WAA9D;AACD;;AAED,SAASC,UAAT,CAAoBC,IAApB,EAA0B;AACxB,SAAOA,IAAI,CAACC,GAAL,GAAWD,IAAI,CAACE,KAAvB;AACD;AACD;;;;;;;;;;;;AAYA,SAASC,eAAT,CAAyBC,GAAzB,EAA8BC,GAA9B,EAAmC;AACjC,MAAIC,MAAM,GAAG,EAAb;AACA,MAAIC,QAAQ,GAAGH,GAAG,CAACJ,IAAnB;AACA,MAAIQ,OAAO,GAAG,OAAd;;AAEA,MAAID,QAAQ,CAACE,IAAT,KAAkB,UAAtB,EAAkC;AAChC;AACD;;AAED,MAAIC,SAAS,GAAGH,QAAQ,CAACI,YAAT,EAAhB;;AAEA,OAAK,IAAIC,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGR,GAAG,CAACS,KAAR,IAAiB,CAAjC,EAAoCD,CAAC,EAArC,EAAyC;AACvCN,IAAAA,MAAM,CAACQ,IAAP,CAAYxB,MAAM,CAACyB,QAAP,CAAgB;AAC1BL,MAAAA,SAAS,EAAEA,SADe;AAE1BF,MAAAA,OAAO,EAAEA,OAFiB;AAG1BQ,MAAAA,OAAO,EAAEtB,YAAY,GAAGkB;AAHE,KAAhB,EAITR,GAJS,CAAZ;AAKD;;AAED,MAAIa,eAAe,GAAGC,sBAAsB,CAACZ,MAAD,EAASD,GAAT,CAA5C;AACA,MAAIc,MAAM,GAAG,EAAb;;AAEA,OAAK,IAAIP,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGR,GAAG,CAACS,KAAxB,EAA+BD,CAAC,EAAhC,EAAoC;AAClC,QAAIQ,IAAI,GAAGH,eAAe,CAACT,OAAD,CAAf,CAAyBd,YAAY,GAAGkB,CAAxC,CAAX;AACAQ,IAAAA,IAAI,CAACC,YAAL,GAAoBD,IAAI,CAACE,MAAL,GAAcF,IAAI,CAACG,KAAL,GAAa,CAA/C;AACAJ,IAAAA,MAAM,CAACL,IAAP,CAAYM,IAAZ;AACD;;AAED,SAAOD,MAAP;AACD;;AAED,SAASK,oBAAT,CAA8BC,SAA9B,EAAyCpB,GAAzC,EAA8C;AAC5C,MAAIqB,cAAc,GAAGpC,MAAM,CAACqC,GAAP,CAAWF,SAAX,EAAsB,UAAU7B,WAAV,EAAuB;AAChE,QAAIgC,IAAI,GAAGhC,WAAW,CAACiC,OAAZ,EAAX;AACA,QAAIC,SAAS,GAAGlC,WAAW,CAACmC,gBAA5B;AACA,QAAIxB,QAAQ,GAAGuB,SAAS,CAACE,WAAV,EAAf;AACA,QAAIC,UAAU,GAAG1B,QAAQ,CAAC2B,SAAT,EAAjB;AACA,QAAIxB,SAAS,GAAGH,QAAQ,CAACE,IAAT,KAAkB,UAAlB,GAA+BF,QAAQ,CAACI,YAAT,EAA/B,GAAyDwB,IAAI,CAACC,GAAL,CAASH,UAAU,CAAC,CAAD,CAAV,GAAgBA,UAAU,CAAC,CAAD,CAAnC,IAA0CL,IAAI,CAACf,KAAL,EAAnH;AACA,QAAIwB,QAAQ,GAAG5C,YAAY,CAACG,WAAW,CAACC,GAAZ,CAAgB,UAAhB,CAAD,EAA8Ba,SAA9B,CAA3B;AACA,QAAI4B,WAAW,GAAG7C,YAAY,CAACG,WAAW,CAACC,GAAZ,CAAgB,aAAhB,CAAD,EAAiCa,SAAjC,CAA9B;AACA,QAAI6B,MAAM,GAAG3C,WAAW,CAACC,GAAZ,CAAgB,QAAhB,CAAb;AACA,QAAI2C,cAAc,GAAG5C,WAAW,CAACC,GAAZ,CAAgB,gBAAhB,CAArB;AACA,WAAO;AACLa,MAAAA,SAAS,EAAEA,SADN;AAEL2B,MAAAA,QAAQ,EAAEA,QAFL;AAGLC,MAAAA,WAAW,EAAEA,WAHR;AAILC,MAAAA,MAAM,EAAEA,MAJH;AAKLC,MAAAA,cAAc,EAAEA,cALX;AAMLhC,MAAAA,OAAO,EAAET,UAAU,CAACQ,QAAD,CANd;AAOLS,MAAAA,OAAO,EAAErB,gBAAgB,CAACC,WAAD;AAPpB,KAAP;AASD,GAnBoB,CAArB;AAoBA,SAAOsB,sBAAsB,CAACQ,cAAD,EAAiBrB,GAAjB,CAA7B;AACD;;AAED,SAASa,sBAAT,CAAgCQ,cAAhC,EAAgDrB,GAAhD,EAAqD;AACnD;AACA,MAAIoC,UAAU,GAAG,EAAjB;AACAnD,EAAAA,MAAM,CAACoD,IAAP,CAAYhB,cAAZ,EAA4B,UAAUiB,UAAV,EAAsBC,GAAtB,EAA2B;AACrD,QAAIpC,OAAO,GAAGmC,UAAU,CAACnC,OAAzB;AACA,QAAIE,SAAS,GAAGiC,UAAU,CAACjC,SAA3B;AACA,QAAImC,aAAa,GAAGJ,UAAU,CAACjC,OAAD,CAAV,IAAuB;AACzCE,MAAAA,SAAS,EAAEA,SAD8B;AAEzCoC,MAAAA,aAAa,EAAEpC,SAF0B;AAGzCqC,MAAAA,cAAc,EAAE,CAHyB;AAIzCC,MAAAA,WAAW,EAAE,KAJ4B;AAKzCC,MAAAA,GAAG,EAAE,KALoC;AAMzCC,MAAAA,MAAM,EAAE;AANiC,KAA3C;AAQA,QAAIA,MAAM,GAAGL,aAAa,CAACK,MAA3B;AACAT,IAAAA,UAAU,CAACjC,OAAD,CAAV,GAAsBqC,aAAtB;AACA,QAAI7B,OAAO,GAAG2B,UAAU,CAAC3B,OAAzB;;AAEA,QAAI,CAACkC,MAAM,CAAClC,OAAD,CAAX,EAAsB;AACpB6B,MAAAA,aAAa,CAACE,cAAd;AACD;;AAEDG,IAAAA,MAAM,CAAClC,OAAD,CAAN,GAAkBkC,MAAM,CAAClC,OAAD,CAAN,IAAmB;AACnCO,MAAAA,KAAK,EAAE,CAD4B;AAEnC4B,MAAAA,QAAQ,EAAE;AAFyB,KAArC,CAnBqD,CAsBlD;AACH;AACA;AACA;AACA;;AAEA,QAAId,QAAQ,GAAGM,UAAU,CAACN,QAA1B;;AAEA,QAAIA,QAAQ,IAAI,CAACa,MAAM,CAAClC,OAAD,CAAN,CAAgBO,KAAjC,EAAwC;AACtC;AACA2B,MAAAA,MAAM,CAAClC,OAAD,CAAN,CAAgBO,KAAhB,GAAwBc,QAAxB;AACAA,MAAAA,QAAQ,GAAGF,IAAI,CAACiB,GAAL,CAASP,aAAa,CAACC,aAAvB,EAAsCT,QAAtC,CAAX;AACAQ,MAAAA,aAAa,CAACC,aAAd,IAA+BT,QAA/B;AACD;;AAED,QAAIC,WAAW,GAAGK,UAAU,CAACL,WAA7B;AACAA,IAAAA,WAAW,KAAKY,MAAM,CAAClC,OAAD,CAAN,CAAgBmC,QAAhB,GAA2Bb,WAAhC,CAAX;AACA,QAAIC,MAAM,GAAGI,UAAU,CAACJ,MAAxB;AACAA,IAAAA,MAAM,IAAI,IAAV,KAAmBM,aAAa,CAACI,GAAd,GAAoBV,MAAvC;AACA,QAAIC,cAAc,GAAGG,UAAU,CAACH,cAAhC;AACAA,IAAAA,cAAc,IAAI,IAAlB,KAA2BK,aAAa,CAACG,WAAd,GAA4BR,cAAvD;AACD,GA3CD;AA4CA,MAAIrB,MAAM,GAAG,EAAb;AACA7B,EAAAA,MAAM,CAACoD,IAAP,CAAYD,UAAZ,EAAwB,UAAUI,aAAV,EAAyBQ,YAAzB,EAAuC;AAC7DlC,IAAAA,MAAM,CAACkC,YAAD,CAAN,GAAuB,EAAvB;AACA,QAAIH,MAAM,GAAGL,aAAa,CAACK,MAA3B;AACA,QAAIxC,SAAS,GAAGmC,aAAa,CAACnC,SAA9B;AACA,QAAIsC,WAAW,GAAGvD,YAAY,CAACoD,aAAa,CAACG,WAAf,EAA4BtC,SAA5B,CAA9B;AACA,QAAI4C,aAAa,GAAG7D,YAAY,CAACoD,aAAa,CAACI,GAAf,EAAoB,CAApB,CAAhC;AACA,QAAIH,aAAa,GAAGD,aAAa,CAACC,aAAlC;AACA,QAAIC,cAAc,GAAGF,aAAa,CAACE,cAAnC;AACA,QAAIQ,SAAS,GAAG,CAACT,aAAa,GAAGE,WAAjB,KAAiCD,cAAc,GAAG,CAACA,cAAc,GAAG,CAAlB,IAAuBO,aAAzE,CAAhB;AACAC,IAAAA,SAAS,GAAGpB,IAAI,CAACqB,GAAL,CAASD,SAAT,EAAoB,CAApB,CAAZ,CAT6D,CASzB;;AAEpCjE,IAAAA,MAAM,CAACoD,IAAP,CAAYQ,MAAZ,EAAoB,UAAUO,MAAV,EAAkBC,KAAlB,EAAyB;AAC3C,UAAIP,QAAQ,GAAGM,MAAM,CAACN,QAAtB;;AAEA,UAAIA,QAAQ,IAAIA,QAAQ,GAAGI,SAA3B,EAAsC;AACpCJ,QAAAA,QAAQ,GAAGhB,IAAI,CAACiB,GAAL,CAASD,QAAT,EAAmBL,aAAnB,CAAX;;AAEA,YAAIW,MAAM,CAAClC,KAAX,EAAkB;AAChB4B,UAAAA,QAAQ,GAAGhB,IAAI,CAACiB,GAAL,CAASD,QAAT,EAAmBM,MAAM,CAAClC,KAA1B,CAAX;AACD;;AAEDuB,QAAAA,aAAa,IAAIK,QAAjB;AACAM,QAAAA,MAAM,CAAClC,KAAP,GAAe4B,QAAf;AACAJ,QAAAA,cAAc;AACf;AACF,KAdD,EAX6D,CAyBzD;;AAEJQ,IAAAA,SAAS,GAAG,CAACT,aAAa,GAAGE,WAAjB,KAAiCD,cAAc,GAAG,CAACA,cAAc,GAAG,CAAlB,IAAuBO,aAAzE,CAAZ;AACAC,IAAAA,SAAS,GAAGpB,IAAI,CAACqB,GAAL,CAASD,SAAT,EAAoB,CAApB,CAAZ;AACA,QAAII,QAAQ,GAAG,CAAf;AACA,QAAIC,UAAJ;AACAtE,IAAAA,MAAM,CAACoD,IAAP,CAAYQ,MAAZ,EAAoB,UAAUO,MAAV,EAAkBb,GAAlB,EAAuB;AACzC,UAAI,CAACa,MAAM,CAAClC,KAAZ,EAAmB;AACjBkC,QAAAA,MAAM,CAAClC,KAAP,GAAegC,SAAf;AACD;;AAEDK,MAAAA,UAAU,GAAGH,MAAb;AACAE,MAAAA,QAAQ,IAAIF,MAAM,CAAClC,KAAP,IAAgB,IAAI+B,aAApB,CAAZ;AACD,KAPD;;AASA,QAAIM,UAAJ,EAAgB;AACdD,MAAAA,QAAQ,IAAIC,UAAU,CAACrC,KAAX,GAAmB+B,aAA/B;AACD;;AAED,QAAIhC,MAAM,GAAG,CAACqC,QAAD,GAAY,CAAzB;AACArE,IAAAA,MAAM,CAACoD,IAAP,CAAYQ,MAAZ,EAAoB,UAAUO,MAAV,EAAkBzC,OAAlB,EAA2B;AAC7CG,MAAAA,MAAM,CAACkC,YAAD,CAAN,CAAqBrC,OAArB,IAAgCG,MAAM,CAACkC,YAAD,CAAN,CAAqBrC,OAArB,KAAiC;AAC/DM,QAAAA,MAAM,EAAEA,MADuD;AAE/DC,QAAAA,KAAK,EAAEkC,MAAM,CAAClC;AAFiD,OAAjE;AAIAD,MAAAA,MAAM,IAAImC,MAAM,CAAClC,KAAP,IAAgB,IAAI+B,aAApB,CAAV;AACD,KAND;AAOD,GApDD;AAqDA,SAAOnC,MAAP;AACD;AACD;;;;;;;AAOA,SAAS0C,aAAT,CAAuBC,UAAvB,EAAmCC,OAAnC,EAA4C1D,GAA5C,EAAiD;AAC/C,MAAI2D,iBAAiB,GAAGxC,oBAAoB,CAAClC,MAAM,CAAC2E,MAAP,CAAcF,OAAO,CAACG,eAAR,CAAwBJ,UAAxB,CAAd,EAAmD,UAAUlE,WAAV,EAAuB;AACrH,WAAO,CAACmE,OAAO,CAACI,gBAAR,CAAyBvE,WAAzB,CAAD,IAA0CA,WAAW,CAACmC,gBAAtD,IAA0EnC,WAAW,CAACmC,gBAAZ,CAA6BtB,IAA7B,KAAsC,aAAvH;AACD,GAF4C,CAAD,CAA5C;AAGA,MAAI2D,eAAe,GAAG,EAAtB;AACA,MAAIC,qBAAqB,GAAG,EAA5B;AACAN,EAAAA,OAAO,CAACO,gBAAR,CAAyBR,UAAzB,EAAqC,UAAUlE,WAAV,EAAuB;AAC1D;AACA,QAAIA,WAAW,CAACmC,gBAAZ,CAA6BtB,IAA7B,KAAsC,aAA1C,EAAyD;AACvD;AACD;;AAED,QAAImB,IAAI,GAAGhC,WAAW,CAACiC,OAAZ,EAAX;AACA,QAAIC,SAAS,GAAGlC,WAAW,CAACmC,gBAA5B;AACA,QAAIxB,QAAQ,GAAGuB,SAAS,CAACE,WAAV,EAAf;AACA,QAAIhB,OAAO,GAAGrB,gBAAgB,CAACC,WAAD,CAA9B;AACA,QAAI2E,gBAAgB,GAAGP,iBAAiB,CAACjE,UAAU,CAACQ,QAAD,CAAX,CAAjB,CAAwCS,OAAxC,CAAvB;AACA,QAAIwD,YAAY,GAAGD,gBAAgB,CAACjD,MAApC;AACA,QAAImD,WAAW,GAAGF,gBAAgB,CAAChD,KAAnC;AACA,QAAImD,SAAS,GAAG5C,SAAS,CAAC6C,YAAV,CAAuBpE,QAAvB,CAAhB;AACA,QAAIqE,YAAY,GAAGhF,WAAW,CAACC,GAAZ,CAAgB,cAAhB,KAAmC,CAAtD;AACA,QAAIgF,cAAc,GAAGtE,QAAQ,CAACuE,MAAT,GAAkBJ,SAAS,CAACK,aAAV,CAAwBL,SAAS,CAACM,WAAV,CAAsB,CAAtB,CAAxB,CAAlB,GAAsEN,SAAS,CAACO,eAAV,GAA4B,CAA5B,CAA3F;AACA,QAAIC,SAAS,GAAG,CAACtF,WAAW,CAACuF,iBAAZ,CAA8B,GAA9B,EAAmC,CAAnC,CAAD,EAAwCvF,WAAW,CAACuF,iBAAZ,CAA8B,GAA9B,EAAmC,CAAnC,CAAxC,CAAhB;AACA,QAAIC,MAAM,GAAGxD,IAAI,CAACyD,QAAL,CAAcH,SAAd,EAAyB,UAAUI,CAAV,EAAaC,CAAb,EAAgB;AACpD,aAAOzD,SAAS,CAAC0D,WAAV,CAAsB,CAACF,CAAD,EAAIC,CAAJ,CAAtB,CAAP;AACD,KAFY,EAEV,IAFU,CAAb;AAGAnB,IAAAA,eAAe,CAACpD,OAAD,CAAf,GAA2BoD,eAAe,CAACpD,OAAD,CAAf,IAA4B,EAAvD;AACAqD,IAAAA,qBAAqB,CAACrD,OAAD,CAArB,GAAiCqD,qBAAqB,CAACrD,OAAD,CAArB,IAAkC,EAAnE,CArB0D,CAqBa;;AAEvEY,IAAAA,IAAI,CAAC6D,SAAL,CAAe;AACbnE,MAAAA,MAAM,EAAEkD,YADK;AAEbkB,MAAAA,IAAI,EAAEjB;AAFO,KAAf;AAIA7C,IAAAA,IAAI,CAACc,IAAL,CAAU9C,WAAW,CAACuF,iBAAZ,CAA8BT,SAAS,CAACzE,GAAxC,EAA6C,CAA7C,CAAV,EAA2D,UAAU0F,KAAV,EAAiB/C,GAAjB,EAAsB;AAC/E,UAAIgD,KAAK,CAACD,KAAD,CAAT,EAAkB;AAChB;AACD;;AAED,UAAI,CAACvB,eAAe,CAACpD,OAAD,CAAf,CAAyB4B,GAAzB,CAAL,EAAoC;AAClCwB,QAAAA,eAAe,CAACpD,OAAD,CAAf,CAAyB4B,GAAzB,IAAgC;AAC9BiD,UAAAA,CAAC,EAAEhB,cAD2B;AAE9B;AACAiB,UAAAA,CAAC,EAAEjB,cAH2B,CAGZ;;AAHY,SAAhC;AAMAR,QAAAA,qBAAqB,CAACrD,OAAD,CAArB,CAA+B4B,GAA/B,IAAsC;AACpCiD,UAAAA,CAAC,EAAEhB,cADiC;AAEpC;AACAiB,UAAAA,CAAC,EAAEjB,cAHiC,CAGlB;;AAHkB,SAAtC;AAMD;;AAED,UAAIkB,IAAI,GAAGJ,KAAK,IAAI,CAAT,GAAa,GAAb,GAAmB,GAA9B;AACA,UAAIK,KAAK,GAAGZ,MAAM,CAACxC,GAAD,CAAlB;AACA,UAAIqD,SAAS,GAAG7B,eAAe,CAACpD,OAAD,CAAf,CAAyB4B,GAAzB,EAA8BmD,IAA9B,CAAhB;AACA,UAAIG,eAAe,GAAG7B,qBAAqB,CAACrD,OAAD,CAArB,CAA+B4B,GAA/B,EAAoCmD,IAApC,CAAtB;AACA,UAAIT,CAAJ;AACA,UAAIC,CAAJ;AACA,UAAIhE,KAAJ;AACA,UAAI4E,MAAJ;;AAEA,UAAIzB,SAAS,CAAC0B,YAAV,EAAJ,EAA8B;AAC5Bd,QAAAA,CAAC,GAAGW,SAAJ;AACAV,QAAAA,CAAC,GAAGS,KAAK,CAAC,CAAD,CAAL,GAAWxB,YAAf;AACAjD,QAAAA,KAAK,GAAGyE,KAAK,CAAC,CAAD,CAAL,GAAWE,eAAnB;AACAC,QAAAA,MAAM,GAAG1B,WAAT;AACAJ,QAAAA,qBAAqB,CAACrD,OAAD,CAArB,CAA+B4B,GAA/B,EAAoCmD,IAApC,KAA6CxE,KAA7C;;AAEA,YAAIY,IAAI,CAACC,GAAL,CAASb,KAAT,IAAkBqD,YAAtB,EAAoC;AAClCrD,UAAAA,KAAK,GAAG,CAACA,KAAK,GAAG,CAAR,GAAY,CAAC,CAAb,GAAiB,CAAlB,IAAuBqD,YAA/B;AACD;;AAEDR,QAAAA,eAAe,CAACpD,OAAD,CAAf,CAAyB4B,GAAzB,EAA8BmD,IAA9B,KAAuCxE,KAAvC;AACD,OAZD,MAYO;AACL+D,QAAAA,CAAC,GAAGU,KAAK,CAAC,CAAD,CAAL,GAAWxB,YAAf;AACAe,QAAAA,CAAC,GAAGU,SAAJ;AACA1E,QAAAA,KAAK,GAAGkD,WAAR;AACA0B,QAAAA,MAAM,GAAGH,KAAK,CAAC,CAAD,CAAL,GAAWE,eAApB;AACA7B,QAAAA,qBAAqB,CAACrD,OAAD,CAArB,CAA+B4B,GAA/B,EAAoCmD,IAApC,KAA6CI,MAA7C;;AAEA,YAAIhE,IAAI,CAACC,GAAL,CAAS+D,MAAT,IAAmBvB,YAAvB,EAAqC;AACnC;AACAuB,UAAAA,MAAM,GAAG,CAACA,MAAM,IAAI,CAAV,GAAc,CAAC,CAAf,GAAmB,CAApB,IAAyBvB,YAAlC;AACD;;AAEDR,QAAAA,eAAe,CAACpD,OAAD,CAAf,CAAyB4B,GAAzB,EAA8BmD,IAA9B,KAAuCI,MAAvC;AACD;;AAEDvE,MAAAA,IAAI,CAACyE,aAAL,CAAmBzD,GAAnB,EAAwB;AACtB0C,QAAAA,CAAC,EAAEA,CADmB;AAEtBC,QAAAA,CAAC,EAAEA,CAFmB;AAGtBhE,QAAAA,KAAK,EAAEA,KAHe;AAItB4E,QAAAA,MAAM,EAAEA;AAJc,OAAxB;AAMD,KA9DD,EA8DG,IA9DH;AA+DD,GA1FD,EA0FG,IA1FH;AA2FD;;AAEDtC,aAAa,CAAC1D,eAAd,GAAgCA,eAAhC;AACA,IAAImG,QAAQ,GAAGzC,aAAf;AACA0C,MAAM,CAACC,OAAP,GAAiBF,QAAjB","sourcesContent":["var zrUtil = require(\"zrender/lib/core/util\");\n\nvar _number = require(\"../util/number\");\n\nvar parsePercent = _number.parsePercent;\nvar STACK_PREFIX = '__ec_stack_';\n\nfunction getSeriesStackId(seriesModel) {\n  return seriesModel.get('stack') || STACK_PREFIX + seriesModel.seriesIndex;\n}\n\nfunction getAxisKey(axis) {\n  return axis.dim + axis.index;\n}\n/**\n * @param {Object} opt\n * @param {module:echarts/coord/Axis} opt.axis Only support category axis currently.\n * @param {number} opt.count Positive interger.\n * @param {number} [opt.barWidth]\n * @param {number} [opt.barMaxWidth]\n * @param {number} [opt.barGap]\n * @param {number} [opt.barCategoryGap]\n * @return {Object} {width, offset, offsetCenter} If axis.type is not 'category', return undefined.\n */\n\n\nfunction getLayoutOnAxis(opt, api) {\n  var params = [];\n  var baseAxis = opt.axis;\n  var axisKey = 'axis0';\n\n  if (baseAxis.type !== 'category') {\n    return;\n  }\n\n  var bandWidth = baseAxis.getBandWidth();\n\n  for (var i = 0; i < opt.count || 0; i++) {\n    params.push(zrUtil.defaults({\n      bandWidth: bandWidth,\n      axisKey: axisKey,\n      stackId: STACK_PREFIX + i\n    }, opt));\n  }\n\n  var widthAndOffsets = doCalBarWidthAndOffset(params, api);\n  var result = [];\n\n  for (var i = 0; i < opt.count; i++) {\n    var item = widthAndOffsets[axisKey][STACK_PREFIX + i];\n    item.offsetCenter = item.offset + item.width / 2;\n    result.push(item);\n  }\n\n  return result;\n}\n\nfunction calBarWidthAndOffset(barSeries, api) {\n  var seriesInfoList = zrUtil.map(barSeries, function (seriesModel) {\n    var data = seriesModel.getData();\n    var cartesian = seriesModel.coordinateSystem;\n    var baseAxis = cartesian.getBaseAxis();\n    var axisExtent = baseAxis.getExtent();\n    var bandWidth = baseAxis.type === 'category' ? baseAxis.getBandWidth() : Math.abs(axisExtent[1] - axisExtent[0]) / data.count();\n    var barWidth = parsePercent(seriesModel.get('barWidth'), bandWidth);\n    var barMaxWidth = parsePercent(seriesModel.get('barMaxWidth'), bandWidth);\n    var barGap = seriesModel.get('barGap');\n    var barCategoryGap = seriesModel.get('barCategoryGap');\n    return {\n      bandWidth: bandWidth,\n      barWidth: barWidth,\n      barMaxWidth: barMaxWidth,\n      barGap: barGap,\n      barCategoryGap: barCategoryGap,\n      axisKey: getAxisKey(baseAxis),\n      stackId: getSeriesStackId(seriesModel)\n    };\n  });\n  return doCalBarWidthAndOffset(seriesInfoList, api);\n}\n\nfunction doCalBarWidthAndOffset(seriesInfoList, api) {\n  // Columns info on each category axis. Key is cartesian name\n  var columnsMap = {};\n  zrUtil.each(seriesInfoList, function (seriesInfo, idx) {\n    var axisKey = seriesInfo.axisKey;\n    var bandWidth = seriesInfo.bandWidth;\n    var columnsOnAxis = columnsMap[axisKey] || {\n      bandWidth: bandWidth,\n      remainedWidth: bandWidth,\n      autoWidthCount: 0,\n      categoryGap: '20%',\n      gap: '30%',\n      stacks: {}\n    };\n    var stacks = columnsOnAxis.stacks;\n    columnsMap[axisKey] = columnsOnAxis;\n    var stackId = seriesInfo.stackId;\n\n    if (!stacks[stackId]) {\n      columnsOnAxis.autoWidthCount++;\n    }\n\n    stacks[stackId] = stacks[stackId] || {\n      width: 0,\n      maxWidth: 0\n    }; // Caution: In a single coordinate system, these barGrid attributes\n    // will be shared by series. Consider that they have default values,\n    // only the attributes set on the last series will work.\n    // Do not change this fact unless there will be a break change.\n    // TODO\n\n    var barWidth = seriesInfo.barWidth;\n\n    if (barWidth && !stacks[stackId].width) {\n      // See #6312, do not restrict width.\n      stacks[stackId].width = barWidth;\n      barWidth = Math.min(columnsOnAxis.remainedWidth, barWidth);\n      columnsOnAxis.remainedWidth -= barWidth;\n    }\n\n    var barMaxWidth = seriesInfo.barMaxWidth;\n    barMaxWidth && (stacks[stackId].maxWidth = barMaxWidth);\n    var barGap = seriesInfo.barGap;\n    barGap != null && (columnsOnAxis.gap = barGap);\n    var barCategoryGap = seriesInfo.barCategoryGap;\n    barCategoryGap != null && (columnsOnAxis.categoryGap = barCategoryGap);\n  });\n  var result = {};\n  zrUtil.each(columnsMap, function (columnsOnAxis, coordSysName) {\n    result[coordSysName] = {};\n    var stacks = columnsOnAxis.stacks;\n    var bandWidth = columnsOnAxis.bandWidth;\n    var categoryGap = parsePercent(columnsOnAxis.categoryGap, bandWidth);\n    var barGapPercent = parsePercent(columnsOnAxis.gap, 1);\n    var remainedWidth = columnsOnAxis.remainedWidth;\n    var autoWidthCount = columnsOnAxis.autoWidthCount;\n    var autoWidth = (remainedWidth - categoryGap) / (autoWidthCount + (autoWidthCount - 1) * barGapPercent);\n    autoWidth = Math.max(autoWidth, 0); // Find if any auto calculated bar exceeded maxBarWidth\n\n    zrUtil.each(stacks, function (column, stack) {\n      var maxWidth = column.maxWidth;\n\n      if (maxWidth && maxWidth < autoWidth) {\n        maxWidth = Math.min(maxWidth, remainedWidth);\n\n        if (column.width) {\n          maxWidth = Math.min(maxWidth, column.width);\n        }\n\n        remainedWidth -= maxWidth;\n        column.width = maxWidth;\n        autoWidthCount--;\n      }\n    }); // Recalculate width again\n\n    autoWidth = (remainedWidth - categoryGap) / (autoWidthCount + (autoWidthCount - 1) * barGapPercent);\n    autoWidth = Math.max(autoWidth, 0);\n    var widthSum = 0;\n    var lastColumn;\n    zrUtil.each(stacks, function (column, idx) {\n      if (!column.width) {\n        column.width = autoWidth;\n      }\n\n      lastColumn = column;\n      widthSum += column.width * (1 + barGapPercent);\n    });\n\n    if (lastColumn) {\n      widthSum -= lastColumn.width * barGapPercent;\n    }\n\n    var offset = -widthSum / 2;\n    zrUtil.each(stacks, function (column, stackId) {\n      result[coordSysName][stackId] = result[coordSysName][stackId] || {\n        offset: offset,\n        width: column.width\n      };\n      offset += column.width * (1 + barGapPercent);\n    });\n  });\n  return result;\n}\n/**\n * @param {string} seriesType\n * @param {module:echarts/model/Global} ecModel\n * @param {module:echarts/ExtensionAPI} api\n */\n\n\nfunction barLayoutGrid(seriesType, ecModel, api) {\n  var barWidthAndOffset = calBarWidthAndOffset(zrUtil.filter(ecModel.getSeriesByType(seriesType), function (seriesModel) {\n    return !ecModel.isSeriesFiltered(seriesModel) && seriesModel.coordinateSystem && seriesModel.coordinateSystem.type === 'cartesian2d';\n  }));\n  var lastStackCoords = {};\n  var lastStackCoordsOrigin = {};\n  ecModel.eachSeriesByType(seriesType, function (seriesModel) {\n    // Check series coordinate, do layout for cartesian2d only\n    if (seriesModel.coordinateSystem.type !== 'cartesian2d') {\n      return;\n    }\n\n    var data = seriesModel.getData();\n    var cartesian = seriesModel.coordinateSystem;\n    var baseAxis = cartesian.getBaseAxis();\n    var stackId = getSeriesStackId(seriesModel);\n    var columnLayoutInfo = barWidthAndOffset[getAxisKey(baseAxis)][stackId];\n    var columnOffset = columnLayoutInfo.offset;\n    var columnWidth = columnLayoutInfo.width;\n    var valueAxis = cartesian.getOtherAxis(baseAxis);\n    var barMinHeight = seriesModel.get('barMinHeight') || 0;\n    var valueAxisStart = baseAxis.onZero ? valueAxis.toGlobalCoord(valueAxis.dataToCoord(0)) : valueAxis.getGlobalExtent()[0];\n    var coordDims = [seriesModel.coordDimToDataDim('x')[0], seriesModel.coordDimToDataDim('y')[0]];\n    var coords = data.mapArray(coordDims, function (x, y) {\n      return cartesian.dataToPoint([x, y]);\n    }, true);\n    lastStackCoords[stackId] = lastStackCoords[stackId] || [];\n    lastStackCoordsOrigin[stackId] = lastStackCoordsOrigin[stackId] || []; // Fix #4243\n\n    data.setLayout({\n      offset: columnOffset,\n      size: columnWidth\n    });\n    data.each(seriesModel.coordDimToDataDim(valueAxis.dim)[0], function (value, idx) {\n      if (isNaN(value)) {\n        return;\n      }\n\n      if (!lastStackCoords[stackId][idx]) {\n        lastStackCoords[stackId][idx] = {\n          p: valueAxisStart,\n          // Positive stack\n          n: valueAxisStart // Negative stack\n\n        };\n        lastStackCoordsOrigin[stackId][idx] = {\n          p: valueAxisStart,\n          // Positive stack\n          n: valueAxisStart // Negative stack\n\n        };\n      }\n\n      var sign = value >= 0 ? 'p' : 'n';\n      var coord = coords[idx];\n      var lastCoord = lastStackCoords[stackId][idx][sign];\n      var lastCoordOrigin = lastStackCoordsOrigin[stackId][idx][sign];\n      var x;\n      var y;\n      var width;\n      var height;\n\n      if (valueAxis.isHorizontal()) {\n        x = lastCoord;\n        y = coord[1] + columnOffset;\n        width = coord[0] - lastCoordOrigin;\n        height = columnWidth;\n        lastStackCoordsOrigin[stackId][idx][sign] += width;\n\n        if (Math.abs(width) < barMinHeight) {\n          width = (width < 0 ? -1 : 1) * barMinHeight;\n        }\n\n        lastStackCoords[stackId][idx][sign] += width;\n      } else {\n        x = coord[0] + columnOffset;\n        y = lastCoord;\n        width = columnWidth;\n        height = coord[1] - lastCoordOrigin;\n        lastStackCoordsOrigin[stackId][idx][sign] += height;\n\n        if (Math.abs(height) < barMinHeight) {\n          // Include zero to has a positive bar\n          height = (height <= 0 ? -1 : 1) * barMinHeight;\n        }\n\n        lastStackCoords[stackId][idx][sign] += height;\n      }\n\n      data.setItemLayout(idx, {\n        x: x,\n        y: y,\n        width: width,\n        height: height\n      });\n    }, true);\n  }, this);\n}\n\nbarLayoutGrid.getLayoutOnAxis = getLayoutOnAxis;\nvar _default = barLayoutGrid;\nmodule.exports = _default;"]},"metadata":{},"sourceType":"script"}