{"ast":null,"code":"var matrix = require(\"../core/matrix\");\n\nvar vector = require(\"../core/vector\");\n/**\n * 提供变换扩展\n * @module zrender/mixin/Transformable\n * @author pissang (https://www.github.com/pissang)\n */\n\n\nvar mIdentity = matrix.identity;\nvar EPSILON = 5e-5;\n\nfunction isNotAroundZero(val) {\n  return val > EPSILON || val < -EPSILON;\n}\n/**\n * @alias module:zrender/mixin/Transformable\n * @constructor\n */\n\n\nvar Transformable = function (opts) {\n  opts = opts || {}; // If there are no given position, rotation, scale\n\n  if (!opts.position) {\n    /**\n     * 平移\n     * @type {Array.<number>}\n     * @default [0, 0]\n     */\n    this.position = [0, 0];\n  }\n\n  if (opts.rotation == null) {\n    /**\n     * 旋转\n     * @type {Array.<number>}\n     * @default 0\n     */\n    this.rotation = 0;\n  }\n\n  if (!opts.scale) {\n    /**\n     * 缩放\n     * @type {Array.<number>}\n     * @default [1, 1]\n     */\n    this.scale = [1, 1];\n  }\n  /**\n   * 旋转和缩放的原点\n   * @type {Array.<number>}\n   * @default null\n   */\n\n\n  this.origin = this.origin || null;\n};\n\nvar transformableProto = Transformable.prototype;\ntransformableProto.transform = null;\n/**\n * 判断是否需要有坐标变换\n * 如果有坐标变换, 则从position, rotation, scale以及父节点的transform计算出自身的transform矩阵\n */\n\ntransformableProto.needLocalTransform = function () {\n  return isNotAroundZero(this.rotation) || isNotAroundZero(this.position[0]) || isNotAroundZero(this.position[1]) || isNotAroundZero(this.scale[0] - 1) || isNotAroundZero(this.scale[1] - 1);\n};\n\ntransformableProto.updateTransform = function () {\n  var parent = this.parent;\n  var parentHasTransform = parent && parent.transform;\n  var needLocalTransform = this.needLocalTransform();\n  var m = this.transform;\n\n  if (!(needLocalTransform || parentHasTransform)) {\n    m && mIdentity(m);\n    return;\n  }\n\n  m = m || matrix.create();\n\n  if (needLocalTransform) {\n    this.getLocalTransform(m);\n  } else {\n    mIdentity(m);\n  } // 应用父节点变换\n\n\n  if (parentHasTransform) {\n    if (needLocalTransform) {\n      matrix.mul(m, parent.transform, m);\n    } else {\n      matrix.copy(m, parent.transform);\n    }\n  } // 保存这个变换矩阵\n\n\n  this.transform = m;\n  this.invTransform = this.invTransform || matrix.create();\n  matrix.invert(this.invTransform, m);\n};\n\ntransformableProto.getLocalTransform = function (m) {\n  return Transformable.getLocalTransform(this, m);\n};\n/**\n * 将自己的transform应用到context上\n * @param {CanvasRenderingContext2D} ctx\n */\n\n\ntransformableProto.setTransform = function (ctx) {\n  var m = this.transform;\n  var dpr = ctx.dpr || 1;\n\n  if (m) {\n    ctx.setTransform(dpr * m[0], dpr * m[1], dpr * m[2], dpr * m[3], dpr * m[4], dpr * m[5]);\n  } else {\n    ctx.setTransform(dpr, 0, 0, dpr, 0, 0);\n  }\n};\n\ntransformableProto.restoreTransform = function (ctx) {\n  var dpr = ctx.dpr || 1;\n  ctx.setTransform(dpr, 0, 0, dpr, 0, 0);\n};\n\nvar tmpTransform = [];\n/**\n * 分解`transform`矩阵到`position`, `rotation`, `scale`\n */\n\ntransformableProto.decomposeTransform = function () {\n  if (!this.transform) {\n    return;\n  }\n\n  var parent = this.parent;\n  var m = this.transform;\n\n  if (parent && parent.transform) {\n    // Get local transform and decompose them to position, scale, rotation\n    matrix.mul(tmpTransform, parent.invTransform, m);\n    m = tmpTransform;\n  }\n\n  var sx = m[0] * m[0] + m[1] * m[1];\n  var sy = m[2] * m[2] + m[3] * m[3];\n  var position = this.position;\n  var scale = this.scale;\n\n  if (isNotAroundZero(sx - 1)) {\n    sx = Math.sqrt(sx);\n  }\n\n  if (isNotAroundZero(sy - 1)) {\n    sy = Math.sqrt(sy);\n  }\n\n  if (m[0] < 0) {\n    sx = -sx;\n  }\n\n  if (m[3] < 0) {\n    sy = -sy;\n  }\n\n  position[0] = m[4];\n  position[1] = m[5];\n  scale[0] = sx;\n  scale[1] = sy;\n  this.rotation = Math.atan2(-m[1] / sy, m[0] / sx);\n};\n/**\n * Get global scale\n * @return {Array.<number>}\n */\n\n\ntransformableProto.getGlobalScale = function () {\n  var m = this.transform;\n\n  if (!m) {\n    return [1, 1];\n  }\n\n  var sx = Math.sqrt(m[0] * m[0] + m[1] * m[1]);\n  var sy = Math.sqrt(m[2] * m[2] + m[3] * m[3]);\n\n  if (m[0] < 0) {\n    sx = -sx;\n  }\n\n  if (m[3] < 0) {\n    sy = -sy;\n  }\n\n  return [sx, sy];\n};\n/**\n * 变换坐标位置到 shape 的局部坐标空间\n * @method\n * @param {number} x\n * @param {number} y\n * @return {Array.<number>}\n */\n\n\ntransformableProto.transformCoordToLocal = function (x, y) {\n  var v2 = [x, y];\n  var invTransform = this.invTransform;\n\n  if (invTransform) {\n    vector.applyTransform(v2, v2, invTransform);\n  }\n\n  return v2;\n};\n/**\n * 变换局部坐标位置到全局坐标空间\n * @method\n * @param {number} x\n * @param {number} y\n * @return {Array.<number>}\n */\n\n\ntransformableProto.transformCoordToGlobal = function (x, y) {\n  var v2 = [x, y];\n  var transform = this.transform;\n\n  if (transform) {\n    vector.applyTransform(v2, v2, transform);\n  }\n\n  return v2;\n};\n/**\n * @static\n * @param {Object} target\n * @param {Array.<number>} target.origin\n * @param {number} target.rotation\n * @param {Array.<number>} target.position\n * @param {Array.<number>} [m]\n */\n\n\nTransformable.getLocalTransform = function (target, m) {\n  m = m || [];\n  mIdentity(m);\n  var origin = target.origin;\n  var scale = target.scale || [1, 1];\n  var rotation = target.rotation || 0;\n  var position = target.position || [0, 0];\n\n  if (origin) {\n    // Translate to origin\n    m[4] -= origin[0];\n    m[5] -= origin[1];\n  }\n\n  matrix.scale(m, m, scale);\n\n  if (rotation) {\n    matrix.rotate(m, m, rotation);\n  }\n\n  if (origin) {\n    // Translate back from origin\n    m[4] += origin[0];\n    m[5] += origin[1];\n  }\n\n  m[4] += position[0];\n  m[5] += position[1];\n  return m;\n};\n\nvar _default = Transformable;\nmodule.exports = _default;","map":{"version":3,"sources":["/home/martin/Escritorio/Taller de Integracion/Tarea3-TallerDeIntegracion/node_modules/react-echarts/node_modules/zrender/lib/mixin/Transformable.js"],"names":["matrix","require","vector","mIdentity","identity","EPSILON","isNotAroundZero","val","Transformable","opts","position","rotation","scale","origin","transformableProto","prototype","transform","needLocalTransform","updateTransform","parent","parentHasTransform","m","create","getLocalTransform","mul","copy","invTransform","invert","setTransform","ctx","dpr","restoreTransform","tmpTransform","decomposeTransform","sx","sy","Math","sqrt","atan2","getGlobalScale","transformCoordToLocal","x","y","v2","applyTransform","transformCoordToGlobal","target","rotate","_default","module","exports"],"mappings":"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","sourcesContent":["var matrix = require(\"../core/matrix\");\n\nvar vector = require(\"../core/vector\");\n\n/**\n * 提供变换扩展\n * @module zrender/mixin/Transformable\n * @author pissang (https://www.github.com/pissang)\n */\nvar mIdentity = matrix.identity;\nvar EPSILON = 5e-5;\n\nfunction isNotAroundZero(val) {\n  return val > EPSILON || val < -EPSILON;\n}\n/**\n * @alias module:zrender/mixin/Transformable\n * @constructor\n */\n\n\nvar Transformable = function (opts) {\n  opts = opts || {}; // If there are no given position, rotation, scale\n\n  if (!opts.position) {\n    /**\n     * 平移\n     * @type {Array.<number>}\n     * @default [0, 0]\n     */\n    this.position = [0, 0];\n  }\n\n  if (opts.rotation == null) {\n    /**\n     * 旋转\n     * @type {Array.<number>}\n     * @default 0\n     */\n    this.rotation = 0;\n  }\n\n  if (!opts.scale) {\n    /**\n     * 缩放\n     * @type {Array.<number>}\n     * @default [1, 1]\n     */\n    this.scale = [1, 1];\n  }\n  /**\n   * 旋转和缩放的原点\n   * @type {Array.<number>}\n   * @default null\n   */\n\n\n  this.origin = this.origin || null;\n};\n\nvar transformableProto = Transformable.prototype;\ntransformableProto.transform = null;\n/**\n * 判断是否需要有坐标变换\n * 如果有坐标变换, 则从position, rotation, scale以及父节点的transform计算出自身的transform矩阵\n */\n\ntransformableProto.needLocalTransform = function () {\n  return isNotAroundZero(this.rotation) || isNotAroundZero(this.position[0]) || isNotAroundZero(this.position[1]) || isNotAroundZero(this.scale[0] - 1) || isNotAroundZero(this.scale[1] - 1);\n};\n\ntransformableProto.updateTransform = function () {\n  var parent = this.parent;\n  var parentHasTransform = parent && parent.transform;\n  var needLocalTransform = this.needLocalTransform();\n  var m = this.transform;\n\n  if (!(needLocalTransform || parentHasTransform)) {\n    m && mIdentity(m);\n    return;\n  }\n\n  m = m || matrix.create();\n\n  if (needLocalTransform) {\n    this.getLocalTransform(m);\n  } else {\n    mIdentity(m);\n  } // 应用父节点变换\n\n\n  if (parentHasTransform) {\n    if (needLocalTransform) {\n      matrix.mul(m, parent.transform, m);\n    } else {\n      matrix.copy(m, parent.transform);\n    }\n  } // 保存这个变换矩阵\n\n\n  this.transform = m;\n  this.invTransform = this.invTransform || matrix.create();\n  matrix.invert(this.invTransform, m);\n};\n\ntransformableProto.getLocalTransform = function (m) {\n  return Transformable.getLocalTransform(this, m);\n};\n/**\n * 将自己的transform应用到context上\n * @param {CanvasRenderingContext2D} ctx\n */\n\n\ntransformableProto.setTransform = function (ctx) {\n  var m = this.transform;\n  var dpr = ctx.dpr || 1;\n\n  if (m) {\n    ctx.setTransform(dpr * m[0], dpr * m[1], dpr * m[2], dpr * m[3], dpr * m[4], dpr * m[5]);\n  } else {\n    ctx.setTransform(dpr, 0, 0, dpr, 0, 0);\n  }\n};\n\ntransformableProto.restoreTransform = function (ctx) {\n  var dpr = ctx.dpr || 1;\n  ctx.setTransform(dpr, 0, 0, dpr, 0, 0);\n};\n\nvar tmpTransform = [];\n/**\n * 分解`transform`矩阵到`position`, `rotation`, `scale`\n */\n\ntransformableProto.decomposeTransform = function () {\n  if (!this.transform) {\n    return;\n  }\n\n  var parent = this.parent;\n  var m = this.transform;\n\n  if (parent && parent.transform) {\n    // Get local transform and decompose them to position, scale, rotation\n    matrix.mul(tmpTransform, parent.invTransform, m);\n    m = tmpTransform;\n  }\n\n  var sx = m[0] * m[0] + m[1] * m[1];\n  var sy = m[2] * m[2] + m[3] * m[3];\n  var position = this.position;\n  var scale = this.scale;\n\n  if (isNotAroundZero(sx - 1)) {\n    sx = Math.sqrt(sx);\n  }\n\n  if (isNotAroundZero(sy - 1)) {\n    sy = Math.sqrt(sy);\n  }\n\n  if (m[0] < 0) {\n    sx = -sx;\n  }\n\n  if (m[3] < 0) {\n    sy = -sy;\n  }\n\n  position[0] = m[4];\n  position[1] = m[5];\n  scale[0] = sx;\n  scale[1] = sy;\n  this.rotation = Math.atan2(-m[1] / sy, m[0] / sx);\n};\n/**\n * Get global scale\n * @return {Array.<number>}\n */\n\n\ntransformableProto.getGlobalScale = function () {\n  var m = this.transform;\n\n  if (!m) {\n    return [1, 1];\n  }\n\n  var sx = Math.sqrt(m[0] * m[0] + m[1] * m[1]);\n  var sy = Math.sqrt(m[2] * m[2] + m[3] * m[3]);\n\n  if (m[0] < 0) {\n    sx = -sx;\n  }\n\n  if (m[3] < 0) {\n    sy = -sy;\n  }\n\n  return [sx, sy];\n};\n/**\n * 变换坐标位置到 shape 的局部坐标空间\n * @method\n * @param {number} x\n * @param {number} y\n * @return {Array.<number>}\n */\n\n\ntransformableProto.transformCoordToLocal = function (x, y) {\n  var v2 = [x, y];\n  var invTransform = this.invTransform;\n\n  if (invTransform) {\n    vector.applyTransform(v2, v2, invTransform);\n  }\n\n  return v2;\n};\n/**\n * 变换局部坐标位置到全局坐标空间\n * @method\n * @param {number} x\n * @param {number} y\n * @return {Array.<number>}\n */\n\n\ntransformableProto.transformCoordToGlobal = function (x, y) {\n  var v2 = [x, y];\n  var transform = this.transform;\n\n  if (transform) {\n    vector.applyTransform(v2, v2, transform);\n  }\n\n  return v2;\n};\n/**\n * @static\n * @param {Object} target\n * @param {Array.<number>} target.origin\n * @param {number} target.rotation\n * @param {Array.<number>} target.position\n * @param {Array.<number>} [m]\n */\n\n\nTransformable.getLocalTransform = function (target, m) {\n  m = m || [];\n  mIdentity(m);\n  var origin = target.origin;\n  var scale = target.scale || [1, 1];\n  var rotation = target.rotation || 0;\n  var position = target.position || [0, 0];\n\n  if (origin) {\n    // Translate to origin\n    m[4] -= origin[0];\n    m[5] -= origin[1];\n  }\n\n  matrix.scale(m, m, scale);\n\n  if (rotation) {\n    matrix.rotate(m, m, rotation);\n  }\n\n  if (origin) {\n    // Translate back from origin\n    m[4] += origin[0];\n    m[5] += origin[1];\n  }\n\n  m[4] += position[0];\n  m[5] += position[1];\n  return m;\n};\n\nvar _default = Transformable;\nmodule.exports = _default;"]},"metadata":{},"sourceType":"script"}