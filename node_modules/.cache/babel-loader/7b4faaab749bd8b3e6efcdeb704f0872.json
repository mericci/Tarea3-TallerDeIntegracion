{"ast":null,"code":"var zrUtil = require(\"zrender/lib/core/util\");\n\nvar _number = require(\"../util/number\");\n\nvar parsePercent = _number.parsePercent;\n\nfunction getSeriesStackId(seriesModel) {\n  return seriesModel.get('stack') || '__ec_stack_' + seriesModel.seriesIndex;\n}\n\nfunction getAxisKey(axis) {\n  return axis.dim;\n}\n/**\n * @param {string} seriesType\n * @param {module:echarts/model/Global} ecModel\n * @param {module:echarts/ExtensionAPI} api\n */\n\n\nfunction barLayoutPolar(seriesType, ecModel, api) {\n  var width = api.getWidth();\n  var height = api.getHeight();\n  var lastStackCoords = {};\n  var lastStackCoordsOrigin = {};\n  var barWidthAndOffset = calRadialBar(zrUtil.filter(ecModel.getSeriesByType(seriesType), function (seriesModel) {\n    return !ecModel.isSeriesFiltered(seriesModel) && seriesModel.coordinateSystem && seriesModel.coordinateSystem.type === 'polar';\n  }));\n  ecModel.eachSeriesByType(seriesType, function (seriesModel) {\n    // Check series coordinate, do layout for polar only\n    if (seriesModel.coordinateSystem.type !== 'polar') {\n      return;\n    }\n\n    var data = seriesModel.getData();\n    var polar = seriesModel.coordinateSystem;\n    var angleAxis = polar.getAngleAxis();\n    var baseAxis = polar.getBaseAxis();\n    var stackId = getSeriesStackId(seriesModel);\n    var columnLayoutInfo = barWidthAndOffset[getAxisKey(baseAxis)][stackId];\n    var columnOffset = columnLayoutInfo.offset;\n    var columnWidth = columnLayoutInfo.width;\n    var valueAxis = polar.getOtherAxis(baseAxis);\n    var center = seriesModel.get('center') || ['50%', '50%'];\n    var cx = parsePercent(center[0], width);\n    var cy = parsePercent(center[1], height);\n    var barMinHeight = seriesModel.get('barMinHeight') || 0;\n    var barMinAngle = seriesModel.get('barMinAngle') || 0;\n    var valueAxisStart = valueAxis.getExtent()[0];\n    var valueMax = valueAxis.model.get('max');\n    var valueMin = valueAxis.model.get('min');\n    var coordDims = [seriesModel.coordDimToDataDim('radius')[0], seriesModel.coordDimToDataDim('angle')[0]];\n    var coords = data.mapArray(coordDims, function (radius, angle) {\n      return polar.dataToPoint([radius, angle]);\n    }, true);\n    lastStackCoords[stackId] = lastStackCoords[stackId] || [];\n    lastStackCoordsOrigin[stackId] = lastStackCoordsOrigin[stackId] || []; // Fix #4243\n\n    data.each(seriesModel.coordDimToDataDim(valueAxis.dim)[0], function (value, idx) {\n      if (isNaN(value)) {\n        return;\n      }\n\n      if (!lastStackCoords[stackId][idx]) {\n        lastStackCoords[stackId][idx] = {\n          p: valueAxisStart,\n          // Positive stack\n          n: valueAxisStart // Negative stack\n\n        };\n        lastStackCoordsOrigin[stackId][idx] = {\n          p: valueAxisStart,\n          // Positive stack\n          n: valueAxisStart // Negative stack\n\n        };\n      }\n\n      var sign = value >= 0 ? 'p' : 'n';\n      var coord = polar.pointToCoord(coords[idx]);\n      var lastCoordOrigin = lastStackCoordsOrigin[stackId][idx][sign];\n      var r0;\n      var r;\n      var startAngle;\n      var endAngle;\n\n      if (valueAxis.dim === 'radius') {\n        // radial sector\n        r0 = lastCoordOrigin;\n        r = coord[0];\n        startAngle = (-coord[1] + columnOffset) * Math.PI / 180;\n        endAngle = startAngle + columnWidth * Math.PI / 180;\n\n        if (Math.abs(r) < barMinHeight) {\n          r = r0 + (r < 0 ? -1 : 1) * barMinHeight;\n        }\n\n        lastStackCoordsOrigin[stackId][idx][sign] = r;\n      } else {\n        // tangential sector\n        r0 = coord[0] + columnOffset;\n        r = r0 + columnWidth; // clamp data if min or max is defined for valueAxis\n\n        if (valueMax != null) {\n          value = Math.min(value, valueMax);\n        }\n\n        if (valueMin != null) {\n          value = Math.max(value, valueMin);\n        }\n\n        var angle = angleAxis.dataToAngle(value);\n\n        if (Math.abs(angle - lastCoordOrigin) < barMinAngle) {\n          angle = lastCoordOrigin - (value < 0 ? -1 : 1) * barMinAngle;\n        }\n\n        startAngle = -lastCoordOrigin * Math.PI / 180;\n        endAngle = -angle * Math.PI / 180; // if the previous stack is at the end of the ring,\n        // add a round to differentiate it from origin\n\n        var extent = angleAxis.getExtent();\n        var stackCoord = angle;\n\n        if (stackCoord === extent[0] && value > 0) {\n          stackCoord = extent[1];\n        } else if (stackCoord === extent[1] && value < 0) {\n          stackCoord = extent[0];\n        }\n\n        lastStackCoordsOrigin[stackId][idx][sign] = stackCoord;\n      }\n\n      data.setItemLayout(idx, {\n        cx: cx,\n        cy: cy,\n        r0: r0,\n        r: r,\n        startAngle: startAngle,\n        endAngle: endAngle\n      });\n    }, true);\n  }, this);\n}\n/**\n * Calculate bar width and offset for radial bar charts\n */\n\n\nfunction calRadialBar(barSeries, api) {\n  // Columns info on each category axis. Key is polar name\n  var columnsMap = {};\n  zrUtil.each(barSeries, function (seriesModel, idx) {\n    var data = seriesModel.getData();\n    var polar = seriesModel.coordinateSystem;\n    var baseAxis = polar.getBaseAxis();\n    var axisExtent = baseAxis.getExtent();\n    var bandWidth = baseAxis.type === 'category' ? baseAxis.getBandWidth() : Math.abs(axisExtent[1] - axisExtent[0]) / data.count();\n    var columnsOnAxis = columnsMap[getAxisKey(baseAxis)] || {\n      bandWidth: bandWidth,\n      remainedWidth: bandWidth,\n      autoWidthCount: 0,\n      categoryGap: '20%',\n      gap: '30%',\n      stacks: {}\n    };\n    var stacks = columnsOnAxis.stacks;\n    columnsMap[getAxisKey(baseAxis)] = columnsOnAxis;\n    var stackId = getSeriesStackId(seriesModel);\n\n    if (!stacks[stackId]) {\n      columnsOnAxis.autoWidthCount++;\n    }\n\n    stacks[stackId] = stacks[stackId] || {\n      width: 0,\n      maxWidth: 0\n    };\n    var barWidth = parsePercent(seriesModel.get('barWidth'), bandWidth);\n    var barMaxWidth = parsePercent(seriesModel.get('barMaxWidth'), bandWidth);\n    var barGap = seriesModel.get('barGap');\n    var barCategoryGap = seriesModel.get('barCategoryGap');\n\n    if (barWidth && !stacks[stackId].width) {\n      barWidth = Math.min(columnsOnAxis.remainedWidth, barWidth);\n      stacks[stackId].width = barWidth;\n      columnsOnAxis.remainedWidth -= barWidth;\n    }\n\n    barMaxWidth && (stacks[stackId].maxWidth = barMaxWidth);\n    barGap != null && (columnsOnAxis.gap = barGap);\n    barCategoryGap != null && (columnsOnAxis.categoryGap = barCategoryGap);\n  });\n  var result = {};\n  zrUtil.each(columnsMap, function (columnsOnAxis, coordSysName) {\n    result[coordSysName] = {};\n    var stacks = columnsOnAxis.stacks;\n    var bandWidth = columnsOnAxis.bandWidth;\n    var categoryGap = parsePercent(columnsOnAxis.categoryGap, bandWidth);\n    var barGapPercent = parsePercent(columnsOnAxis.gap, 1);\n    var remainedWidth = columnsOnAxis.remainedWidth;\n    var autoWidthCount = columnsOnAxis.autoWidthCount;\n    var autoWidth = (remainedWidth - categoryGap) / (autoWidthCount + (autoWidthCount - 1) * barGapPercent);\n    autoWidth = Math.max(autoWidth, 0); // Find if any auto calculated bar exceeded maxBarWidth\n\n    zrUtil.each(stacks, function (column, stack) {\n      var maxWidth = column.maxWidth;\n\n      if (maxWidth && maxWidth < autoWidth) {\n        maxWidth = Math.min(maxWidth, remainedWidth);\n\n        if (column.width) {\n          maxWidth = Math.min(maxWidth, column.width);\n        }\n\n        remainedWidth -= maxWidth;\n        column.width = maxWidth;\n        autoWidthCount--;\n      }\n    }); // Recalculate width again\n\n    autoWidth = (remainedWidth - categoryGap) / (autoWidthCount + (autoWidthCount - 1) * barGapPercent);\n    autoWidth = Math.max(autoWidth, 0);\n    var widthSum = 0;\n    var lastColumn;\n    zrUtil.each(stacks, function (column, idx) {\n      if (!column.width) {\n        column.width = autoWidth;\n      }\n\n      lastColumn = column;\n      widthSum += column.width * (1 + barGapPercent);\n    });\n\n    if (lastColumn) {\n      widthSum -= lastColumn.width * barGapPercent;\n    }\n\n    var offset = -widthSum / 2;\n    zrUtil.each(stacks, function (column, stackId) {\n      result[coordSysName][stackId] = result[coordSysName][stackId] || {\n        offset: offset,\n        width: column.width\n      };\n      offset += column.width * (1 + barGapPercent);\n    });\n  });\n  return result;\n}\n\nvar _default = barLayoutPolar;\nmodule.exports = _default;","map":{"version":3,"sources":["/home/martin/Escritorio/Taller de Integracion/Tarea3-TallerDeIntegracion/node_modules/react-echarts/node_modules/echarts/lib/layout/barPolar.js"],"names":["zrUtil","require","_number","parsePercent","getSeriesStackId","seriesModel","get","seriesIndex","getAxisKey","axis","dim","barLayoutPolar","seriesType","ecModel","api","width","getWidth","height","getHeight","lastStackCoords","lastStackCoordsOrigin","barWidthAndOffset","calRadialBar","filter","getSeriesByType","isSeriesFiltered","coordinateSystem","type","eachSeriesByType","data","getData","polar","angleAxis","getAngleAxis","baseAxis","getBaseAxis","stackId","columnLayoutInfo","columnOffset","offset","columnWidth","valueAxis","getOtherAxis","center","cx","cy","barMinHeight","barMinAngle","valueAxisStart","getExtent","valueMax","model","valueMin","coordDims","coordDimToDataDim","coords","mapArray","radius","angle","dataToPoint","each","value","idx","isNaN","p","n","sign","coord","pointToCoord","lastCoordOrigin","r0","r","startAngle","endAngle","Math","PI","abs","min","max","dataToAngle","extent","stackCoord","setItemLayout","barSeries","columnsMap","axisExtent","bandWidth","getBandWidth","count","columnsOnAxis","remainedWidth","autoWidthCount","categoryGap","gap","stacks","maxWidth","barWidth","barMaxWidth","barGap","barCategoryGap","result","coordSysName","barGapPercent","autoWidth","column","stack","widthSum","lastColumn","_default","module","exports"],"mappings":"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","sourcesContent":["var zrUtil = require(\"zrender/lib/core/util\");\n\nvar _number = require(\"../util/number\");\n\nvar parsePercent = _number.parsePercent;\n\nfunction getSeriesStackId(seriesModel) {\n  return seriesModel.get('stack') || '__ec_stack_' + seriesModel.seriesIndex;\n}\n\nfunction getAxisKey(axis) {\n  return axis.dim;\n}\n/**\n * @param {string} seriesType\n * @param {module:echarts/model/Global} ecModel\n * @param {module:echarts/ExtensionAPI} api\n */\n\n\nfunction barLayoutPolar(seriesType, ecModel, api) {\n  var width = api.getWidth();\n  var height = api.getHeight();\n  var lastStackCoords = {};\n  var lastStackCoordsOrigin = {};\n  var barWidthAndOffset = calRadialBar(zrUtil.filter(ecModel.getSeriesByType(seriesType), function (seriesModel) {\n    return !ecModel.isSeriesFiltered(seriesModel) && seriesModel.coordinateSystem && seriesModel.coordinateSystem.type === 'polar';\n  }));\n  ecModel.eachSeriesByType(seriesType, function (seriesModel) {\n    // Check series coordinate, do layout for polar only\n    if (seriesModel.coordinateSystem.type !== 'polar') {\n      return;\n    }\n\n    var data = seriesModel.getData();\n    var polar = seriesModel.coordinateSystem;\n    var angleAxis = polar.getAngleAxis();\n    var baseAxis = polar.getBaseAxis();\n    var stackId = getSeriesStackId(seriesModel);\n    var columnLayoutInfo = barWidthAndOffset[getAxisKey(baseAxis)][stackId];\n    var columnOffset = columnLayoutInfo.offset;\n    var columnWidth = columnLayoutInfo.width;\n    var valueAxis = polar.getOtherAxis(baseAxis);\n    var center = seriesModel.get('center') || ['50%', '50%'];\n    var cx = parsePercent(center[0], width);\n    var cy = parsePercent(center[1], height);\n    var barMinHeight = seriesModel.get('barMinHeight') || 0;\n    var barMinAngle = seriesModel.get('barMinAngle') || 0;\n    var valueAxisStart = valueAxis.getExtent()[0];\n    var valueMax = valueAxis.model.get('max');\n    var valueMin = valueAxis.model.get('min');\n    var coordDims = [seriesModel.coordDimToDataDim('radius')[0], seriesModel.coordDimToDataDim('angle')[0]];\n    var coords = data.mapArray(coordDims, function (radius, angle) {\n      return polar.dataToPoint([radius, angle]);\n    }, true);\n    lastStackCoords[stackId] = lastStackCoords[stackId] || [];\n    lastStackCoordsOrigin[stackId] = lastStackCoordsOrigin[stackId] || []; // Fix #4243\n\n    data.each(seriesModel.coordDimToDataDim(valueAxis.dim)[0], function (value, idx) {\n      if (isNaN(value)) {\n        return;\n      }\n\n      if (!lastStackCoords[stackId][idx]) {\n        lastStackCoords[stackId][idx] = {\n          p: valueAxisStart,\n          // Positive stack\n          n: valueAxisStart // Negative stack\n\n        };\n        lastStackCoordsOrigin[stackId][idx] = {\n          p: valueAxisStart,\n          // Positive stack\n          n: valueAxisStart // Negative stack\n\n        };\n      }\n\n      var sign = value >= 0 ? 'p' : 'n';\n      var coord = polar.pointToCoord(coords[idx]);\n      var lastCoordOrigin = lastStackCoordsOrigin[stackId][idx][sign];\n      var r0;\n      var r;\n      var startAngle;\n      var endAngle;\n\n      if (valueAxis.dim === 'radius') {\n        // radial sector\n        r0 = lastCoordOrigin;\n        r = coord[0];\n        startAngle = (-coord[1] + columnOffset) * Math.PI / 180;\n        endAngle = startAngle + columnWidth * Math.PI / 180;\n\n        if (Math.abs(r) < barMinHeight) {\n          r = r0 + (r < 0 ? -1 : 1) * barMinHeight;\n        }\n\n        lastStackCoordsOrigin[stackId][idx][sign] = r;\n      } else {\n        // tangential sector\n        r0 = coord[0] + columnOffset;\n        r = r0 + columnWidth; // clamp data if min or max is defined for valueAxis\n\n        if (valueMax != null) {\n          value = Math.min(value, valueMax);\n        }\n\n        if (valueMin != null) {\n          value = Math.max(value, valueMin);\n        }\n\n        var angle = angleAxis.dataToAngle(value);\n\n        if (Math.abs(angle - lastCoordOrigin) < barMinAngle) {\n          angle = lastCoordOrigin - (value < 0 ? -1 : 1) * barMinAngle;\n        }\n\n        startAngle = -lastCoordOrigin * Math.PI / 180;\n        endAngle = -angle * Math.PI / 180; // if the previous stack is at the end of the ring,\n        // add a round to differentiate it from origin\n\n        var extent = angleAxis.getExtent();\n        var stackCoord = angle;\n\n        if (stackCoord === extent[0] && value > 0) {\n          stackCoord = extent[1];\n        } else if (stackCoord === extent[1] && value < 0) {\n          stackCoord = extent[0];\n        }\n\n        lastStackCoordsOrigin[stackId][idx][sign] = stackCoord;\n      }\n\n      data.setItemLayout(idx, {\n        cx: cx,\n        cy: cy,\n        r0: r0,\n        r: r,\n        startAngle: startAngle,\n        endAngle: endAngle\n      });\n    }, true);\n  }, this);\n}\n/**\n * Calculate bar width and offset for radial bar charts\n */\n\n\nfunction calRadialBar(barSeries, api) {\n  // Columns info on each category axis. Key is polar name\n  var columnsMap = {};\n  zrUtil.each(barSeries, function (seriesModel, idx) {\n    var data = seriesModel.getData();\n    var polar = seriesModel.coordinateSystem;\n    var baseAxis = polar.getBaseAxis();\n    var axisExtent = baseAxis.getExtent();\n    var bandWidth = baseAxis.type === 'category' ? baseAxis.getBandWidth() : Math.abs(axisExtent[1] - axisExtent[0]) / data.count();\n    var columnsOnAxis = columnsMap[getAxisKey(baseAxis)] || {\n      bandWidth: bandWidth,\n      remainedWidth: bandWidth,\n      autoWidthCount: 0,\n      categoryGap: '20%',\n      gap: '30%',\n      stacks: {}\n    };\n    var stacks = columnsOnAxis.stacks;\n    columnsMap[getAxisKey(baseAxis)] = columnsOnAxis;\n    var stackId = getSeriesStackId(seriesModel);\n\n    if (!stacks[stackId]) {\n      columnsOnAxis.autoWidthCount++;\n    }\n\n    stacks[stackId] = stacks[stackId] || {\n      width: 0,\n      maxWidth: 0\n    };\n    var barWidth = parsePercent(seriesModel.get('barWidth'), bandWidth);\n    var barMaxWidth = parsePercent(seriesModel.get('barMaxWidth'), bandWidth);\n    var barGap = seriesModel.get('barGap');\n    var barCategoryGap = seriesModel.get('barCategoryGap');\n\n    if (barWidth && !stacks[stackId].width) {\n      barWidth = Math.min(columnsOnAxis.remainedWidth, barWidth);\n      stacks[stackId].width = barWidth;\n      columnsOnAxis.remainedWidth -= barWidth;\n    }\n\n    barMaxWidth && (stacks[stackId].maxWidth = barMaxWidth);\n    barGap != null && (columnsOnAxis.gap = barGap);\n    barCategoryGap != null && (columnsOnAxis.categoryGap = barCategoryGap);\n  });\n  var result = {};\n  zrUtil.each(columnsMap, function (columnsOnAxis, coordSysName) {\n    result[coordSysName] = {};\n    var stacks = columnsOnAxis.stacks;\n    var bandWidth = columnsOnAxis.bandWidth;\n    var categoryGap = parsePercent(columnsOnAxis.categoryGap, bandWidth);\n    var barGapPercent = parsePercent(columnsOnAxis.gap, 1);\n    var remainedWidth = columnsOnAxis.remainedWidth;\n    var autoWidthCount = columnsOnAxis.autoWidthCount;\n    var autoWidth = (remainedWidth - categoryGap) / (autoWidthCount + (autoWidthCount - 1) * barGapPercent);\n    autoWidth = Math.max(autoWidth, 0); // Find if any auto calculated bar exceeded maxBarWidth\n\n    zrUtil.each(stacks, function (column, stack) {\n      var maxWidth = column.maxWidth;\n\n      if (maxWidth && maxWidth < autoWidth) {\n        maxWidth = Math.min(maxWidth, remainedWidth);\n\n        if (column.width) {\n          maxWidth = Math.min(maxWidth, column.width);\n        }\n\n        remainedWidth -= maxWidth;\n        column.width = maxWidth;\n        autoWidthCount--;\n      }\n    }); // Recalculate width again\n\n    autoWidth = (remainedWidth - categoryGap) / (autoWidthCount + (autoWidthCount - 1) * barGapPercent);\n    autoWidth = Math.max(autoWidth, 0);\n    var widthSum = 0;\n    var lastColumn;\n    zrUtil.each(stacks, function (column, idx) {\n      if (!column.width) {\n        column.width = autoWidth;\n      }\n\n      lastColumn = column;\n      widthSum += column.width * (1 + barGapPercent);\n    });\n\n    if (lastColumn) {\n      widthSum -= lastColumn.width * barGapPercent;\n    }\n\n    var offset = -widthSum / 2;\n    zrUtil.each(stacks, function (column, stackId) {\n      result[coordSysName][stackId] = result[coordSysName][stackId] || {\n        offset: offset,\n        width: column.width\n      };\n      offset += column.width * (1 + barGapPercent);\n    });\n  });\n  return result;\n}\n\nvar _default = barLayoutPolar;\nmodule.exports = _default;"]},"metadata":{},"sourceType":"script"}