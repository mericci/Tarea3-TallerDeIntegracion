{"ast":null,"code":"var zrUtil = require(\"zrender/lib/core/util\");\n\nvar graphic = require(\"../../util/graphic\");\n\nvar layoutUtil = require(\"../../util/layout\");\n\nvar LegendView = require(\"./LegendView\");\n/**\n * Separate legend and scrollable legend to reduce package size.\n */\n\n\nvar Group = graphic.Group;\nvar WH = ['width', 'height'];\nvar XY = ['x', 'y'];\nvar ScrollableLegendView = LegendView.extend({\n  type: 'legend.scroll',\n  newlineDisabled: true,\n  init: function () {\n    ScrollableLegendView.superCall(this, 'init');\n    /**\n     * @private\n     * @type {number} For `scroll`.\n     */\n\n    this._currentIndex = 0;\n    /**\n     * @private\n     * @type {module:zrender/container/Group}\n     */\n\n    this.group.add(this._containerGroup = new Group());\n\n    this._containerGroup.add(this.getContentGroup());\n    /**\n     * @private\n     * @type {module:zrender/container/Group}\n     */\n\n\n    this.group.add(this._controllerGroup = new Group());\n    /**\n     *\n     * @private\n     */\n\n    this._showController;\n  },\n\n  /**\n   * @override\n   */\n  resetInner: function () {\n    ScrollableLegendView.superCall(this, 'resetInner');\n\n    this._controllerGroup.removeAll();\n\n    this._containerGroup.removeClipPath();\n\n    this._containerGroup.__rectSize = null;\n  },\n\n  /**\n   * @override\n   */\n  renderInner: function (itemAlign, legendModel, ecModel, api) {\n    var me = this; // Render content items.\n\n    ScrollableLegendView.superCall(this, 'renderInner', itemAlign, legendModel, ecModel, api);\n    var controllerGroup = this._controllerGroup;\n    var pageIconSize = legendModel.get('pageIconSize', true);\n\n    if (!zrUtil.isArray(pageIconSize)) {\n      pageIconSize = [pageIconSize, pageIconSize];\n    }\n\n    createPageButton('pagePrev', 0);\n    var pageTextStyleModel = legendModel.getModel('pageTextStyle');\n    controllerGroup.add(new graphic.Text({\n      name: 'pageText',\n      style: {\n        textFill: pageTextStyleModel.getTextColor(),\n        font: pageTextStyleModel.getFont(),\n        textVerticalAlign: 'middle',\n        textAlign: 'center'\n      },\n      silent: true\n    }));\n    createPageButton('pageNext', 1);\n\n    function createPageButton(name, iconIdx) {\n      var pageDataIndexName = name + 'DataIndex';\n      var icon = graphic.createIcon(legendModel.get('pageIcons', true)[legendModel.getOrient().name][iconIdx], {\n        // Buttons will be created in each render, so we do not need\n        // to worry about avoiding using legendModel kept in scope.\n        onclick: zrUtil.bind(me._pageGo, me, pageDataIndexName, legendModel, api)\n      }, {\n        x: -pageIconSize[0] / 2,\n        y: -pageIconSize[1] / 2,\n        width: pageIconSize[0],\n        height: pageIconSize[1]\n      });\n      icon.name = name;\n      controllerGroup.add(icon);\n    }\n  },\n\n  /**\n   * @override\n   */\n  layoutInner: function (legendModel, itemAlign, maxSize) {\n    var contentGroup = this.getContentGroup();\n    var containerGroup = this._containerGroup;\n    var controllerGroup = this._controllerGroup;\n    var orientIdx = legendModel.getOrient().index;\n    var wh = WH[orientIdx];\n    var hw = WH[1 - orientIdx];\n    var yx = XY[1 - orientIdx]; // Place items in contentGroup.\n\n    layoutUtil.box(legendModel.get('orient'), contentGroup, legendModel.get('itemGap'), !orientIdx ? null : maxSize.width, orientIdx ? null : maxSize.height);\n    layoutUtil.box( // Buttons in controller are layout always horizontally.\n    'horizontal', controllerGroup, legendModel.get('pageButtonItemGap', true));\n    var contentRect = contentGroup.getBoundingRect();\n    var controllerRect = controllerGroup.getBoundingRect();\n    var showController = this._showController = contentRect[wh] > maxSize[wh];\n    var contentPos = [-contentRect.x, -contentRect.y]; // Remain contentPos when scroll animation perfroming.\n\n    contentPos[orientIdx] = contentGroup.position[orientIdx]; // Layout container group based on 0.\n\n    var containerPos = [0, 0];\n    var controllerPos = [-controllerRect.x, -controllerRect.y];\n    var pageButtonGap = zrUtil.retrieve2(legendModel.get('pageButtonGap', true), legendModel.get('itemGap', true)); // Place containerGroup and controllerGroup and contentGroup.\n\n    if (showController) {\n      var pageButtonPosition = legendModel.get('pageButtonPosition', true); // controller is on the right / bottom.\n\n      if (pageButtonPosition === 'end') {\n        controllerPos[orientIdx] += maxSize[wh] - controllerRect[wh];\n      } // controller is on the left / top.\n      else {\n          containerPos[orientIdx] += controllerRect[wh] + pageButtonGap;\n        }\n    } // Always align controller to content as 'middle'.\n\n\n    controllerPos[1 - orientIdx] += contentRect[hw] / 2 - controllerRect[hw] / 2;\n    contentGroup.attr('position', contentPos);\n    containerGroup.attr('position', containerPos);\n    controllerGroup.attr('position', controllerPos); // Calculate `mainRect` and set `clipPath`.\n    // mainRect should not be calculated by `this.group.getBoundingRect()`\n    // for sake of the overflow.\n\n    var mainRect = this.group.getBoundingRect();\n    var mainRect = {\n      x: 0,\n      y: 0\n    }; // Consider content may be overflow (should be clipped).\n\n    mainRect[wh] = showController ? maxSize[wh] : contentRect[wh];\n    mainRect[hw] = Math.max(contentRect[hw], controllerRect[hw]); // `containerRect[yx] + containerPos[1 - orientIdx]` is 0.\n\n    mainRect[yx] = Math.min(0, controllerRect[yx] + controllerPos[1 - orientIdx]);\n    containerGroup.__rectSize = maxSize[wh];\n\n    if (showController) {\n      var clipShape = {\n        x: 0,\n        y: 0\n      };\n      clipShape[wh] = Math.max(maxSize[wh] - controllerRect[wh] - pageButtonGap, 0);\n      clipShape[hw] = mainRect[hw];\n      containerGroup.setClipPath(new graphic.Rect({\n        shape: clipShape\n      })); // Consider content may be larger than container, container rect\n      // can not be obtained from `containerGroup.getBoundingRect()`.\n\n      containerGroup.__rectSize = clipShape[wh];\n    } else {\n      // Do not remove or ignore controller. Keep them set as place holders.\n      controllerGroup.eachChild(function (child) {\n        child.attr({\n          invisible: true,\n          silent: true\n        });\n      });\n    } // Content translate animation.\n\n\n    var pageInfo = this._getPageInfo(legendModel);\n\n    pageInfo.pageIndex != null && graphic.updateProps(contentGroup, {\n      position: pageInfo.contentPosition\n    }, // When switch from \"show controller\" to \"not show controller\", view should be\n    // updated immediately without animation, otherwise causes weird efffect.\n    showController ? legendModel : false);\n\n    this._updatePageInfoView(legendModel, pageInfo);\n\n    return mainRect;\n  },\n  _pageGo: function (to, legendModel, api) {\n    var scrollDataIndex = this._getPageInfo(legendModel)[to];\n\n    scrollDataIndex != null && api.dispatchAction({\n      type: 'legendScroll',\n      scrollDataIndex: scrollDataIndex,\n      legendId: legendModel.id\n    });\n  },\n  _updatePageInfoView: function (legendModel, pageInfo) {\n    var controllerGroup = this._controllerGroup;\n    zrUtil.each(['pagePrev', 'pageNext'], function (name) {\n      var canJump = pageInfo[name + 'DataIndex'] != null;\n      var icon = controllerGroup.childOfName(name);\n\n      if (icon) {\n        icon.setStyle('fill', canJump ? legendModel.get('pageIconColor', true) : legendModel.get('pageIconInactiveColor', true));\n        icon.cursor = canJump ? 'pointer' : 'default';\n      }\n    });\n    var pageText = controllerGroup.childOfName('pageText');\n    var pageFormatter = legendModel.get('pageFormatter');\n    var pageIndex = pageInfo.pageIndex;\n    var current = pageIndex != null ? pageIndex + 1 : 0;\n    var total = pageInfo.pageCount;\n    pageText && pageFormatter && pageText.setStyle('text', zrUtil.isString(pageFormatter) ? pageFormatter.replace('{current}', current).replace('{total}', total) : pageFormatter({\n      current: current,\n      total: total\n    }));\n  },\n\n  /**\n   * @param {module:echarts/model/Model} legendModel\n   * @return {Object} {\n   *  contentPosition: Array.<number>, null when data item not found.\n   *  pageIndex: number, null when data item not found.\n   *  pageCount: number, always be a number, can be 0.\n   *  pagePrevDataIndex: number, null when no next page.\n   *  pageNextDataIndex: number, null when no previous page.\n   * }\n   */\n  _getPageInfo: function (legendModel) {\n    // Align left or top by the current dataIndex.\n    var currDataIndex = legendModel.get('scrollDataIndex', true);\n    var contentGroup = this.getContentGroup();\n    var contentRect = contentGroup.getBoundingRect();\n    var containerRectSize = this._containerGroup.__rectSize;\n    var orientIdx = legendModel.getOrient().index;\n    var wh = WH[orientIdx];\n    var hw = WH[1 - orientIdx];\n    var xy = XY[orientIdx];\n    var contentPos = contentGroup.position.slice();\n    var pageIndex;\n    var pagePrevDataIndex;\n    var pageNextDataIndex;\n    var targetItemGroup;\n\n    if (this._showController) {\n      contentGroup.eachChild(function (child) {\n        if (child.__legendDataIndex === currDataIndex) {\n          targetItemGroup = child;\n        }\n      });\n    } else {\n      targetItemGroup = contentGroup.childAt(0);\n    }\n\n    var pageCount = containerRectSize ? Math.ceil(contentRect[wh] / containerRectSize) : 0;\n\n    if (targetItemGroup) {\n      var itemRect = targetItemGroup.getBoundingRect();\n      var itemLoc = targetItemGroup.position[orientIdx] + itemRect[xy];\n      contentPos[orientIdx] = -itemLoc - contentRect[xy];\n      pageIndex = Math.floor(pageCount * (itemLoc + itemRect[xy] + containerRectSize / 2) / contentRect[wh]);\n      pageIndex = contentRect[wh] && pageCount ? Math.max(0, Math.min(pageCount - 1, pageIndex)) : -1;\n      var winRect = {\n        x: 0,\n        y: 0\n      };\n      winRect[wh] = containerRectSize;\n      winRect[hw] = contentRect[hw];\n      winRect[xy] = -contentPos[orientIdx] - contentRect[xy];\n      var startIdx;\n      var children = contentGroup.children();\n      contentGroup.eachChild(function (child, index) {\n        var itemRect = getItemRect(child);\n\n        if (itemRect.intersect(winRect)) {\n          startIdx == null && (startIdx = index); // It is user-friendly that the last item shown in the\n          // current window is shown at the begining of next window.\n\n          pageNextDataIndex = child.__legendDataIndex;\n        } // If the last item is shown entirely, no next page.\n\n\n        if (index === children.length - 1 && itemRect[xy] + itemRect[wh] <= winRect[xy] + winRect[wh]) {\n          pageNextDataIndex = null;\n        }\n      }); // Always align based on the left/top most item, so the left/top most\n      // item in the previous window is needed to be found here.\n\n      if (startIdx != null) {\n        var startItem = children[startIdx];\n        var startRect = getItemRect(startItem);\n        winRect[xy] = startRect[xy] + startRect[wh] - winRect[wh]; // If the first item is shown entirely, no previous page.\n\n        if (startIdx <= 0 && startRect[xy] >= winRect[xy]) {\n          pagePrevDataIndex = null;\n        } else {\n          while (startIdx > 0 && getItemRect(children[startIdx - 1]).intersect(winRect)) {\n            startIdx--;\n          }\n\n          pagePrevDataIndex = children[startIdx].__legendDataIndex;\n        }\n      }\n    }\n\n    return {\n      contentPosition: contentPos,\n      pageIndex: pageIndex,\n      pageCount: pageCount,\n      pagePrevDataIndex: pagePrevDataIndex,\n      pageNextDataIndex: pageNextDataIndex\n    };\n\n    function getItemRect(el) {\n      var itemRect = el.getBoundingRect().clone();\n      itemRect[xy] += el.position[orientIdx];\n      return itemRect;\n    }\n  }\n});\nvar _default = ScrollableLegendView;\nmodule.exports = _default;","map":{"version":3,"sources":["/home/martin/Escritorio/Taller de Integracion/Tarea3-TallerDeIntegracion/node_modules/react-echarts/node_modules/echarts/lib/component/legend/ScrollableLegendView.js"],"names":["zrUtil","require","graphic","layoutUtil","LegendView","Group","WH","XY","ScrollableLegendView","extend","type","newlineDisabled","init","superCall","_currentIndex","group","add","_containerGroup","getContentGroup","_controllerGroup","_showController","resetInner","removeAll","removeClipPath","__rectSize","renderInner","itemAlign","legendModel","ecModel","api","me","controllerGroup","pageIconSize","get","isArray","createPageButton","pageTextStyleModel","getModel","Text","name","style","textFill","getTextColor","font","getFont","textVerticalAlign","textAlign","silent","iconIdx","pageDataIndexName","icon","createIcon","getOrient","onclick","bind","_pageGo","x","y","width","height","layoutInner","maxSize","contentGroup","containerGroup","orientIdx","index","wh","hw","yx","box","contentRect","getBoundingRect","controllerRect","showController","contentPos","position","containerPos","controllerPos","pageButtonGap","retrieve2","pageButtonPosition","attr","mainRect","Math","max","min","clipShape","setClipPath","Rect","shape","eachChild","child","invisible","pageInfo","_getPageInfo","pageIndex","updateProps","contentPosition","_updatePageInfoView","to","scrollDataIndex","dispatchAction","legendId","id","each","canJump","childOfName","setStyle","cursor","pageText","pageFormatter","current","total","pageCount","isString","replace","currDataIndex","containerRectSize","xy","slice","pagePrevDataIndex","pageNextDataIndex","targetItemGroup","__legendDataIndex","childAt","ceil","itemRect","itemLoc","floor","winRect","startIdx","children","getItemRect","intersect","length","startItem","startRect","el","clone","_default","module","exports"],"mappings":"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","sourcesContent":["var zrUtil = require(\"zrender/lib/core/util\");\n\nvar graphic = require(\"../../util/graphic\");\n\nvar layoutUtil = require(\"../../util/layout\");\n\nvar LegendView = require(\"./LegendView\");\n\n/**\n * Separate legend and scrollable legend to reduce package size.\n */\nvar Group = graphic.Group;\nvar WH = ['width', 'height'];\nvar XY = ['x', 'y'];\nvar ScrollableLegendView = LegendView.extend({\n  type: 'legend.scroll',\n  newlineDisabled: true,\n  init: function () {\n    ScrollableLegendView.superCall(this, 'init');\n    /**\n     * @private\n     * @type {number} For `scroll`.\n     */\n\n    this._currentIndex = 0;\n    /**\n     * @private\n     * @type {module:zrender/container/Group}\n     */\n\n    this.group.add(this._containerGroup = new Group());\n\n    this._containerGroup.add(this.getContentGroup());\n    /**\n     * @private\n     * @type {module:zrender/container/Group}\n     */\n\n\n    this.group.add(this._controllerGroup = new Group());\n    /**\n     *\n     * @private\n     */\n\n    this._showController;\n  },\n\n  /**\n   * @override\n   */\n  resetInner: function () {\n    ScrollableLegendView.superCall(this, 'resetInner');\n\n    this._controllerGroup.removeAll();\n\n    this._containerGroup.removeClipPath();\n\n    this._containerGroup.__rectSize = null;\n  },\n\n  /**\n   * @override\n   */\n  renderInner: function (itemAlign, legendModel, ecModel, api) {\n    var me = this; // Render content items.\n\n    ScrollableLegendView.superCall(this, 'renderInner', itemAlign, legendModel, ecModel, api);\n    var controllerGroup = this._controllerGroup;\n    var pageIconSize = legendModel.get('pageIconSize', true);\n\n    if (!zrUtil.isArray(pageIconSize)) {\n      pageIconSize = [pageIconSize, pageIconSize];\n    }\n\n    createPageButton('pagePrev', 0);\n    var pageTextStyleModel = legendModel.getModel('pageTextStyle');\n    controllerGroup.add(new graphic.Text({\n      name: 'pageText',\n      style: {\n        textFill: pageTextStyleModel.getTextColor(),\n        font: pageTextStyleModel.getFont(),\n        textVerticalAlign: 'middle',\n        textAlign: 'center'\n      },\n      silent: true\n    }));\n    createPageButton('pageNext', 1);\n\n    function createPageButton(name, iconIdx) {\n      var pageDataIndexName = name + 'DataIndex';\n      var icon = graphic.createIcon(legendModel.get('pageIcons', true)[legendModel.getOrient().name][iconIdx], {\n        // Buttons will be created in each render, so we do not need\n        // to worry about avoiding using legendModel kept in scope.\n        onclick: zrUtil.bind(me._pageGo, me, pageDataIndexName, legendModel, api)\n      }, {\n        x: -pageIconSize[0] / 2,\n        y: -pageIconSize[1] / 2,\n        width: pageIconSize[0],\n        height: pageIconSize[1]\n      });\n      icon.name = name;\n      controllerGroup.add(icon);\n    }\n  },\n\n  /**\n   * @override\n   */\n  layoutInner: function (legendModel, itemAlign, maxSize) {\n    var contentGroup = this.getContentGroup();\n    var containerGroup = this._containerGroup;\n    var controllerGroup = this._controllerGroup;\n    var orientIdx = legendModel.getOrient().index;\n    var wh = WH[orientIdx];\n    var hw = WH[1 - orientIdx];\n    var yx = XY[1 - orientIdx]; // Place items in contentGroup.\n\n    layoutUtil.box(legendModel.get('orient'), contentGroup, legendModel.get('itemGap'), !orientIdx ? null : maxSize.width, orientIdx ? null : maxSize.height);\n    layoutUtil.box( // Buttons in controller are layout always horizontally.\n    'horizontal', controllerGroup, legendModel.get('pageButtonItemGap', true));\n    var contentRect = contentGroup.getBoundingRect();\n    var controllerRect = controllerGroup.getBoundingRect();\n    var showController = this._showController = contentRect[wh] > maxSize[wh];\n    var contentPos = [-contentRect.x, -contentRect.y]; // Remain contentPos when scroll animation perfroming.\n\n    contentPos[orientIdx] = contentGroup.position[orientIdx]; // Layout container group based on 0.\n\n    var containerPos = [0, 0];\n    var controllerPos = [-controllerRect.x, -controllerRect.y];\n    var pageButtonGap = zrUtil.retrieve2(legendModel.get('pageButtonGap', true), legendModel.get('itemGap', true)); // Place containerGroup and controllerGroup and contentGroup.\n\n    if (showController) {\n      var pageButtonPosition = legendModel.get('pageButtonPosition', true); // controller is on the right / bottom.\n\n      if (pageButtonPosition === 'end') {\n        controllerPos[orientIdx] += maxSize[wh] - controllerRect[wh];\n      } // controller is on the left / top.\n      else {\n          containerPos[orientIdx] += controllerRect[wh] + pageButtonGap;\n        }\n    } // Always align controller to content as 'middle'.\n\n\n    controllerPos[1 - orientIdx] += contentRect[hw] / 2 - controllerRect[hw] / 2;\n    contentGroup.attr('position', contentPos);\n    containerGroup.attr('position', containerPos);\n    controllerGroup.attr('position', controllerPos); // Calculate `mainRect` and set `clipPath`.\n    // mainRect should not be calculated by `this.group.getBoundingRect()`\n    // for sake of the overflow.\n\n    var mainRect = this.group.getBoundingRect();\n    var mainRect = {\n      x: 0,\n      y: 0\n    }; // Consider content may be overflow (should be clipped).\n\n    mainRect[wh] = showController ? maxSize[wh] : contentRect[wh];\n    mainRect[hw] = Math.max(contentRect[hw], controllerRect[hw]); // `containerRect[yx] + containerPos[1 - orientIdx]` is 0.\n\n    mainRect[yx] = Math.min(0, controllerRect[yx] + controllerPos[1 - orientIdx]);\n    containerGroup.__rectSize = maxSize[wh];\n\n    if (showController) {\n      var clipShape = {\n        x: 0,\n        y: 0\n      };\n      clipShape[wh] = Math.max(maxSize[wh] - controllerRect[wh] - pageButtonGap, 0);\n      clipShape[hw] = mainRect[hw];\n      containerGroup.setClipPath(new graphic.Rect({\n        shape: clipShape\n      })); // Consider content may be larger than container, container rect\n      // can not be obtained from `containerGroup.getBoundingRect()`.\n\n      containerGroup.__rectSize = clipShape[wh];\n    } else {\n      // Do not remove or ignore controller. Keep them set as place holders.\n      controllerGroup.eachChild(function (child) {\n        child.attr({\n          invisible: true,\n          silent: true\n        });\n      });\n    } // Content translate animation.\n\n\n    var pageInfo = this._getPageInfo(legendModel);\n\n    pageInfo.pageIndex != null && graphic.updateProps(contentGroup, {\n      position: pageInfo.contentPosition\n    }, // When switch from \"show controller\" to \"not show controller\", view should be\n    // updated immediately without animation, otherwise causes weird efffect.\n    showController ? legendModel : false);\n\n    this._updatePageInfoView(legendModel, pageInfo);\n\n    return mainRect;\n  },\n  _pageGo: function (to, legendModel, api) {\n    var scrollDataIndex = this._getPageInfo(legendModel)[to];\n\n    scrollDataIndex != null && api.dispatchAction({\n      type: 'legendScroll',\n      scrollDataIndex: scrollDataIndex,\n      legendId: legendModel.id\n    });\n  },\n  _updatePageInfoView: function (legendModel, pageInfo) {\n    var controllerGroup = this._controllerGroup;\n    zrUtil.each(['pagePrev', 'pageNext'], function (name) {\n      var canJump = pageInfo[name + 'DataIndex'] != null;\n      var icon = controllerGroup.childOfName(name);\n\n      if (icon) {\n        icon.setStyle('fill', canJump ? legendModel.get('pageIconColor', true) : legendModel.get('pageIconInactiveColor', true));\n        icon.cursor = canJump ? 'pointer' : 'default';\n      }\n    });\n    var pageText = controllerGroup.childOfName('pageText');\n    var pageFormatter = legendModel.get('pageFormatter');\n    var pageIndex = pageInfo.pageIndex;\n    var current = pageIndex != null ? pageIndex + 1 : 0;\n    var total = pageInfo.pageCount;\n    pageText && pageFormatter && pageText.setStyle('text', zrUtil.isString(pageFormatter) ? pageFormatter.replace('{current}', current).replace('{total}', total) : pageFormatter({\n      current: current,\n      total: total\n    }));\n  },\n\n  /**\n   * @param {module:echarts/model/Model} legendModel\n   * @return {Object} {\n   *  contentPosition: Array.<number>, null when data item not found.\n   *  pageIndex: number, null when data item not found.\n   *  pageCount: number, always be a number, can be 0.\n   *  pagePrevDataIndex: number, null when no next page.\n   *  pageNextDataIndex: number, null when no previous page.\n   * }\n   */\n  _getPageInfo: function (legendModel) {\n    // Align left or top by the current dataIndex.\n    var currDataIndex = legendModel.get('scrollDataIndex', true);\n    var contentGroup = this.getContentGroup();\n    var contentRect = contentGroup.getBoundingRect();\n    var containerRectSize = this._containerGroup.__rectSize;\n    var orientIdx = legendModel.getOrient().index;\n    var wh = WH[orientIdx];\n    var hw = WH[1 - orientIdx];\n    var xy = XY[orientIdx];\n    var contentPos = contentGroup.position.slice();\n    var pageIndex;\n    var pagePrevDataIndex;\n    var pageNextDataIndex;\n    var targetItemGroup;\n\n    if (this._showController) {\n      contentGroup.eachChild(function (child) {\n        if (child.__legendDataIndex === currDataIndex) {\n          targetItemGroup = child;\n        }\n      });\n    } else {\n      targetItemGroup = contentGroup.childAt(0);\n    }\n\n    var pageCount = containerRectSize ? Math.ceil(contentRect[wh] / containerRectSize) : 0;\n\n    if (targetItemGroup) {\n      var itemRect = targetItemGroup.getBoundingRect();\n      var itemLoc = targetItemGroup.position[orientIdx] + itemRect[xy];\n      contentPos[orientIdx] = -itemLoc - contentRect[xy];\n      pageIndex = Math.floor(pageCount * (itemLoc + itemRect[xy] + containerRectSize / 2) / contentRect[wh]);\n      pageIndex = contentRect[wh] && pageCount ? Math.max(0, Math.min(pageCount - 1, pageIndex)) : -1;\n      var winRect = {\n        x: 0,\n        y: 0\n      };\n      winRect[wh] = containerRectSize;\n      winRect[hw] = contentRect[hw];\n      winRect[xy] = -contentPos[orientIdx] - contentRect[xy];\n      var startIdx;\n      var children = contentGroup.children();\n      contentGroup.eachChild(function (child, index) {\n        var itemRect = getItemRect(child);\n\n        if (itemRect.intersect(winRect)) {\n          startIdx == null && (startIdx = index); // It is user-friendly that the last item shown in the\n          // current window is shown at the begining of next window.\n\n          pageNextDataIndex = child.__legendDataIndex;\n        } // If the last item is shown entirely, no next page.\n\n\n        if (index === children.length - 1 && itemRect[xy] + itemRect[wh] <= winRect[xy] + winRect[wh]) {\n          pageNextDataIndex = null;\n        }\n      }); // Always align based on the left/top most item, so the left/top most\n      // item in the previous window is needed to be found here.\n\n      if (startIdx != null) {\n        var startItem = children[startIdx];\n        var startRect = getItemRect(startItem);\n        winRect[xy] = startRect[xy] + startRect[wh] - winRect[wh]; // If the first item is shown entirely, no previous page.\n\n        if (startIdx <= 0 && startRect[xy] >= winRect[xy]) {\n          pagePrevDataIndex = null;\n        } else {\n          while (startIdx > 0 && getItemRect(children[startIdx - 1]).intersect(winRect)) {\n            startIdx--;\n          }\n\n          pagePrevDataIndex = children[startIdx].__legendDataIndex;\n        }\n      }\n    }\n\n    return {\n      contentPosition: contentPos,\n      pageIndex: pageIndex,\n      pageCount: pageCount,\n      pagePrevDataIndex: pagePrevDataIndex,\n      pageNextDataIndex: pageNextDataIndex\n    };\n\n    function getItemRect(el) {\n      var itemRect = el.getBoundingRect().clone();\n      itemRect[xy] += el.position[orientIdx];\n      return itemRect;\n    }\n  }\n});\nvar _default = ScrollableLegendView;\nmodule.exports = _default;"]},"metadata":{},"sourceType":"script"}