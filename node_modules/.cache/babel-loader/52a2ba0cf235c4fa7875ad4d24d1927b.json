{"ast":null,"code":"var vec2 = require(\"zrender/lib/core/vector\");\n\nvar scaleAndAdd = vec2.scaleAndAdd; // function adjacentNode(n, e) {\n//     return e.n1 === n ? e.n2 : e.n1;\n// }\n\nfunction forceLayout(nodes, edges, opts) {\n  var rect = opts.rect;\n  var width = rect.width;\n  var height = rect.height;\n  var center = [rect.x + width / 2, rect.y + height / 2]; // var scale = opts.scale || 1;\n\n  var gravity = opts.gravity == null ? 0.1 : opts.gravity; // for (var i = 0; i < edges.length; i++) {\n  //     var e = edges[i];\n  //     var n1 = e.n1;\n  //     var n2 = e.n2;\n  //     n1.edges = n1.edges || [];\n  //     n2.edges = n2.edges || [];\n  //     n1.edges.push(e);\n  //     n2.edges.push(e);\n  // }\n  // Init position\n\n  for (var i = 0; i < nodes.length; i++) {\n    var n = nodes[i];\n\n    if (!n.p) {\n      // Use the position from first adjecent node with defined position\n      // Or use a random position\n      // From d3\n      // if (n.edges) {\n      //     var j = -1;\n      //     while (++j < n.edges.length) {\n      //         var e = n.edges[j];\n      //         var other = adjacentNode(n, e);\n      //         if (other.p) {\n      //             n.p = vec2.clone(other.p);\n      //             break;\n      //         }\n      //     }\n      // }\n      // if (!n.p) {\n      n.p = vec2.create(width * (Math.random() - 0.5) + center[0], height * (Math.random() - 0.5) + center[1]); // }\n    }\n\n    n.pp = vec2.clone(n.p);\n    n.edges = null;\n  } // Formula in 'Graph Drawing by Force-directed Placement'\n  // var k = scale * Math.sqrt(width * height / nodes.length);\n  // var k2 = k * k;\n\n\n  var friction = 0.6;\n  return {\n    warmUp: function () {\n      friction = 0.5;\n    },\n    setFixed: function (idx) {\n      nodes[idx].fixed = true;\n    },\n    setUnfixed: function (idx) {\n      nodes[idx].fixed = false;\n    },\n    step: function (cb) {\n      var v12 = [];\n      var nLen = nodes.length;\n\n      for (var i = 0; i < edges.length; i++) {\n        var e = edges[i];\n        var n1 = e.n1;\n        var n2 = e.n2;\n        vec2.sub(v12, n2.p, n1.p);\n        var d = vec2.len(v12) - e.d;\n        var w = n2.w / (n1.w + n2.w);\n\n        if (isNaN(w)) {\n          w = 0;\n        }\n\n        vec2.normalize(v12, v12);\n        !n1.fixed && scaleAndAdd(n1.p, n1.p, v12, w * d * friction);\n        !n2.fixed && scaleAndAdd(n2.p, n2.p, v12, -(1 - w) * d * friction);\n      } // Gravity\n\n\n      for (var i = 0; i < nLen; i++) {\n        var n = nodes[i];\n\n        if (!n.fixed) {\n          vec2.sub(v12, center, n.p); // var d = vec2.len(v12);\n          // vec2.scale(v12, v12, 1 / d);\n          // var gravityFactor = gravity;\n\n          scaleAndAdd(n.p, n.p, v12, gravity * friction);\n        }\n      } // Repulsive\n      // PENDING\n\n\n      for (var i = 0; i < nLen; i++) {\n        var n1 = nodes[i];\n\n        for (var j = i + 1; j < nLen; j++) {\n          var n2 = nodes[j];\n          vec2.sub(v12, n2.p, n1.p);\n          var d = vec2.len(v12);\n\n          if (d === 0) {\n            // Random repulse\n            vec2.set(v12, Math.random() - 0.5, Math.random() - 0.5);\n            d = 1;\n          }\n\n          var repFact = (n1.rep + n2.rep) / d / d;\n          !n1.fixed && scaleAndAdd(n1.pp, n1.pp, v12, repFact);\n          !n2.fixed && scaleAndAdd(n2.pp, n2.pp, v12, -repFact);\n        }\n      }\n\n      var v = [];\n\n      for (var i = 0; i < nLen; i++) {\n        var n = nodes[i];\n\n        if (!n.fixed) {\n          vec2.sub(v, n.p, n.pp);\n          scaleAndAdd(n.p, n.p, v, friction);\n          vec2.copy(n.pp, n.p);\n        }\n      }\n\n      friction = friction * 0.992;\n      cb && cb(nodes, edges, friction < 0.01);\n    }\n  };\n}\n\nexports.forceLayout = forceLayout;","map":{"version":3,"sources":["/home/martin/Escritorio/Taller de Integracion/Tarea3-TallerDeIntegracion/node_modules/react-echarts/node_modules/echarts/lib/chart/graph/forceHelper.js"],"names":["vec2","require","scaleAndAdd","forceLayout","nodes","edges","opts","rect","width","height","center","x","y","gravity","i","length","n","p","create","Math","random","pp","clone","friction","warmUp","setFixed","idx","fixed","setUnfixed","step","cb","v12","nLen","e","n1","n2","sub","d","len","w","isNaN","normalize","j","set","repFact","rep","v","copy","exports"],"mappings":"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","sourcesContent":["var vec2 = require(\"zrender/lib/core/vector\");\n\nvar scaleAndAdd = vec2.scaleAndAdd; // function adjacentNode(n, e) {\n//     return e.n1 === n ? e.n2 : e.n1;\n// }\n\nfunction forceLayout(nodes, edges, opts) {\n  var rect = opts.rect;\n  var width = rect.width;\n  var height = rect.height;\n  var center = [rect.x + width / 2, rect.y + height / 2]; // var scale = opts.scale || 1;\n\n  var gravity = opts.gravity == null ? 0.1 : opts.gravity; // for (var i = 0; i < edges.length; i++) {\n  //     var e = edges[i];\n  //     var n1 = e.n1;\n  //     var n2 = e.n2;\n  //     n1.edges = n1.edges || [];\n  //     n2.edges = n2.edges || [];\n  //     n1.edges.push(e);\n  //     n2.edges.push(e);\n  // }\n  // Init position\n\n  for (var i = 0; i < nodes.length; i++) {\n    var n = nodes[i];\n\n    if (!n.p) {\n      // Use the position from first adjecent node with defined position\n      // Or use a random position\n      // From d3\n      // if (n.edges) {\n      //     var j = -1;\n      //     while (++j < n.edges.length) {\n      //         var e = n.edges[j];\n      //         var other = adjacentNode(n, e);\n      //         if (other.p) {\n      //             n.p = vec2.clone(other.p);\n      //             break;\n      //         }\n      //     }\n      // }\n      // if (!n.p) {\n      n.p = vec2.create(width * (Math.random() - 0.5) + center[0], height * (Math.random() - 0.5) + center[1]); // }\n    }\n\n    n.pp = vec2.clone(n.p);\n    n.edges = null;\n  } // Formula in 'Graph Drawing by Force-directed Placement'\n  // var k = scale * Math.sqrt(width * height / nodes.length);\n  // var k2 = k * k;\n\n\n  var friction = 0.6;\n  return {\n    warmUp: function () {\n      friction = 0.5;\n    },\n    setFixed: function (idx) {\n      nodes[idx].fixed = true;\n    },\n    setUnfixed: function (idx) {\n      nodes[idx].fixed = false;\n    },\n    step: function (cb) {\n      var v12 = [];\n      var nLen = nodes.length;\n\n      for (var i = 0; i < edges.length; i++) {\n        var e = edges[i];\n        var n1 = e.n1;\n        var n2 = e.n2;\n        vec2.sub(v12, n2.p, n1.p);\n        var d = vec2.len(v12) - e.d;\n        var w = n2.w / (n1.w + n2.w);\n\n        if (isNaN(w)) {\n          w = 0;\n        }\n\n        vec2.normalize(v12, v12);\n        !n1.fixed && scaleAndAdd(n1.p, n1.p, v12, w * d * friction);\n        !n2.fixed && scaleAndAdd(n2.p, n2.p, v12, -(1 - w) * d * friction);\n      } // Gravity\n\n\n      for (var i = 0; i < nLen; i++) {\n        var n = nodes[i];\n\n        if (!n.fixed) {\n          vec2.sub(v12, center, n.p); // var d = vec2.len(v12);\n          // vec2.scale(v12, v12, 1 / d);\n          // var gravityFactor = gravity;\n\n          scaleAndAdd(n.p, n.p, v12, gravity * friction);\n        }\n      } // Repulsive\n      // PENDING\n\n\n      for (var i = 0; i < nLen; i++) {\n        var n1 = nodes[i];\n\n        for (var j = i + 1; j < nLen; j++) {\n          var n2 = nodes[j];\n          vec2.sub(v12, n2.p, n1.p);\n          var d = vec2.len(v12);\n\n          if (d === 0) {\n            // Random repulse\n            vec2.set(v12, Math.random() - 0.5, Math.random() - 0.5);\n            d = 1;\n          }\n\n          var repFact = (n1.rep + n2.rep) / d / d;\n          !n1.fixed && scaleAndAdd(n1.pp, n1.pp, v12, repFact);\n          !n2.fixed && scaleAndAdd(n2.pp, n2.pp, v12, -repFact);\n        }\n      }\n\n      var v = [];\n\n      for (var i = 0; i < nLen; i++) {\n        var n = nodes[i];\n\n        if (!n.fixed) {\n          vec2.sub(v, n.p, n.pp);\n          scaleAndAdd(n.p, n.p, v, friction);\n          vec2.copy(n.pp, n.p);\n        }\n      }\n\n      friction = friction * 0.992;\n      cb && cb(nodes, edges, friction < 0.01);\n    }\n  };\n}\n\nexports.forceLayout = forceLayout;"]},"metadata":{},"sourceType":"script"}